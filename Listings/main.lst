C51 COMPILER V9.56.0.0   MAIN                                                              11/25/2017 12:12:32 PAGE 1   


C51 COMPILER V9.56.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE main.c LARGE OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listing
                    -s\main.lst) OBJECT(.\Objects\main.obj)

line level    source

   1          #include <main.h>
   2          #include "macros.h"
   3          
   4          //-------------------------------------------------------------------------------------------------------
   5          // Global Declarations
   6          //-------------------------------------------------------------------------------------------------------
   7          unsigned char tsByte;
   8          
   9          bit splashEnd = 0;
  10          bit screenReset = 0;
  11          bit ackFromScreen = 0;
  12          bit tsCommandReceived = 0;
  13          bit tsCommandTransmitted = 0;
  14          bit SMB_RW;                                                                                     // Software flag to indicate Read or Writ
             -e
  15          
  16          unsigned char sharedDataRx[SHARED_DATA_MAX];
  17          unsigned char sharedDataTx[SHARED_DATA_MAX];
  18          unsigned char eepromTx[EEPROM_TX_BUFFER];
  19          unsigned char eepromRx[EEPROM_RX_BUFFER];
  20          unsigned char eepromPageTx[EEPROM_PAGE_SIZE];
  21          
  22          unsigned int pageCount;
  23          unsigned int bytesExtra;
  24          unsigned int eepromPageCounter;
  25          unsigned int startAddr;
  26          unsigned char slaveAddr;                                                                        // Target SMBus slave address
  27          unsigned char eepromDataByte;
  28          
  29          unsigned int numBytesRD;
  30          unsigned int numBytesWR;
  31          unsigned char slaveWriteDone;
  32          unsigned char slaveReadDone;
  33          unsigned char eepromWriteDone;
  34          unsigned char eepromReaddone;
  35          unsigned char rtcWriteDone;
  36          unsigned char rtcReadDone;
  37          
  38          unsigned char tsRxBuffer[RX_BUFFER_SIZE];
  39          unsigned char tsTxBuffer[TX_BUFFER_SIZE];
  40          unsigned char userCommand[RX_BUFFER_SIZE];
  41          
  42          unsigned int tsRxIn;
  43          unsigned int tsRxOut; 
  44          unsigned int tsTxIn;
  45          unsigned int tsTxOut;
  46          
  47          bit tsRxEmpty;
  48          bit tsTxEmpty;
  49          bit tsLastCharGone;     
  50          
  51          bit screenChanged;
  52          unsigned char screen;
  53          unsigned char lastScreen;
C51 COMPILER V9.56.0.0   MAIN                                                              11/25/2017 12:12:32 PAGE 2   

  54          
  55          const char code * Font[] = {/*0*/       "m10B", 
  56                                                                  /*1*/   "m12B",
  57                                                                  /*2*/   "m14B",
  58                                                                  /*3*/   "m16B",
  59                                                                  /*4*/   "m20B",
  60                                                                  /*5*/   "m24B",
  61                                                                  /*6*/   "m32B",
  62                                                                  /*7*/   "m48",
  63                                                                  /*8*/   "m64"};
  64          
  65          bit SMB_BUSY = 0;                                                                               // Set to claim the bus, clear to free
  66          bit SMB_RW;                                                                     // Software flag to indica
             -te Read or Write
  67          
  68          unsigned int startAddr;
  69          unsigned char slaveAddr;                                                                        // Target SMBus slave address
  70          
  71          unsigned int numBytesRD;
  72          unsigned int numBytesWR;
  73          
  74          unsigned char slaveWriteDone;
  75          unsigned char slaveReadDone;
  76                                      
  77          unsigned char roomTemp1;
  78          unsigned char roomTemp2;
  79          unsigned char roomTemp3;
  80                                      
  81          unsigned char seconds;
  82          unsigned char minutes;
  83          unsigned char hours;
  84          unsigned char hours24;
  85          unsigned char amPm;
  86          unsigned char day;
  87          unsigned char date;
  88          unsigned char month;
  89          unsigned char year;
  90          unsigned char century;
  91          unsigned char timeMode;
  92          unsigned char currentIndex = 0;
  93          unsigned char minuteIndex = 0;
  94          unsigned char hourIndex = 0;
  95          
  96          unsigned char currentDate;
  97          unsigned char currentMonth;
  98          unsigned char currentYear;
  99          
 100          unsigned char realTimeClockItems;
 101          
 102          unsigned char adjustedSeconds;
 103          unsigned char adjustedMinutes;
 104          unsigned char adjustedHours;
 105          unsigned char adjustedAmPm;
 106          unsigned char adjustedDay;
 107          unsigned char adjustedDate;
 108          unsigned char adjustedMonth;
 109          unsigned char adjustedYear;
 110          unsigned char adjustedCentury;
 111          unsigned char adjustedTimeMode;
 112          
 113          bit monthUpdated;
 114          bit dateUpdated;
C51 COMPILER V9.56.0.0   MAIN                                                              11/25/2017 12:12:32 PAGE 3   

 115          bit yearUpdated;
 116          bit hoursUpdated;
 117          bit minutesUpdated;
 118          bit secondsUpdated;
 119          bit amPmUpdated;
 120          bit timeUpdated;
 121          bit monthDateYearUpdated;
 122          
 123          const char code * dayOfWeek[] =         {/*0*/  "NON",
 124                                                                                   /*1*/  "SUN",
 125                                                                                   /*2*/  "MON", 
 126                                                                                   /*3*/  "TUE",
 127                                                                                   /*4*/  "WED", 
 128                                                                                   /*5*/  "THU",
 129                                                                                   /*6*/  "FRI", 
 130                                                                                   /*7*/  "SAT"}; 
 131          
 132          const char code * monthOfYear[] =       {/*0*/  "NON",
 133                                                                                   /*1*/  "JAN",
 134                                                                                   /*2*/  "FEB", 
 135                                                                                   /*3*/  "MAR",
 136                                                                                   /*4*/  "APR", 
 137                                                                                   /*5*/  "MAY",
 138                                                                                   /*6*/  "JUN", 
 139                                                                                   /*7*/  "JUL",
 140                                                                                   /*8*/  "AUG",
 141                                                                                   /*9*/  "SEP",
 142                                                                                   /*10*/ "OCT", 
 143                                                                                   /*11*/ "NOV",
 144                                                                                   /*12*/ "DEC"};
 145          
 146          const char code * clockSetupMsg[] = {/*0*/      "SET DATE AND TIME      ",
 147                                                                                  /*1*/   "WRITING DATA... WAIT!  ",
 148                                                                                  /*2*/   "DATA SUCCESSFULLY SAVED",
 149                                                                                  /*3*/   "ERROR                  "};
 150          
 151          //-------------------------------------------------------------------------------------------------------
 152          // System Configurations
 153          //-------------------------------------------------------------------------------------------------------
 154          void systemClockInit(void)
 155          {
 156   1          char SFRPAGE_SAVE = SFRPAGE;                                                                                        // Save Current SFR page
 157   1              int i = 0;
 158   1          
 159   1              SFRPAGE  = CONFIG_PAGE;
 160   1              
 161   1          OSCICN    = 0x83;
 162   1      
 163   1              SFRPAGE = SFRPAGE_SAVE;                                                                                         // Restore SFRPAGE
 164   1      }
 165          
 166          void portInit(void)
 167          {
 168   1              char SFRPAGE_SAVE = SFRPAGE;                                                            // Save Current SFR page
 169   1      
 170   1              SFRPAGE = CONFIG_PAGE;                                                                  // Set SFR page
 171   1      
 172   1              XBR0 = 0x2F;                                                                                                                            // Enable UART0, UART1, SPI0, SMB, CEX0 - CEX4                                                                                                                                                  
 173   1              XBR1 = 0x01;                                                                            
 174   1          XBR2 = 0xC4;                                                                                                                                // Enable crossbar and disable weak pull-up                                                                                             
 175   1          
 176   1              P0MDOUT = 0x01;                                                                                 // Set TX0 pin to push-pull
C51 COMPILER V9.56.0.0   MAIN                                                              11/25/2017 12:12:32 PAGE 4   

 177   1                                                                                                                                                                      // TX0 = P0.0; RX0 = P0.1
 178   1              P1MDOUT = 0x01;                                                                                                                         // Set TX1 pin to push-pull, P1.0
 179   1                                                                                                                                                                      // TX1 = P1.0; RX1 = P1.1
 180   1              P3MDOUT = 0xCA;                                                                                                                         // P3.0, P3.2, P3.4, P3.5: open drain; P3.1, P3.3, P3.6, P3.7: push pull
 181   1              
 182   1              P4MDOUT = 0x0F;                                                                                                                         // P4.0, P4.1, P4.2, P4.3: push pull
 183   1                                                                                                                                                                      
 184   1              P5MDOUT = 0x04;                                                                                                                         // P5.0 open drain; P5.1 Open drain; P5.2 Push pull
 185   1              
 186   1              P6MDOUT = 0x00;
 187   1                                                                                                                                                                                                                                                                                                                              
 188   1              P7MDOUT = 0x80;                                                                                                                         // Set P7.7 push-pull (smb error line)
 189   1              
 190   1              P0 = 0xFF;                                                                                                                                      // Initialize port P0 latch
 191   1              P1 = 0xFF;                                                                                                                                      // Initialize port P1 latch
 192   1              P2 = 0xFF;                                                                                                                                      // Initialize port P2 latch
 193   1              P3 = 0xFF;                                                                                                                                      // Initialize port P3 latch
 194   1              P4 = 0xFF;                                                                                                                                      // Initialize port P4 latch
 195   1              P5 = 0xFF;                                                                                                                                      // Initialize port P5 latch
 196   1              P6 = 0xFF;                                                                                                                                      // Initialize port P6 latch
 197   1              P7 = 0xFF;                                                                                                                                      // Initialize port P7 latch
 198   1      
 199   1              RHW = 0;                                                                                                                                        // Pull low SMB error line
 200   1      
 201   1          SFRPAGE = SFRPAGE_SAVE;                                                                     // Restore SFR page
 202   1      }
 203          
 204          void enableInterrupts(void)
 205          {
 206   1              IE = 0x92;                                                                                                                                      // Enable all interrupts + UART0 + Timer 0
 207   1              EIE2 |= 0x01;                                                                                   // Enable Timer 3 interrupt
 208   1              EIE2 |= 0x40;                                                                                                                           // Enable UART1 interrupt
 209   1              EIE1 |= 0x0A;                                                                                                                           // Enable SMBus interrupt
 210   1      }
 211          
 212          void uart0Init(void)
 213          {
 214   1         char SFRPAGE_SAVE;
 215   1      
 216   1         SFRPAGE_SAVE = SFRPAGE;                                                                      // Preserve SFRPAGE
 217   1      
 218   1         SFRPAGE = TMR2_PAGE;
 219   1         TMR2CN = 0x00;                                                                               // Stop timer. Timer 2 in 16-bit auto-
             -reload up timer mode
 220   1         TMR2CF = 0x08;                                                                               // SYSCLK is time base; no output; up 
             -count only
 221   1         RCAP2L = 0xF3;                                                               // Low byte
 222   1         RCAP2H = 0xFF;                                                               // High byte
 223   1         TMR2 = RCAP2;                                                                // Load 16 bit reload valu
             -e into timer 2
 224   1         TMR2CN = 0x04;                                                               // Enable timer 2 (Start t
             -imer 2)
 225   1      
 226   1         SFRPAGE = UART0_PAGE;
 227   1         SCON0 = 0x50;                                                                                // 8-bit variable baud rate; 9th bit i
             -gnored; RX enabled
 228   1         SSTA0 = 0x05;                                                                                // Enable baud rate                   
             -                                                                      
 229   1                                                                                                      // Use timer 2 as RX and TX baud rate 
             -source
 230   1         IE = 0x90;                                                                   // Enable all interrupts a
             -nd UART0 Interrupt
C51 COMPILER V9.56.0.0   MAIN                                                              11/25/2017 12:12:32 PAGE 5   

 231   1      
 232   1         SFRPAGE = SFRPAGE_SAVE;                                                                      // Restore SFRPAGE
 233   1      }
 234          
 235          void disableWatchdog(void)
 236          {
 237   1              WDTCN = 0xDE;                                                                                           // Disable watchdog timer
 238   1          WDTCN = 0xAD;
 239   1      }
 240          
 241          void uart0Interrupt(void) interrupt INTERRUPT_UART_0 using 2
 242          {
 243   1              char SFRPAGE_SAVE = SFRPAGE;
 244   1              unsigned int i = 0;
 245   1              unsigned long txWaitCounter = 0;
 246   1      
 247   1              SFRPAGE = UART0_PAGE;
 248   1      
 249   1              if(RI0 == 1)                                                                                    // There is a char in SBUF
 250   1              {
 251   2              RI0 = 0;                                                                                        // Clear interrupt flag
 252   2      
 253   2              tsByte = SBUF0;                                                                         // Read a character from UART
 254   2      
 255   2              if(tsRxIn < RX_BUFFER_SIZE)                                                                                             // If buffer size is within limit
 256   2              {
 257   3                      if(tsByte != '\r')                                                                                                      // Check end of a command from touch screen
 258   3                              {
 259   4                                      tsRxBuffer[tsRxIn] = tsByte;                                                                    // Store a character in software buffer
 260   4                                      tsRxIn++;                                                                                                               // Increment index
 261   4                              }
 262   3                      else                                                                                                                            // If it is CR character, it marks end of command
 263   3                              {                                                                                                                               
 264   4                                      if(tsRxBuffer[0] == '{')                                        // Splash screen indicator
 265   4                                      {
 266   5                                              if(tsRxBuffer[1] == 'c' && tsRxBuffer[2] == 'm' && tsRxBuffer[3] == 'p' && tsRxBuffer[4] == 'e' && ts
             -RxBuffer[5] == '}')
 267   5                                              {
 268   6                                                      splashEnd = 1;                                          // Detect end of splash screen
 269   6                                                      screenReset = 1;                                                                                // Screen was reset, so touch screen sends {babe\r}
 270   6                                              }
 271   5                                              else
 272   5                                              {
 273   6                                                      splashEnd = 0;                                          // End of splash screen NOT detected
 274   6                                                      screenReset = 0;                                                                        
 275   6                                              }
 276   5                                      }
 277   4                      else if(tsRxBuffer[0] == 'x')                                   // It is a command from to
             -uch screen controller
 278   4                      {                                                               // A command starts with '
             -('
 279   5                          for(i = 0; i < tsRxIn; i++)
 280   5                          {
 281   6                              userCommand[i] = tsRxBuffer[i];                         // Copy to command array f
             -or later evaluation
 282   6                          }
 283   5      
 284   5                          ackFromScreen = 0;                                          // This is a command, NOT 
             -an ACK
 285   5                          tsCommandReceived = 1;                                      // Set flag when a complet
             -e command is received
 286   5                      }
C51 COMPILER V9.56.0.0   MAIN                                                              11/25/2017 12:12:32 PAGE 6   

 287   4                                      else if(tsRxBuffer[0] == '(')                                                                   // It is a command from touch screen controller
 288   4                                      {                                                                                                                               // A command starts with '('
 289   5                                              for(i = 0; i < tsRxIn; i++)
 290   5                                              {
 291   6                                                      userCommand[i] = tsRxBuffer[i];                                                 // Copy to command array for later evaluation
 292   6                                              }
 293   5      
 294   5                                              ackFromScreen = 0;                                                                                      // This is a command, NOT an ACK
 295   5                                              tsCommandReceived = 1;                                                                          // Set flag when a complete command is received
 296   5                                      }
 297   4                                      else                                                                                                                    // Not a command from touch screen controller
 298   4                                      {
 299   5                                              ackFromScreen = 1;                                                                                      // Set a flag to indicate it is an ACK from screen
 300   5                                              tsCommandReceived = 0;                                                                          // No need to set flag because it is not a command
 301   5                                      }
 302   4      
 303   4                                      for(i = 0; i < tsRxIn; i++)
 304   4                                      {
 305   5                                              tsRxBuffer[i] = '\0';                                                                           // Delete all contents
 306   5                                      }
 307   4                                      
 308   4                                      tsRxOut = 0;                                                                                                    // Reset index Out
 309   4                                      tsRxIn = 0;                                                                                                             // Reset index In
 310   4                              }       
 311   3              }
 312   2                      else                                                                                                                                    // Reset all indexes
 313   2                      {       
 314   3                              while(tsRxOut < tsRxIn)
 315   3                              {
 316   4                                      tsRxBuffer[tsRxOut] = '\0';
 317   4                                      tsRxOut++;
 318   4                              }
 319   3                              tsRxOut = 0;
 320   3                              tsRxIn = 0;
 321   3                              tsCommandReceived = 0;
 322   3                      }
 323   2         }
 324   1      
 325   1         if(TI0 == 1)                                                                                                 // Check if one character is successfully sent out
 326   1         {
 327   2              TI0 = 0;                                                                                        // Clear interrupt flag
 328   2      
 329   2                      if(tsTxEmpty == 0)                                                                                                              // TX buffer has something to send
 330   2                      {
 331   3                              SBUF0 = tsTxBuffer[tsTxOut];                                                                            // Send a character in TX buffer
 332   3                              tsTxOut++;                                                                                                                      // Move to next character
 333   3      
 334   3                              while(TI0 == 0 && txWaitCounter++ < TX_WAIT_LIMIT);                                     // Wait until completion of transmission TI0 = 
             -1
 335   3                              if(txWaitCounter >= TX_WAIT_LIMIT)
 336   3                              {
 337   4                                      TI0 = 1;                                                                                                                // TI0 is not set by hardware, set it by software
 338   4                              }                                                                                                                                       // When TI0 is set to 1, this ISR is executed again
 339   3                              
 340   3                              txWaitCounter = 0;                                                                                                      // Reset counter for next execution     
 341   3      
 342   3                              if(tsTxOut >= TX_BUFFER_SIZE)
 343   3                              {
 344   4                                      tsTxOut = 0;                                                                                                    // Reset index to 0
 345   4                              }                                                               
 346   3      
 347   3                              if(tsTxOut == tsTxIn)                                                                                           // If two indexes are equal
C51 COMPILER V9.56.0.0   MAIN                                                              11/25/2017 12:12:32 PAGE 7   

 348   3                              {
 349   4                                      tsTxEmpty = 1;                                                                                                  // No more character in buffer. Empty
 350   4                              }
 351   3                      }
 352   2                      else
 353   2                      {
 354   3                              tsLastCharGone = 1;                                                                                                     // Last character has gone. Buffer is empty
 355   3                      }
 356   2              }
 357   1              
 358   1              SFRPAGE = SFRPAGE_SAVE;                                                                         // Restore SFR page detector
 359   1      }
 360          
 361          //-------------------------------------------------------------------------------------------------------
 362          // Function Name: sendCommand
 363          // Return Value: None 
 364          // Parmeters: s (a string to send)
 365          // Function Description: This function sends a command from the touch screen
 366          //-------------------------------------------------------------------------------------------------------
 367          void sendCommand(const char * s)
 368          {       
 369   1              char SFRPAGE_SAVE = SFRPAGE;
 370   1              
 371   1              while(*s != '\0')                                                                                                                       // Search for end of touch screen command in buffer
 372   1          {
 373   2              if(tsTxEmpty == 1 || (tsTxOut != tsTxIn))                                                               // Tx is empty or two indexes are not equal
 374   2                      {
 375   3                              tsTxBuffer[tsTxIn++] = *s;
 376   3                              if(tsTxIn >= TX_BUFFER_SIZE)                                                                            // Check for limit
 377   3                              {
 378   4                                      tsTxIn = 0;                                                                                                             // Reset if limit reached
 379   4                              }
 380   3      
 381   3                              if(tsTxEmpty == 1)                                                                                                      // If buffer is empty
 382   3                              {
 383   4                                      tsTxEmpty = 0;                                                                                                  // Now buffer has at leat 1 character, set flag
 384   4                              }
 385   3                      }
 386   2              
 387   2                      s++;                                                                                                                                    // Point to next char to send out
 388   2          }
 389   1                                                                                                                                                                      
 390   1              if(tsLastCharGone == 1)                                                                                                         // All characters in buffer has sent out
 391   1              {
 392   2                      tsLastCharGone = 0;                                                                                                             // Reset flag to indicate no char left in buffer
 393   2                      SFRPAGE = UART0_PAGE;                                                                                                                                                   
 394   2                      TI0 = 1;                                                                        // Set this flage to call ISR to send 
             -out one character
 395   2              }                                                                                                                                                       
 396   1                                                                                                                                                                      
 397   1              SFRPAGE = SFRPAGE_SAVE;                                                                 // Restore SFRPAGE
 398   1      }
 399          
 400          //-------------------------------------------------------------------------------------------------------
 401          // Function Name: displayText
 402          // Return Value: None 
 403          // Parmeters: fg, bg, size, message, x, y
 404          // Function Description: This function displays a text on the touch screen
 405          //-------------------------------------------------------------------------------------------------------
 406          void displayText(const char* fg, const char* bg, const unsigned char size, const char* message, const unsi
             -gned int x, const unsigned int y)
 407          {
C51 COMPILER V9.56.0.0   MAIN                                                              11/25/2017 12:12:32 PAGE 8   

 408   1              char str[TS_BUFFER_SIZE];                                                                                                       // String
 409   1                      
 410   1              sprintf(str, "S %s %s\r", fg, bg);                                                                                      // Set forground and background color
 411   1              sendCommand(str);                                                                                                               
 412   1              sprintf(str, "f %s\r", Font[size]);                                                                                     // Set text font
 413   1              sendCommand(str);                                                                                                               
 414   1              sprintf(str, "t \"%s\" %u %u\r", message, x, y);                                                        // Display text
 415   1              sendCommand(str);                                                                                                               
 416   1      }
 417          
 418          //-------------------------------------------------------------------------------------------------------
 419          // Function Name: showBitmap
 420          // Return Value: None 
 421          // Parmeters: index, x, y (bitmap index and coordinates)
 422          // Function Description: This function displays a bitmap image
 423          //-------------------------------------------------------------------------------------------------------
 424          void showBitmap(const unsigned int index, const unsigned int x, const unsigned int y)
 425          {
 426   1              char str[TS_BUFFER_SIZE];
 427   1      
 428   1              sprintf(str, "xi %u %u %u\r", index, x, y);                                                                     // Bitmap index
 429   1              sendCommand(str);
 430   1      }
 431          
 432          //-------------------------------------------------------------------------------------------------------
 433          // Function Name: changeScreen
 434          // Return Value: None 
 435          // Parmeters: screenIndex (macro number)
 436          // Function Description: This function switches to the new screen
 437          //-------------------------------------------------------------------------------------------------------
 438          void changeScreen(const unsigned char screenIndex)
 439          {
 440   1              callMacro(screenIndex);                                                                                                         // Change screen                
 441   1      }
 442          
 443          //-------------------------------------------------------------------------------------------------------
 444          // Function Name: callMacro
 445          // Return Value: None 
 446          // Parmeters: macroNumber (macro number in the macro file)
 447          // Function Description: This function calls a macro
 448          //-------------------------------------------------------------------------------------------------------
 449          void callMacro(const unsigned int macroNumber)
 450          {
 451   1              char str[TS_BUFFER_SIZE];
 452   1      
 453   1              sprintf(str, "m %u\r", macroNumber);                                                                            // Execute macro number
 454   1              sendCommand(str);
 455   1      }
 456          
 457          //-------------------------------------------------------------------------------------------------------
 458          // Function Name: scanUserInput
 459          // Return Value: None 
 460          // Parmeters: None
 461          // Function Description: This function processes commands from the touch screen
 462          //-------------------------------------------------------------------------------------------------------
 463          void scanUserInput(void)
 464          {       
 465   1              int i = 0;
 466   1      
 467   1              if(screen == MAIN_PAGE)                                                                                                         // Main screen
 468   1              {                
 469   2                      if(userCommand[0] == '(')                                                                                               // Check for an actual command followed by this '(' character
C51 COMPILER V9.56.0.0   MAIN                                                              11/25/2017 12:12:32 PAGE 9   

 470   2                      {
 471   3                              switch (userCommand[1])                                                                                         // Scan a command type
 472   3                              {
 473   4                                      case '1':                                                                                                               // Main page
 474   4                                              changeScreen(MAIN_PAGE);                                                                        // Stay in main page if main button is pressed again
 475   4                                              break;
 476   4                                      case '2':                                                                                                               // Settings page
 477   4                                              changeScreen(SETTINGS_PAGE);
 478   4                                              break;
 479   4                                      case '3':                                                                                                               // Service page
 480   4                                              changeScreen(SERVICE_PAGE);
 481   4                                              break;
 482   4                                      case 'A':
 483   4                                              // Call a function here or do something here                    
 484   4                                              break;
 485   4                                      case 'B':
 486   4                                              // Call a function here or do something here
 487   4                                              break;
 488   4                                      case 'C':
 489   4                                              // Call a function here or do something here
 490   4                                              break;  
 491   4                                      default:                                                                                                                // Other options
 492   4                                              break;
 493   4                                      }
 494   3                      }
 495   2                      else                                                                                                                                    // Not a command, empty buffer with null char
 496   2                      {
 497   3                              i = 0;
 498   3                              while(userCommand[i] != '\0')
 499   3                              {
 500   4                                      userCommand[i] = '\0';
 501   4                                      i++;
 502   4                              }
 503   3                      }       
 504   2              }
 505   1              else if(screen == SETTINGS_PAGE)                                                                                        // Settings page
 506   1              {
 507   2                      if(userCommand[0] == '(')
 508   2                      {
 509   3                              switch (userCommand[1])
 510   3                              {
 511   4                                      case '1':
 512   4                                              changeScreen(MAIN_PAGE);
 513   4                                              break;
 514   4                                      case '2':
 515   4                                              changeScreen(SETTINGS_PAGE);
 516   4                                              break;
 517   4                                      case '3':
 518   4                                              changeScreen(SERVICE_PAGE);
 519   4                                              break;
 520   4                                      case 'A':
 521   4                                              // Call a function here or do something here
 522   4                                              break;
 523   4                                      case 'B':
 524   4                                              // Call a function here or do something here
 525   4                                              break;
 526   4                                      case 'C':
 527   4                                              // Call a function here or do something here
 528   4                                              break;
 529   4                                      default:
 530   4                                              break;
 531   4                              }
C51 COMPILER V9.56.0.0   MAIN                                                              11/25/2017 12:12:32 PAGE 10  

 532   3                      }
 533   2                      else                                                                                                                                    // Not a command, empty buffer with null
 534   2                      {
 535   3                              i = 0;
 536   3                              while(userCommand[i] != '\0')
 537   3                              {
 538   4                                      userCommand[i] = '\0';
 539   4                                      i++;
 540   4                              }
 541   3                      }                               
 542   2              }
 543   1              else if(screen == SERVICE_PAGE)
 544   1              {
 545   2                      if(userCommand[0] == '(')
 546   2                      {
 547   3                              switch (userCommand[1])
 548   3                              {
 549   4                                      case '1':
 550   4                                              changeScreen(MAIN_PAGE);
 551   4                                              break;
 552   4                                      case '2':
 553   4                                              changeScreen(SETTINGS_PAGE);
 554   4                                              break;
 555   4                                      case '3':
 556   4                                              changeScreen(SERVICE_PAGE);
 557   4                                              break;
 558   4                                      case 'A':
 559   4                                              // Call a function here or do something here
 560   4                                      case 'B':
 561   4                                              // Call a function here or do something here
 562   4                                      case 'C':
 563   4                                              // Call a function here or do something here
 564   4                                      default:
 565   4                                              break;
 566   4                              }
 567   3                      }
 568   2                      else                                                                                                                                    // Not a command, empty buffer with null
 569   2                      {                                                                                                                       
 570   3                              i = 0;
 571   3                              while(userCommand[i] != '\0')
 572   3                              {
 573   4                                      userCommand[i] = '\0';
 574   4                                      i++;
 575   4                              }
 576   3                      }                               
 577   2              }       
 578   1              else
 579   1              {
 580   2      
 581   2              }
 582   1      
 583   1              i = 0;
 584   1              while(userCommand[i] != '\0')
 585   1              {
 586   2                      userCommand[i] = '\0';                                                                                                  // Delete all contents in array
 587   2                      i++;
 588   2              }
 589   1      }
 590          
 591          //-------------------------------------------------------------------------------------------------------
 592          // Function Name: smbInit
 593          // Return Value: None 
C51 COMPILER V9.56.0.0   MAIN                                                              11/25/2017 12:12:32 PAGE 11  

 594          // Parmeters: None
 595          // Function Description: This function initializes the SMB bus 
 596          //-------------------------------------------------------------------------------------------------------
 597          void smbInit(void)
 598          {
 599   1              int i;
 600   1              unsigned long pollingCounter = 0;
 601   1              char SFRPAGE_SAVE = SFRPAGE;
 602   1      
 603   1              SFRPAGE = SMB0_PAGE;
 604   1              while(SDA == 0 && pollingCounter++ < SMB_POLLING_LIMIT)                                                 // If slave is holding SDA low because of e
             -rror or reset
 605   1              {
 606   2              SCL = 0;                                                                                        // Drive the clock low
 607   2              for(i = 0; i < 255; i++);                                                                       // Hold the clock low
 608   2              SCL = 1;                                                                                        // Release the clock
 609   2              while(SCL == 0 && pollingCounter++ < SMB_POLLING_LIMIT);                                        // Wait for open-drain
 610   2              for(i = 0; i < 10; i++);                                                                        // Hold the clock high
 611   2              }
 612   1                              
 613   1              SMB0CN = 0x07;                                                                                          // Assert Acknowledge low (AA bit = 1b);
 614   1                                                                                                              // Enable SMBus Free timeout detect;
 615   1              SMB0CR = 267 - (SYSTEM_CLOCK / (8 * SMB_FREQUENCY));                                                    // Derived approximation from the Tlow and Thi
             -gh equations
 616   1                                                                                                                                              
 617   1              SMB0CN |= 0x40;                                                                                         // Enable SMBus;
 618   1      
 619   1              SFRPAGE = SFRPAGE_SAVE;                                                                                 // Restore SFR page detector
 620   1              
 621   1              SMB_BUSY = 0;
 622   1                                                                                          // Release SMB
 623   1          slaveWriteDone = FALSE;
 624   1              slaveReadDone = FALSE;
 625   1              eepromWriteDone = FALSE;
 626   1              eepromReadDone = FALSE;
 627   1              rtcWriteDone = FALSE;
 628   1              rtcReadDone = FALSE;
 629   1      }
 630          
 631          //-------------------------------------------------------------------------------------------------------
 632          // Function Name: timer3Init
 633          // Return Value: None 
 634          // Parmeters: None
 635          // Function Description: This function nitializes timer 3 which is used to time out the SMB if errors occu
             -r
 636          //-------------------------------------------------------------------------------------------------------
 637          void timer3Init (void)
 638          {
 639   1              char SFRPAGE_SAVE = SFRPAGE;        
 640   1      
 641   1              SFRPAGE = TMR3_PAGE;
 642   1      
 643   1              TMR3CN = 0x00;                                                                                          // Timer 3 in timer mode
 644   1                                                                                                                                                                              // Timer 3 auto reload
 645   1              TMR3CF = 0x00;                                                                                          // Timer 3 prescaler = 12
 646   1      
 647   1              RCAP3 = -(SYSTEM_CLOCK / 12 / 40);                                                              // Timer 3 overflows after 25 ms
 648   1              TMR3 = RCAP3;                                                                                   
 649   1      
 650   1              TR3 = 1;                                                                                                // Start Timer 3
 651   1      
 652   1              SFRPAGE = SFRPAGE_SAVE;                                                                                 // Restore SFR page
C51 COMPILER V9.56.0.0   MAIN                                                              11/25/2017 12:12:32 PAGE 12  

 653   1      }
 654          
 655          //-------------------------------------------------------------------------------------------------------
 656          // Function Name: timer3ISR
 657          // Return Value: None 
 658          // Parmeters: None
 659          // Function Description: This function is timer 3 ISR which is used to reset the SMB bus if the clock line
             - is held for too long
 660          //-------------------------------------------------------------------------------------------------------
 661          void timer3ISR(void) interrupt INTERRUPT_Timer_3
 662          {
 663   1              char SFRPAGE_SAVE = SFRPAGE;                                                                            // Save Current SFR page
 664   1      
 665   1              SFRPAGE = SMB0_PAGE;
 666   1              SMB0CN &= ~0x40;                                                                                        // Disable SMBus
 667   1              SMB0CN |= 0x40;                                                                                         // Re-enable SMBus
 668   1      
 669   1              SFRPAGE = SFRPAGE_SAVE;                                                                                 // Switch back to the Timer3 SFRPAGE
 670   1              TF3 = 0;                                                                                                // Clear Timer3 interrupt-pending flag
 671   1              SMB_BUSY = 0;                                                                                           // Free bus
 672   1         
 673   1              SFRPAGE = SFRPAGE_SAVE;                                                                                 // Restore SFR page detector
 674   1      }
 675          
 676          //-------------------------------------------------------------------------------------------------------
 677          // Function Name: writeOneByteToSlave
 678          // Return Value: None 
 679          // Parmeters: target, startAddr, content
 680          // Function Description: This function writes one to the slave microprocessor
 681          //-------------------------------------------------------------------------------------------------------
 682          void writeOneByteToSlave(unsigned char startAddr, unsigned char content)
 683          {               
 684   1              sharedDataTx[startAddr] = content;
 685   1              smbWrite(MCU_SLAVE_ADDR, startAddr, 1);
 686   1      }
 687          
 688          //-------------------------------------------------------------------------------------------------------
 689          // Function Name: readOneByteFromSlave
 690          // Return Value: long 
 691          // Parmeters: startAddr, bytes
 692          // Function Description: This function reads one from the slave microprocessor
 693          //-------------------------------------------------------------------------------------------------------
 694          unsigned char readOneByteFromSlave(unsigned char startAddr)
 695          {
 696   1              smbRead(MCU_SLAVE_ADDR, startAddr, 1);
 697   1              return sharedDataRx[startAddr];                                                                                                                                                                                         
 698   1      }
 699          
 700          //-------------------------------------------------------------------------------------------------------
 701          // Function Name: writeBytesToRealTimeClock
 702          // Return Value: None 
 703          // Parmeters: target, startAddr, bytes
 704          // Function Description: This function writes data byte to the real time clock DS3232
 705          //-------------------------------------------------------------------------------------------------------
 706          void writeBytesToRealTimeClock(unsigned char startAddr, unsigned char numBytes)
 707          {
 708   1              smbWrite(REAL_TIME_CLOCK_ADDR, startAddr, numBytes);
 709   1      }
 710          
 711          //-------------------------------------------------------------------------------------------------------
 712          // Function Name: readBytesFromRealTimeClock
 713          // Return Value: None 
C51 COMPILER V9.56.0.0   MAIN                                                              11/25/2017 12:12:32 PAGE 13  

 714          // Parmeters: target, startAddr, bytes
 715          // Function Description: This function reads data byte from the real time clock DS3232
 716          //-------------------------------------------------------------------------------------------------------
 717          void readBytesFromRealTimeClock(unsigned char startAddr, unsigned char numBytes)
 718          {
 719   1              smbRead(REAL_TIME_CLOCK_ADDR, startAddr, numBytes);
 720   1      }
 721          
 722          //-------------------------------------------------------------------------------------------------------
 723          // Function Name: smbRead
 724          // Return Value: unsigned char * 
 725          // Parmeters: target, startAddr, bytes
 726          // Function Description: This function reads from SM bus
 727          //-------------------------------------------------------------------------------------------------------
 728          void smbRead(unsigned char deviceId, unsigned int location, unsigned int bytes)
 729          {
 730   1              char SFRPAGE_SAVE = SFRPAGE;
 731   1      
 732   1              SFRPAGE = SMB0_PAGE;
 733   1              
 734   1              while(BUSY || SMB_BUSY);                                                                        // Wait for free SMB
 735   1      
 736   1              SFRPAGE = SFRPAGE_SAVE;
 737   1                      
 738   1          switch(deviceId)
 739   1          {
 740   2              case MCU_SLAVE_ADDR:
 741   2              case REAL_TIME_CLOCK_ADDR:
 742   2              case EEPROM_ADDR:
 743   2                  smbWrite(deviceId, location, 0);                                                                        // Write address before reading
 744   2                  break;
 745   2              default:
 746   2                  break;      
 747   2          }
 748   1      
 749   1          SFRPAGE = SMB0_PAGE;
 750   1                      
 751   1          while(BUSY || SMB_BUSY);
 752   1          slaveAddr = deviceId;                                                                       // Address of MCU slave
 753   1          startAddr = location;                                                                                                               // Starting address to read from slave
 754   1          numBytesRD = bytes;                                                                                                                 // Number of bytes to read
 755   1          
 756   1          SMB_BUSY = 1;                                                                               // Claim SMBus (set to busy)
 757   1          SMB_RW = 1;                                                                                 // Mark this transfer as a READ
 758   1          STA = 1;
 759   1      
 760   1              while(BUSY || SMB_BUSY);                                                                // Wait for SMB
 761   1                      
 762   1              SFRPAGE = SFRPAGE_SAVE;
 763   1                              
 764   1          switch(deviceId)
 765   1          {
 766   2              case MCU_SLAVE_ADDR:
 767   2                  while(slaveReadDone == 0);                                                  // Wait until slave write 
             -completed
 768   2                  break;
 769   2              case REAL_TIME_CLOCK_ADDR:
 770   2                              while(rtcReadDone == 0);                                                        // Wait until real time clock write c
             -ompleted or timeout occurs
 771   2                              break;
 772   2              case EEPROM_ADDR:
 773   2                  while(eepromReadDone == 0);                                                 // Wait until EEPROM writ
C51 COMPILER V9.56.0.0   MAIN                                                              11/25/2017 12:12:32 PAGE 14  

             -e completed
 774   2                  break;
 775   2              default:
 776   2                  break;      
 777   2          }    
 778   1      }
 779          
 780          //-------------------------------------------------------------------------------------------------------
 781          // Function Name: smbWrite
 782          // Return Value: unsigned char * 
 783          // Parmeters: target, startAddr, bytes
 784          // Function Description: This function reads to SM bus
 785          //-------------------------------------------------------------------------------------------------------
 786          void smbWrite(unsigned char deviceId, unsigned int location, unsigned int bytes)
 787          {
 788   1              unsigned char i = 0;
 789   1              unsigned int pageWrittenDelay = 0;
 790   1              char SFRPAGE_SAVE = SFRPAGE;
 791   1                      
 792   1              SFRPAGE = SMB0_PAGE;
 793   1              
 794   1              while(BUSY || SMB_BUSY);                                                                        // Wait for SMB to be free
 795   1          slaveAddr = deviceId;                                                                           // Address of MCU slave board
 796   1          startAddr = location;                                                                                                                   // Starting address to write to slave
 797   1      
 798   1          switch(deviceId)
 799   1          {
 800   2              case MCU_SLAVE_ADDR:                                                                                                        // Pass through
 801   2              case DEVICE_DUMP_ADDR:                                                                                                      // Pass through
 802   2                  numBytesWR = bytes;                                                                                                     // Number of bytes to read
 803   2                  SMB_BUSY = 1;                                                                   // Claim SMBus (set to busy)
 804   2                  SMB_RW = 0;                                                                     // Mark this transfer as a WRIT
             -E
 805   2                  STA = 1;                                                                        // Start transfer
 806   2                  while(slaveWriteDone == 0);                                             // Wait until SRAM wri
             -te completed or timeout occurs
 807   2                  break;
 808   2              case REAL_TIME_CLOCK_ADDR:
 809   2                  numBytesWR = bytes;                                                                                                     // Number of bytes to read
 810   2                  SMB_BUSY = 1;                                                                   // Claim SMBus (set to busy)
 811   2                  SMB_RW = 0;                                                                     // Mark this transfer as a WRIT
             -E
 812   2                  STA = 1;                                                                        // Start transfer
 813   2                  while(rtcWriteDone == 0);                                               // Wait until SRAM write
             - completed or timeout occurs
 814   2                  break;
 815   2              default:
 816   2                  break;              
 817   2              }
 818   1      
 819   1              SFRPAGE = SFRPAGE_SAVE;                                                                                                                 // Restore SFR page
 820   1      }
 821          
 822          //-------------------------------------------------------------------------------------------------------
 823          // Function Name: smbISR
 824          // Return Value: None 
 825          // Parmeters: None
 826          // Function Description: 
 827          // SMBus Interrupt Service Routine (ISR)
 828          // Anytime the SDA is pulled low by the master, this ISR will be called. For example, if STA = 1,
 829          // this ISR is called and SMB0STA = SMB_START = SMB_REPEAT_START. These cases are executed within the swit
             -ch statement.
C51 COMPILER V9.56.0.0   MAIN                                                              11/25/2017 12:12:32 PAGE 15  

 830          //-------------------------------------------------------------------------------------------------------
 831          void smbISR (void) interrupt INTERRUPT_SMB using 2
 832          {
 833   1              bit FAIL = 0;                                                                                           // Used by the ISR to flag failed trans
             -fers
 834   1              static unsigned int TxCounter;                                                                                                  // Initialize counter
 835   1              static unsigned int RxCounter;                                                                                                  // Initialize counter
 836   1              static unsigned int slaveCount = 0;
 837   1              static unsigned int realTimeClockCount = 0;
 838   1              static unsigned int eepromCount = 0;
 839   1              static unsigned char eepromAddrDone;
 840   1              
 841   1              switch (SMB0STA >> 3)                                                                                                                   // Check SMB bus status
 842   1              {
 843   2      //-------------------------------------------------------------------------------------------------------
 844   2      // Master Transmitter/Receiver: START condition transmitted. Load SMB0DAT with slave device address
 845   2      //-------------------------------------------------------------------------------------------------------
 846   2              case SMB_START:                                                                                                                         // Master initiates a transfer
 847   2      
 848   2      //-------------------------------------------------------------------------------------------------------
 849   2      // Master Transmitter/Receiver: repeated START condition transmitted. Load SMB0DAT with slave device addre
             -ss
 850   2      //-------------------------------------------------------------------------------------------------------
 851   2              case SMB_REPEAT_START:
 852   2                              SMB0DAT = slaveAddr;                                                                    // Load address of the slave.
 853   2                      SMB0DAT &= 0xFE;                                                                                // Clear the LSB of the address for the
             - R/W bit
 854   2                      SMB0DAT |= SMB_RW;                                                                              // Load R/W bit (Read = 1; Write = 0)
 855   2                              STA = 0;                                                                                        // Manually clear STA bit
 856   2      
 857   2                      RxCounter = 0;                                                                                  // Reset the counter
 858   2                      TxCounter = 0;                                                                                  // Reset the counter
 859   2                              eepromAddrDone = CLEAR;                                                                                                 // For 2 byte EEPROM address    
 860   2                      
 861   2                              break;
 862   2      
 863   2      //-------------------------------------------------------------------------------------------------------
 864   2      // Master Transmitter: Slave address + WRITE transmitted.  ACK received. For a READ: N/A
 865   2      // For a WRITE: Send the first data byte to the slave
 866   2      //-------------------------------------------------------------------------------------------------------
 867   2              case SMB_ADDR_W_TX_ACK_RX:
 868   2                              if(slaveAddr == MCU_SLAVE_ADDR)
 869   2                              {
 870   3                                      if(startAddr == DEVICE_DUMP_ADDR)                                                                       // Dump device address to check slave presence only
 871   3                                      {
 872   4                                              STO = 1;                                                                                                                // Stop this transfer
 873   4                                              SMB_BUSY = 0;                                                                                                   // Releas SMB
 874   4                                      }
 875   3                                      else
 876   3                                      {
 877   4                                              SMB0DAT = startAddr;                                                                                    // Send 1 byte address to slave
 878   4                                              slaveWriteDone = 0;                                                                                             // Mark start of slave write
 879   4                                      }
 880   3                              }
 881   2                  else if(slaveAddr == REAL_TIME_CLOCK_ADDR)
 882   2                              {
 883   3                                      SMB0DAT = startAddr;                                                                                            // Point to byte address to write on real time clock
 884   3                                      rtcWriteDone = 0;                                                                                                       // Mark start of rtc write
 885   3                              }
 886   2                  else{}
 887   2                      break;
 888   2      
C51 COMPILER V9.56.0.0   MAIN                                                              11/25/2017 12:12:32 PAGE 16  

 889   2      //-------------------------------------------------------------------------------------------------------
 890   2      // Master Transmitter: Slave address + WRITE transmitted.  NACK received. Restart the transfer
 891   2      //-------------------------------------------------------------------------------------------------------
 892   2              case SMB_ADDR_W_TX_NACK_RX:
 893   2                              if(slaveAddr == MCU_SLAVE_ADDR)
 894   2                              {
 895   3                                      if(slaveCount < MAX_NACK_RETRY)
 896   3                                      {
 897   4                                              slaveCount++;                                                                                                   // Increment number of attempts when NACK is received
 898   4                                              STA = 1;                                                                                                                // Restart a new transfer
 899   4                                      }
 900   3                                      else
 901   3                                      {
 902   4                                              slaveCount = 0;                                                                                                 // Reset this counter to keep retry seeking slave response
 903   4                                              slaveWriteDone = 1;
 904   4                                              STO = 1;
 905   4                                              SMB_BUSY = 0;
 906   4                                              FAIL = 1;
 907   4                                      }       
 908   3                              }
 909   2                  else if(slaveAddr == REAL_TIME_CLOCK_ADDR)
 910   2                              {
 911   3                                      if(realTimeClockCount < MAX_NACK_RETRY)
 912   3                                      {
 913   4                                              realTimeClockCount++;                                                                                   // Increment number of attempts when NACK is received
 914   4                                              STA = 1;                                                                                                                // Restart a new transfer
 915   4                                      }
 916   3                                      else
 917   3                                      {
 918   4                                              realTimeClockCount = 0;
 919   4                                              rtcWriteDone = 1;
 920   4                                              STO = 1;
 921   4                                              SMB_BUSY = 0;
 922   4                                              FAIL = 1;
 923   4                                      }       
 924   3                              }
 925   2                              else if(slaveAddr == EEPROM_ADDR)
 926   2                              {
 927   3                                      if(eepromCount < MAX_NACK_RETRY)
 928   3                                      {
 929   4                                              eepromCount++;                                                                                                  // Increment number of attempts when NACK is received
 930   4                                              STA = 1;                                                                                                                // Restart a new transfer
 931   4                                      }
 932   3                                      else
 933   3                                      {
 934   4                                              eepromCount = 0;
 935   4                                              eepromWriteDone = 1;
 936   4                                              STO = 1;
 937   4                                              SMB_BUSY = 0;
 938   4                                              FAIL = 1;
 939   4                                      }       
 940   3                              }
 941   2                              else
 942   2                              {}
 943   2      
 944   2                      break;
 945   2      
 946   2      //-------------------------------------------------------------------------------------------------------
 947   2      //Master Transmitter: Data byte transmitted.  ACK received. For a READ: N/A
 948   2      //For a WRITE: Send all data.  After the last data byte, send the stop bit
 949   2      //-------------------------------------------------------------------------------------------------------
 950   2              case SMB_DATA_TX_ACK_RX:
C51 COMPILER V9.56.0.0   MAIN                                                              11/25/2017 12:12:32 PAGE 17  

 951   2                      if(slaveAddr == MCU_SLAVE_ADDR)
 952   2                              {
 953   3                                      if(TxCounter < numBytesWR)
 954   3                              {
 955   4                                              SMB0DAT = sharedDataTx[startAddr + TxCounter];                                  // Send data byte
 956   4                              TxCounter++;
 957   4                              }
 958   3                              else
 959   3                              {
 960   4                              STO = 1;                                                                        // Set STO to terminate transfer                                                                
             -                                
 961   4                              SMB_BUSY = 0;                                                                   // And free SMBus interface
 962   4                                              slaveWriteDone = 1;                                                                                             // Mark end of slave write
 963   4                              }
 964   3                              }
 965   2                  else if(slaveAddr == REAL_TIME_CLOCK_ADDR)
 966   2                              {
 967   3                                      if(TxCounter < numBytesWR)
 968   3                              {
 969   4                                              SMB0DAT = sharedDataTx[startAddr + TxCounter];                                  // Send data byte
 970   4                              TxCounter++;
 971   4                              }
 972   3                              else
 973   3                              {
 974   4                              STO = 1;                                                                        // Set STO to terminate transfer                                                                
             -                                
 975   4                              SMB_BUSY = 0;                                                                   // And free SMBus interface
 976   4                                              rtcWriteDone = 1;                                                                                               // Mark end of slave write
 977   4                              }
 978   3                              }
 979   2                      break;
 980   2      
 981   2      //-------------------------------------------------------------------------------------------------------
 982   2      // Master Transmitter: Data byte transmitted.  NACK received. Restart the transfer
 983   2      //-------------------------------------------------------------------------------------------------------
 984   2              case SMB_DATA_TX_NACK_RX:
 985   2                              if(slaveAddr == MCU_SLAVE_ADDR)
 986   2                              {
 987   3                                      if(slaveCount < MAX_NACK_RETRY)
 988   3                                      {
 989   4                                              slaveCount++;                                                                                                   // Increment number of attempts when NACK is received
 990   4                                              STA = 1;                                                                                                                // Restart a new transfer
 991   4                                      }
 992   3                                      else
 993   3                                      {
 994   4                                              slaveCount = 0;
 995   4                                              STO = 1;
 996   4                                              SMB_BUSY = 0;
 997   4                                              FAIL = 1;
 998   4                                      }       
 999   3                              }
1000   2                  else if(slaveAddr == REAL_TIME_CLOCK_ADDR)
1001   2                              {
1002   3                                      if(realTimeClockCount < MAX_NACK_RETRY)
1003   3                                      {
1004   4                                              realTimeClockCount++;                                                                                   // Increment number of attempts when NACK is received
1005   4                                              STA = 1;                                                                                                                // Restart a new transfer
1006   4                                      }
1007   3                                      else
1008   3                                      {
1009   4                                              realTimeClockCount = 0;
1010   4                                              STO = 1;
C51 COMPILER V9.56.0.0   MAIN                                                              11/25/2017 12:12:32 PAGE 18  

1011   4                                              SMB_BUSY = 0;
1012   4                                              FAIL = 1;
1013   4                                      }       
1014   3                              }
1015   2                              else if(slaveAddr == EEPROM_ADDR)
1016   2                              {
1017   3                                      if(eepromCount < MAX_NACK_RETRY)
1018   3                                      {
1019   4                                              eepromCount++;                                                                                                  // Increment number of attempts when NACK is received
1020   4                                              STA = 1;                                                                                                                // Restart a new transfer
1021   4                                      }
1022   3                                      else
1023   3                                      {
1024   4                                              eepromCount = 0;
1025   4                                              STO = 1;
1026   4                                              SMB_BUSY = 0;
1027   4                                              FAIL = 1;
1028   4                                      }       
1029   3                              }
1030   2                              else
1031   2                              {}
1032   2                      break;
1033   2      
1034   2      //-------------------------------------------------------------------------------------------------------
1035   2      // Master Receiver: Slave address + READ transmitted.  ACK received. 
1036   2      // For a READ: check if this is a one-byte transfer. if so, set the NACK after the data byte
1037   2      // is received to end the transfer. if not, set the ACK and receive the other data bytes
1038   2      //-------------------------------------------------------------------------------------------------------
1039   2              case SMB_ADDR_R_TX_ACK_RX:
1040   2                      if(numBytesRD == 1)                                                                                                             // If there is one byte to transfer, send a NACK and go to
1041   2                      {                                                                                                                                               // SMB_DATA_RX_NACK_TX case to accept data from slave
1042   3                      AA = 0;                                                                                 // Clear AA flag before data byte is rec
             -eived
1043   3                                                                                                              // send NACK signal to slave after byte 
             -is received
1044   3                      }
1045   2                      else
1046   2                      {
1047   3                      AA = 1;                                                                                 // More than one byte in this transfer,
1048   3                                                                                                              // send ACK after byte is received
1049   3                      }
1050   2                      break;
1051   2      
1052   2      //-------------------------------------------------------------------------------------------------------
1053   2      // Master Receiver: Slave address + READ transmitted.  NACK received. Restart the transfer
1054   2      //-------------------------------------------------------------------------------------------------------
1055   2              case SMB_ADDR_R_TX_NACK_RX:
1056   2                              if(slaveAddr == MCU_SLAVE_ADDR)
1057   2                              {
1058   3                                      if(slaveCount < MAX_NACK_RETRY)
1059   3                                      {
1060   4                                              slaveCount++;                                                                                                   // Increment number of attempts when NACK is received
1061   4                                              STA = 1;                                                                                                                // Restart transfer after receiving a NACK
1062   4                                      }
1063   3                                      else
1064   3                                      {
1065   4                                              slaveCount = 0;                                                                                                 // Reset counter
1066   4                                              STO = 1;
1067   4                                              SMB_BUSY = 0;
1068   4                                              FAIL = 1;
1069   4                                      }       
1070   3                              }
C51 COMPILER V9.56.0.0   MAIN                                                              11/25/2017 12:12:32 PAGE 19  

1071   2                  else if(slaveAddr == REAL_TIME_CLOCK_ADDR)
1072   2                              {
1073   3                                      if(realTimeClockCount < MAX_NACK_RETRY)
1074   3                                      {
1075   4                                              realTimeClockCount++;                                                                                   // Increment number of attempts when NACK is received
1076   4                                              STA = 1;                                                                                                                // Restart a new transfer
1077   4                                      }
1078   3                                      else
1079   3                                      {
1080   4                                              realTimeClockCount = 0;
1081   4                                              STO = 1;
1082   4                                              SMB_BUSY = 0;
1083   4                                              FAIL = 1;
1084   4                                      }       
1085   3                              }
1086   2                              else if(slaveAddr == EEPROM_ADDR)
1087   2                              {
1088   3                                      if(eepromCount < MAX_NACK_RETRY)
1089   3                                      {
1090   4                                              eepromCount++;                                                                                                  // Increment number of attempts when NACK is received
1091   4                                              STA = 1;                                                                                                                // Restart a new transfer
1092   4                                      }
1093   3                                      else
1094   3                                      {
1095   4                                              eepromCount = 0;
1096   4                                              STO = 1;
1097   4                                              SMB_BUSY = 0;
1098   4                                              FAIL = 1;
1099   4                                      }       
1100   3                              }
1101   2                              else
1102   2                              {}
1103   2                      break;
1104   2      
1105   2      //-------------------------------------------------------------------------------------------------------
1106   2      // Master Receiver: Data byte received. If AA flag was set beforehand, then ACK transmitted.
1107   2      // For a READ: receive each byte from the slave.  if this is the last byte, send a NACK and set the STOP b
             -it
1108   2      //-------------------------------------------------------------------------------------------------------
1109   2              case SMB_DATA_RX_ACK_TX:
1110   2                              
1111   2                              if(slaveAddr == MCU_SLAVE_ADDR)
1112   2                              {
1113   3                                      if (RxCounter < numBytesRD)
1114   3                              {
1115   4                                              sharedDataRx[startAddr + RxCounter] = SMB0DAT;
1116   4                              AA = 1;                                                                         // Send ACK to indicate byte received
1117   4                              RxCounter++;                                                                    // Increment the byte counter
1118   4                                              slaveReadDone = 0;                                                                                              // Mark start of slave read
1119   4                              }
1120   3                              else
1121   3                              {
1122   4                              AA = 0;                                                                         // Send NACK to indicate last byte is re
             -ceived
1123   4                                              slaveReadDone = 1;                                                                                              // Mark end of slave read
1124   4                              }
1125   3                              }
1126   2                  else if(slaveAddr == REAL_TIME_CLOCK_ADDR)
1127   2                              {
1128   3                                      if(RxCounter < numBytesRD)
1129   3                                      {
1130   4                                              sharedDataRx[startAddr + RxCounter] = SMB0DAT;                                  // RTC
C51 COMPILER V9.56.0.0   MAIN                                                              11/25/2017 12:12:32 PAGE 20  

1131   4                                              rtcReadDone = 0;
1132   4                                              
1133   4                                              AA = 1;                                                                                                                 // Send ACK to indicate byte received
1134   4                                              RxCounter++;                                                                                                    // Increment the byte counter
1135   4                                      }
1136   3                                      else
1137   3                                      {
1138   4                                              rtcReadDone = 1;
1139   4                                              AA = 0;                                                                                                                 // Send NACK to indicate last byte is received
1140   4                                      }
1141   3                              }
1142   2                              else if(slaveAddr == EEPROM_ADDR)
1143   2                              {
1144   3                                      if(RxCounter < numBytesRD)
1145   3                                      {
1146   4                                              eepromDataByte = eepromRx[RxCounter] = SMB0DAT;
1147   4                                              AA = 1;                                                                                                                 // Send ACK to indicate byte received
1148   4                                              RxCounter++;                                                                                                    // Increment the byte counter
1149   4                                              eepromReadDone = 0;                                                                                             // Mark start of fram read
1150   4                                      }
1151   3                                      else
1152   3                                      {
1153   4                                              AA = 0;                                                                                                                 // Send NACK to indicate last byte is received
1154   4                                              eepromReadDone = 1;                                                                                             // Mark end of fram read
1155   4                                      }
1156   3                              }
1157   2                      break;
1158   2      
1159   2      //-------------------------------------------------------------------------------------------------------
1160   2      // Master Receiver: Data byte received. If AA flag was cleared, then NACK transmitted.
1161   2      // For a READ: Read operation has completed.  Read data register and send STOP
1162   2      //-------------------------------------------------------------------------------------------------------
1163   2              case SMB_DATA_RX_NACK_TX:
1164   2                              if(slaveAddr == MCU_SLAVE_ADDR)
1165   2                              {
1166   3                                      sharedDataRx[startAddr + RxCounter] = SMB0DAT;
1167   3                              STO = 1;                                                                                                                        // Stop transfer
1168   3                              SMB_BUSY = 0;                                                                                                           // Release SMB
1169   3                              AA = 1;
1170   3                                      slaveReadDone = 1;                                                                                                      // Mark end of slave read                                                                                                                               // Set AA for next transfer   
             -                                                                      
1171   3                              }
1172   2                  else if(slaveAddr == REAL_TIME_CLOCK_ADDR)
1173   2                              {
1174   3                                      sharedDataRx[startAddr + RxCounter] = SMB0DAT;                                          // RTC
1175   3                                      rtcReadDone = 1;
1176   3      
1177   3                                      STO = 1;                                                                                                                        // Stop transfer
1178   3                                      SMB_BUSY = 0;                                                                                                           // Release SMB
1179   3                                      AA = 1;                                                                                                                         // Send ACK to indicate byte received
1180   3                              }
1181   2                              else if(slaveAddr == EEPROM_ADDR)
1182   2                              {
1183   3                                      eepromRx[RxCounter] = SMB0DAT;
1184   3                                      STO = 1;                                                                                                                        // Stop transfer
1185   3                                      SMB_BUSY = 0;                                                                                                           // Release SMB
1186   3                                      AA = 1;
1187   3                                      eepromReadDone = 1;                                                                                                     // Mark end of eeprom read      
1188   3                              }
1189   2                      break;
1190   2      
1191   2      //-------------------------------------------------------------------------------------------------------
C51 COMPILER V9.56.0.0   MAIN                                                              11/25/2017 12:12:32 PAGE 21  

1192   2      // Master Transmitter: Arbitration lost
1193   2      //-------------------------------------------------------------------------------------------------------
1194   2              case SMB_ARBITRATION_LOST:
1195   2                      FAIL = 1;                                                                                       // Indicate failed transfer
1196   2                                                                                                              // and handle at end of ISR
1197   2                      break;
1198   2      
1199   2      //-------------------------------------------------------------------------------------------------------
1200   2      // All other status codes invalid.  Reset communication
1201   2      //-------------------------------------------------------------------------------------------------------
1202   2              default:
1203   2                      FAIL = 1;
1204   2                      break;
1205   2         }
1206   1      //-------------------------------------------------------------------------------------------------------
1207   1      // If all failed, reset everything
1208   1      //-------------------------------------------------------------------------------------------------------
1209   1              if(FAIL)                                                                                                // If the transfer failed,
1210   1              {
1211   2              SMB0CN &= ~0x40;                                                                                // Reset communication
1212   2              SMB0CN |= 0x40;
1213   2              STA = 0;
1214   2              STO = 0;
1215   2              AA = 0;
1216   2      
1217   2              SMB_BUSY = 0;                                                                                   // Free SMBus
1218   2      
1219   2              FAIL = 0;
1220   2                                                                                                                                                                              // Set to finish all pending processes
1221   2                      slaveWriteDone = 1;                                                                                                                     // Mark end of slave write
1222   2                      slaveReadDone = 1;                                                                                                                      // Mark end of slave read
1223   2              rtcWriteDone = 1;
1224   2                      rtcReadDone = 1;
1225   2                      eepromWriteDone = 1;                                                                                                            // Mark end of eeprom write
1226   2                      eepromReadDone = 1;                                                                                                                     // Mark end of eeprom read
1227   2              }
1228   1      
1229   1              SI = 0;                                                                                                 // Clear interrupt flag
1230   1      }
1231          
1232          //-------------------------------------------------------------------------------------------------------
1233          // Function Name: setClockControl
1234          // Return Value: None 
1235          // Parmeters: None
1236          // Function Description: This function sets values to the real time clock control register
1237          // Check DS3232 documentation for more details of this this control register
1238          //-------------------------------------------------------------------------------------------------------
1239          void setClockControl(void)
1240          {
1241   1              sharedDataTx[RTC_START_ADDR + RTC_CONTROL] = 0x04;
1242   1              sharedDataTx[RTC_START_ADDR + RTC_CONTROL_STATUS] = 0x30; 
1243   1              writeBytesToRealTimeClock(RTC_START_ADDR + RTC_CONTROL, 2);                                                     // Set control registers (2 byte)
1244   1      }
1245                                                                            
1246          //-------------------------------------------------------------------------------------------------------
1247          // Function Name: setClock
1248          // Return Value: None 
1249          // Parmeters: None
1250          // Function Description: This function sets the new values to the real time clock
1251          //-------------------------------------------------------------------------------------------------------
1252          void setClock(void)
1253          {       
C51 COMPILER V9.56.0.0   MAIN                                                              11/25/2017 12:12:32 PAGE 22  

1254   1              unsigned char hoursAux;
1255   1              
1256   1              sharedDataTx[RTC_START_ADDR + SECONDS] = convertDecimalToBCD(seconds);                          // Load all data from PC to arr
             -ay before writing
1257   1              sharedDataTx[RTC_START_ADDR + MINUTES] = convertDecimalToBCD(minutes);                          // All data: seconds,.... are a
             -lready converted to BCD
1258   1              sharedDataTx[RTC_START_ADDR + DAY] = convertDecimalToBCD(day);
1259   1              sharedDataTx[RTC_START_ADDR + DATE] = convertDecimalToBCD(date);
1260   1              sharedDataTx[RTC_START_ADDR + MONTH] = convertDecimalToBCD(month);
1261   1              sharedDataTx[RTC_START_ADDR + YEAR] = convertDecimalToBCD(year);
1262   1              
1263   1              hoursAux = convertDecimalToBCD(hours);                                                                                          // Get updated hours from user on screen
1264   1      
1265   1              hoursAux = hoursAux | 0x40;                                                                                                                     // Set 12/24 bit --> 12 hour mode
1266   1              
1267   1              if(amPm == 'P')
1268   1              {
1269   2                       hoursAux = hoursAux | 0x60;                                                                                                    // Set AM/PM bit --> PM mode
1270   2              }
1271   1              else if(amPm == 'A')
1272   1              {
1273   2                       hoursAux = hoursAux & 0x5F;                                                                                                    // Clear AM/PM bit --> AM mode
1274   2              }
1275   1              
1276   1              sharedDataTx[RTC_START_ADDR + HOURS] = hoursAux;
1277   1              
1278   1              writeBytesToRealTimeClock(RTC_START_ADDR, 7);                                       // Write 7 bytes to R
             -TC
1279   1      
1280   1              //resetAllDisplayCounters();                                                                                                                    // Update new values on screen
1281   1      }                       
1282          
1283          //-------------------------------------------------------------------------------------------------------
1284          // Function Name: getClockData()
1285          // Return Value: None 
1286          // Parmeters: None
1287          // Function Description: This function gets the new values from the real time clock
1288          //-------------------------------------------------------------------------------------------------------
1289          void getClockData()
1290          {
1291   1              static unsigned char previousMonth = 0;
1292   1              static unsigned char previousDate = 0;
1293   1              static unsigned char previousYear = 0;
1294   1              static unsigned char previousHours = 0;
1295   1              static unsigned char previousMinutes = 0;
1296   1              static unsigned char previousSeconds = 0;
1297   1              
1298   1              unsigned int currentIndex = 0;
1299   1              unsigned char tempHours;
1300   1              
1301   1              readBytesFromRealTimeClock(RTC_START_ADDR, 7);                                                                          // Get date and time (7 bytes)
1302   1      
1303   1              seconds = convertBCDToDecimal(sharedDataRx[RTC_START_ADDR + SECONDS]);                          // Convert BCD to decimal for s
             -econds (1 byte)
1304   1              minutes = convertBCDToDecimal(sharedDataRx[RTC_START_ADDR + MINUTES]);                          // Convert BCD to decimal for m
             -inutes (1 byte)
1305   1      
1306   1              tempHours = sharedDataRx[RTC_START_ADDR + HOURS];                                                                       // Get BCD without conversion and check AM/PM
1307   1      
1308   1              if(tempHours & 0x40)                                                                                                                            // 12/24 bit (bit 6) is set --> 12 hour mode
1309   1              {
1310   2                      timeMode = TWELVE_HR_MODE;
C51 COMPILER V9.56.0.0   MAIN                                                              11/25/2017 12:12:32 PAGE 23  

1311   2      
1312   2                      if(tempHours & 0x20)                                                                                                                    // PM/AM bit (bit 5) is set --> PM
1313   2                      {
1314   3                              amPm = 'P';
1315   3                      }
1316   2                      else
1317   2                      {
1318   3                          amPm = 'A';
1319   3                      }
1320   2              }
1321   1              else
1322   1              {
1323   2                      timeMode = TWENTY_FOUR_HR_MODE;
1324   2              }
1325   1      
1326   1              hours = convertBCDToDecimal(tempHours & 0x1F);                                                                          // Get hours (bit 4 to bit 0 only. Ignore others)
1327   1      
1328   1              if(hours == 12)
1329   1              {
1330   2                      if(amPm == 'A')
1331   2                      {
1332   3                              hours24 = 0;
1333   3                      }
1334   2                      else
1335   2                      {
1336   3                              hours24 = hours;
1337   3                      }       
1338   2              }
1339   1              else
1340   1              {
1341   2                      if(amPm == 'P')
1342   2                      {
1343   3                              hours24 = hours + 12;                                                                                                           // Twenty four hour format if PM
1344   3                      }
1345   2                      else
1346   2                      {
1347   3                              hours24 = hours;                                                                                                                        // Twenty four hour format if AM
1348   3                      }
1349   2              }
1350   1      
1351   1              day = convertBCDToDecimal(sharedDataRx[RTC_START_ADDR + DAY]);                                          // Convert BCD to decimal for day (1 
             -byte)
1352   1              date = convertBCDToDecimal(sharedDataRx[RTC_START_ADDR + DATE]);                                        // Convert BCD to decimal for date (
             -1 byte)
1353   1              month = convertBCDToDecimal(sharedDataRx[RTC_START_ADDR + MONTH]);                                      // Convert BCD to decimal for mont
             -h (1 byte)
1354   1              year = convertBCDToDecimal(sharedDataRx[RTC_START_ADDR + YEAR]);                                        // Convert BCD to decimal for year (
             -1 byte)
1355   1      
1356   1              if(month != previousMonth || date != previousDate || year != previousYear)
1357   1              {
1358   2                      monthDateYearUpdated = SET;     
1359   2              }
1360   1              if(hours != previousHours || minutes != previousMinutes || seconds != previousSeconds)
1361   1              {
1362   2                      timeUpdated = SET;
1363   2              }
1364   1      
1365   1              if(amPm == 'P')
1366   1              {
1367   2                      currentIndex = ((12 + hours) * 60) + minutes;
1368   2              }
C51 COMPILER V9.56.0.0   MAIN                                                              11/25/2017 12:12:32 PAGE 24  

1369   1              else if(amPm == 'A')
1370   1              {
1371   2                      if(hours == 12)
1372   2                      {
1373   3                              hours = 0;
1374   3                      }
1375   2                      
1376   2                      currentIndex = (hours * 60) + minutes;
1377   2              }
1378   1              else
1379   1              {}
1380   1      
1381   1              minuteIndex = currentIndex % 60;                                                                                                        // Get minute index from 0 - 59
1382   1              hourIndex = currentIndex / 60;                                                                                                          // Get hour index from 0 - 23
1383   1      
1384   1              previousDate = date;
1385   1              previousMonth = month;
1386   1              previousYear = year;
1387   1              previousHours = hours;
1388   1              previousMinutes = minutes;
1389   1              previousSeconds = seconds;
1390   1      }
1391          
1392          //-------------------------------------------------------------------------------------------------------
1393          // Function Name: moveDateTimeUp
1394          // Return Value: None 
1395          // Parmeters: None
1396          // Function Description: This function sets date and time of the clock from the touch screen by pressing t
             -he up button
1397          //-------------------------------------------------------------------------------------------------------
1398          void moveDateTimeUp(void)
1399          {
1400   1              char str[SPRINTF_SIZE];
1401   1              
1402   1              if(realTimeClockItems == MONTH_ADJUST)
1403   1              {
1404   2                      adjustedMonth++;
1405   2                      monthUpdated = SET;
1406   2      
1407   2                      if(adjustedMonth > 12)
1408   2                      {
1409   3                              adjustedMonth = 1;                                                                                                                      // Roll over
1410   3                      }
1411   2      
1412   2                      sprintf(str, "%s ", monthOfYear[adjustedMonth]);
1413   2                      displayText(VALUE_DISPLAY_FG, VALUE_DISPLAY_BG, VALUE_DISPLAY_FONT, str, VALUE_DISPLAY_X, VALUE_DISPLAY_
             -Y);
1414   2              }
1415   1              else if(realTimeClockItems == DATE_ADJUST)
1416   1              {
1417   2                      adjustedDate++;
1418   2                      dateUpdated = SET;
1419   2      
1420   2                      if(adjustedDate > 31)
1421   2                      {
1422   3                              adjustedDate = 1;                                                                                                                       // Roll over
1423   3                      }
1424   2      
1425   2                      sprintf(str, "%bu   ", adjustedDate);
1426   2                      displayText(VALUE_DISPLAY_FG, VALUE_DISPLAY_BG, VALUE_DISPLAY_FONT, str, VALUE_DISPLAY_X, VALUE_DISPLAY_
             -Y);
1427   2              }
C51 COMPILER V9.56.0.0   MAIN                                                              11/25/2017 12:12:32 PAGE 25  

1428   1              else if(realTimeClockItems == YEAR_ADJUST)
1429   1              {
1430   2                      adjustedYear++;
1431   2                      yearUpdated = SET;
1432   2      
1433   2                      if(adjustedYear > 99)
1434   2                      {
1435   3                              adjustedYear = 99;
1436   3                      }
1437   2      
1438   2                      sprintf(str, "20%02bu", adjustedYear);
1439   2                      displayText(VALUE_DISPLAY_FG, VALUE_DISPLAY_BG, VALUE_DISPLAY_FONT, str, VALUE_DISPLAY_X, VALUE_DISPLAY_
             -Y);
1440   2              }
1441   1              else if(realTimeClockItems == HOUR_ADJUST)
1442   1              {
1443   2                      adjustedHours++;
1444   2                      hoursUpdated = SET;
1445   2      
1446   2                      if(adjustedHours > 12)
1447   2                      {
1448   3                              adjustedHours = 1;                                                                                                                      // Roll over
1449   3                      }
1450   2      
1451   2                      sprintf(str, "%bu   ", adjustedHours);
1452   2                      displayText(VALUE_DISPLAY_FG, VALUE_DISPLAY_BG, VALUE_DISPLAY_FONT, str, VALUE_DISPLAY_X, VALUE_DISPLAY_
             -Y);
1453   2              }
1454   1              else if(realTimeClockItems == MINUTE_ADJUST)
1455   1              {
1456   2                      adjustedMinutes++;
1457   2                      minutesUpdated = SET;
1458   2      
1459   2                      if(adjustedMinutes > 59)
1460   2                      {
1461   3                              adjustedMinutes = 0;
1462   3                      }
1463   2      
1464   2                      sprintf(str, "%bu   ", adjustedMinutes);
1465   2                      displayText(VALUE_DISPLAY_FG, VALUE_DISPLAY_BG, VALUE_DISPLAY_FONT, str, VALUE_DISPLAY_X, VALUE_DISPLAY_
             -Y);
1466   2              }
1467   1              else if(realTimeClockItems == AMPM_ADJUST)
1468   1              {
1469   2                      if(adjustedAmPm == 'P')
1470   2                      {
1471   3                              adjustedAmPm = 'A';
1472   3                      }
1473   2                      else if(adjustedAmPm == 'A')
1474   2                      {
1475   3                              adjustedAmPm = 'P';
1476   3                      }
1477   2                      else
1478   2                      {}
1479   2      
1480   2                      amPmUpdated = SET;
1481   2      
1482   2                      sprintf(str, "%cM  ", adjustedAmPm);
1483   2                      displayText(VALUE_DISPLAY_FG, VALUE_DISPLAY_BG, VALUE_DISPLAY_FONT, str, VALUE_DISPLAY_X, VALUE_DISPLAY_
             -Y);
1484   2              }
1485   1              else
C51 COMPILER V9.56.0.0   MAIN                                                              11/25/2017 12:12:32 PAGE 26  

1486   1              {}
1487   1      }
1488          
1489          //-------------------------------------------------------------------------------------------------------
1490          // Function Name: moveDateTimeDown
1491          // Return Value: None 
1492          // Parmeters: None
1493          // Function Description: This function sets date and time of the clock from the touch screen by pressing t
             -he down button
1494          //-------------------------------------------------------------------------------------------------------
1495          void moveDateTimeDown(void)
1496          {
1497   1              char str[SPRINTF_SIZE];
1498   1      
1499   1              if(realTimeClockItems == MONTH_ADJUST)
1500   1              {
1501   2                      adjustedMonth--;
1502   2                      monthUpdated = SET;
1503   2      
1504   2                      if(adjustedMonth < 1)
1505   2                      {
1506   3                              adjustedMonth = 12;                                                                                                                     // Roll over to hour 12
1507   3                      }
1508   2                      sprintf(str, "%s ", monthOfYear[adjustedMonth]);
1509   2                      displayText(VALUE_DISPLAY_FG, VALUE_DISPLAY_BG, VALUE_DISPLAY_FONT, str, VALUE_DISPLAY_X, VALUE_DISPLAY_
             -Y);
1510   2              }
1511   1              else if(realTimeClockItems == DATE_ADJUST)
1512   1              {
1513   2                      adjustedDate--;
1514   2                      dateUpdated = SET;
1515   2      
1516   2                      if(adjustedDate < 1)
1517   2                      {
1518   3                              adjustedDate = 31;                                                                                                                      // Roll over to day 31
1519   3                      }
1520   2      
1521   2                      sprintf(str, "%bu   ", adjustedDate);
1522   2                      displayText(VALUE_DISPLAY_FG, VALUE_DISPLAY_BG, VALUE_DISPLAY_FONT, str, VALUE_DISPLAY_X, VALUE_DISPLAY_
             -Y);
1523   2              }
1524   1              else if(realTimeClockItems == YEAR_ADJUST)
1525   1              {
1526   2                      if(adjustedYear > 0)
1527   2                      {
1528   3                              adjustedYear--;                                                                                                                         // Check if it is greater than 0 before decrementing                                                                                            
1529   3                      }                                                                                                                                                               // to avoid a negative number
1530   2                      else
1531   2                      {
1532   3                              adjustedYear = 0;                                                                                                                       // Roll over to 99
1533   3                      }
1534   2                      
1535   2                      yearUpdated = SET;
1536   2      
1537   2                      sprintf(str, "20%02bu", adjustedYear);
1538   2                      displayText(VALUE_DISPLAY_FG, VALUE_DISPLAY_BG, VALUE_DISPLAY_FONT, str, VALUE_DISPLAY_X, VALUE_DISPLAY_
             -Y);
1539   2              }
1540   1              else if(realTimeClockItems == HOUR_ADJUST)
1541   1              {
1542   2                      if(adjustedHours > 0)
1543   2                      {
C51 COMPILER V9.56.0.0   MAIN                                                              11/25/2017 12:12:32 PAGE 27  

1544   3                              adjustedHours--;                                                                                                                        // Check if it is greater than 0 before decrementing
1545   3                      }                                                                                                                                                               // to avoid a negative number
1546   2                      else
1547   2                      {
1548   3                              adjustedHours = 12;
1549   3                      }
1550   2      
1551   2                      hoursUpdated = SET;
1552   2      
1553   2                      sprintf(str, "%bu   ", adjustedHours);
1554   2                      displayText(VALUE_DISPLAY_FG, VALUE_DISPLAY_BG, VALUE_DISPLAY_FONT, str, VALUE_DISPLAY_X, VALUE_DISPLAY_
             -Y);
1555   2              }
1556   1              else if(realTimeClockItems == MINUTE_ADJUST)
1557   1              {
1558   2                      if(adjustedMinutes > 0)
1559   2                      {
1560   3                              adjustedMinutes--;                                                                                                                      // Check if it is greater than 0 before decrementing
1561   3                      }                                                                                                                                                               // to avoid a negative number
1562   2                      else
1563   2                      {
1564   3                              adjustedMinutes = 59;
1565   3                      }
1566   2      
1567   2                      minutesUpdated = SET;
1568   2      
1569   2                      sprintf(str, "%bu   ", adjustedMinutes);
1570   2                      displayText(VALUE_DISPLAY_FG, VALUE_DISPLAY_BG, VALUE_DISPLAY_FONT, str, VALUE_DISPLAY_X, VALUE_DISPLAY_
             -Y);
1571   2              }
1572   1              else if(realTimeClockItems == AMPM_ADJUST)
1573   1              {
1574   2                      if(adjustedAmPm == 'P')
1575   2                      {
1576   3                              adjustedAmPm = 'A';
1577   3                      }
1578   2                      else if(adjustedAmPm == 'A')
1579   2                      {
1580   3                              adjustedAmPm = 'P';
1581   3                      }
1582   2                      else
1583   2                      {}
1584   2      
1585   2                      amPmUpdated = SET;
1586   2      
1587   2                      sprintf(str, "%cM  ", adjustedAmPm);
1588   2                      displayText(VALUE_DISPLAY_FG, VALUE_DISPLAY_BG, VALUE_DISPLAY_FONT, str, VALUE_DISPLAY_X, VALUE_DISPLAY_
             -Y);
1589   2              }
1590   1              else
1591   1              {}
1592   1      }
1593          
1594          //-------------------------------------------------------------------------------------------------------
1595          // Function Name: enterDateTime
1596          // Return Value: None 
1597          // Parmeters: None
1598          // Function Description: This function confirms the date or time set by the user on the touch screen
1599          //-------------------------------------------------------------------------------------------------------
1600          void enterDateTime(void)
1601          {
1602   1              char str[SPRINTF_SIZE];
C51 COMPILER V9.56.0.0   MAIN                                                              11/25/2017 12:12:32 PAGE 28  

1603   1              
1604   1              realTimeClockItems++;                                                                                                                           // Move to next item
1605   1              
1606   1              if(realTimeClockItems == MONTH_ADJUST)
1607   1              {
1608   2                      monthUpdated = SET;
1609   2                      displayText(TITLE_DISPLAY_FG, TITLE_DISPLAY_BG, TITLE_DISPLAY_FONT, "SET MONTH ", TITLE_DISPLAY_X, TITLE
             -_DISPLAY_Y);
1610   2                      sprintf(str, "%s ", monthOfYear[adjustedMonth]);
1611   2                      displayText(VALUE_DISPLAY_FG, VALUE_DISPLAY_BG, VALUE_DISPLAY_FONT, str, VALUE_DISPLAY_X, VALUE_DISPLAY_
             -Y);
1612   2              }
1613   1              else if(realTimeClockItems == DATE_ADJUST)
1614   1              {
1615   2                      dateUpdated = SET;
1616   2                      displayText(TITLE_DISPLAY_FG, TITLE_DISPLAY_BG, TITLE_DISPLAY_FONT, "SET DATE  ", TITLE_DISPLAY_X, TITLE
             -_DISPLAY_Y);
1617   2                      sprintf(str, "%bu   ", adjustedDate);
1618   2                      displayText(VALUE_DISPLAY_FG, VALUE_DISPLAY_BG, VALUE_DISPLAY_FONT, str, VALUE_DISPLAY_X, VALUE_DISPLAY_
             -Y);
1619   2              }
1620   1              else if(realTimeClockItems == YEAR_ADJUST)
1621   1              {
1622   2                      yearUpdated = SET;
1623   2                      displayText(TITLE_DISPLAY_FG, TITLE_DISPLAY_BG, TITLE_DISPLAY_FONT, "SET YEAR  ", TITLE_DISPLAY_X, TITLE
             -_DISPLAY_Y);
1624   2                      sprintf(str, "20%02bu", adjustedYear);
1625   2                      displayText(VALUE_DISPLAY_FG, VALUE_DISPLAY_BG, VALUE_DISPLAY_FONT, str, VALUE_DISPLAY_X, VALUE_DISPLAY_
             -Y);
1626   2              }
1627   1              else if(realTimeClockItems == HOUR_ADJUST)
1628   1              {
1629   2                      hoursUpdated = SET;
1630   2                      displayText(TITLE_DISPLAY_FG, TITLE_DISPLAY_BG, TITLE_DISPLAY_FONT, "SET HOUR  ", TITLE_DISPLAY_X, TITLE
             -_DISPLAY_Y);
1631   2                      sprintf(str, "%bu   ", adjustedHours);
1632   2                      displayText(VALUE_DISPLAY_FG, VALUE_DISPLAY_BG, VALUE_DISPLAY_FONT, str, VALUE_DISPLAY_X, VALUE_DISPLAY_
             -Y);
1633   2              }
1634   1              else if(realTimeClockItems == MINUTE_ADJUST)
1635   1              {
1636   2                      minutesUpdated = SET;
1637   2                      amPmUpdated = SET;                                                                                                                              // Set it anyway because user usually does not set at the end
1638   2                      displayText(TITLE_DISPLAY_FG, TITLE_DISPLAY_BG, TITLE_DISPLAY_FONT, "SET MINUTE", TITLE_DISPLAY_X, TITLE
             -_DISPLAY_Y);
1639   2                      sprintf(str, "%bu   ", adjustedMinutes);
1640   2                      displayText(VALUE_DISPLAY_FG, VALUE_DISPLAY_BG, VALUE_DISPLAY_FONT, str, VALUE_DISPLAY_X, VALUE_DISPLAY_
             -Y);
1641   2              }
1642   1              else if(realTimeClockItems == AMPM_ADJUST)
1643   1              {
1644   2                      amPmUpdated = SET;                                                                                                                              // Set it anyway because user usually does not set at the end
1645   2                      displayText(TITLE_DISPLAY_FG, TITLE_DISPLAY_BG, TITLE_DISPLAY_FONT, "SET AM/PM ", TITLE_DISPLAY_X, TITLE
             -_DISPLAY_Y);
1646   2                      sprintf(str, "%cM  ", adjustedAmPm);
1647   2                      displayText(VALUE_DISPLAY_FG, VALUE_DISPLAY_BG, VALUE_DISPLAY_FONT, str, VALUE_DISPLAY_X, VALUE_DISPLAY_
             -Y);
1648   2              }
1649   1              else if(realTimeClockItems == DONE_ADJUST)
1650   1              {
1651   2                      amPmUpdated = SET;                                                                                                                              // Set it if user explicitly press enter button
1652   2                      displayText(TITLE_DISPLAY_FG, TITLE_DISPLAY_BG, TITLE_DISPLAY_FONT, "PRESS DONE", TITLE_DISPLAY_X, TITLE
C51 COMPILER V9.56.0.0   MAIN                                                              11/25/2017 12:12:32 PAGE 29  

             -_DISPLAY_Y);
1653   2                      displayText(VALUE_DISPLAY_FG, VALUE_DISPLAY_BG, VALUE_DISPLAY_FONT, "----", VALUE_DISPLAY_X, VALUE_DISPL
             -AY_Y);
1654   2              }
1655   1              else if(realTimeClockItems == ROLL_OVER_ADJUST)
1656   1              {
1657   2                      realTimeClockItems = MONTH_ADJUST;                                                                                              // Set it for next round of real time clock items
1658   2                      monthUpdated = SET;
1659   2                      displayText(TITLE_DISPLAY_FG, TITLE_DISPLAY_BG, TITLE_DISPLAY_FONT, "SET MONTH ", TITLE_DISPLAY_X, TITLE
             -_DISPLAY_Y);
1660   2                      sprintf(str, "%s ", monthOfYear[adjustedMonth]);
1661   2                      displayText(VALUE_DISPLAY_FG, VALUE_DISPLAY_BG, VALUE_DISPLAY_FONT, str, VALUE_DISPLAY_X, VALUE_DISPLAY_
             -Y);
1662   2              }
1663   1              else
1664   1              {}
1665   1      }
1666          
1667          //-------------------------------------------------------------------------------------------------------
1668          // Function Name: setClockOnScreen
1669          // Return Value: None 
1670          // Parmeters: None
1671          // Function Description: This function sets the real time clock on the touch screen
1672          //-------------------------------------------------------------------------------------------------------
1673          void setClockOnScreen(void)
1674          {               
1675   1              unsigned char hoursAux;
1676   1              
1677   1              if(monthUpdated == SET)
1678   1              {
1679   2                      sharedDataTx[RTC_START_ADDR + MONTH] = convertDecimalToBCD(adjustedMonth);              // Get updated month from us
             -er on screen
1680   2                      writeBytesToRealTimeClock(RTC_START_ADDR + MONTH, 1);                                                   // Set month only (1 byte)
1681   2                      monthUpdated = CLEAR;                                                                                                                   //Clear flag after writing to real time clock                                                                                                   
1682   2              }
1683   1              
1684   1              if(dateUpdated == SET)
1685   1              {
1686   2                      sharedDataTx[RTC_START_ADDR + DATE] = convertDecimalToBCD(adjustedDate);                // Get updated date from user 
             -on screen
1687   2                      writeBytesToRealTimeClock(RTC_START_ADDR + DATE, 1);                                                    // Set date only (1 byte)
1688   2                      dateUpdated = CLEAR;
1689   2              }
1690   1      
1691   1              if(yearUpdated == SET)
1692   1              {
1693   2                      sharedDataTx[RTC_START_ADDR + YEAR] = convertDecimalToBCD(adjustedYear);                // Get updated year from user 
             -on screen
1694   2                      writeBytesToRealTimeClock(RTC_START_ADDR + YEAR, 1);                                                    // Set year only (1 byte)
1695   2                      yearUpdated = CLEAR;
1696   2              }
1697   1      
1698   1              if(hoursUpdated == SET || amPmUpdated == SET)
1699   1              {
1700   2                      hoursAux = convertDecimalToBCD(adjustedHours);                                                                  // Get updated hours from user on screen
1701   2                      
1702   2                      if(amPmUpdated == SET)
1703   2                      {
1704   3                              amPm = adjustedAmPm;                                                                                                            // Set updated amPm from user on screen
1705   3                      
1706   3                              hoursAux = hoursAux | 0x40;                                                                                                     // Set 12/24 bit --> 12 hour mode
1707   3                              
C51 COMPILER V9.56.0.0   MAIN                                                              11/25/2017 12:12:32 PAGE 30  

1708   3                              if(adjustedAmPm == 'P')
1709   3                              {                                                                                                                                       
1710   4                                      hoursAux = hoursAux | 0x60;                                                                                             // Set AM/PM bit --> PM mode
1711   4                              }
1712   3                              else if(adjustedAmPm == 'A')
1713   3                              {                                                                                                                                       
1714   4                                      hoursAux = hoursAux & 0x5F;                                                                                             // Clear AM/PM bit --> AM mode
1715   4                              }
1716   3                              else
1717   3                              {}
1718   3      
1719   3                              amPmUpdated = CLEAR;
1720   3                      }
1721   2                      
1722   2                      sharedDataTx[RTC_START_ADDR + HOURS] = hoursAux;
1723   2                      writeBytesToRealTimeClock(RTC_START_ADDR + HOURS, 1);                                                   // Set hours only (1 byte)
1724   2                      hoursUpdated = CLEAR; 
1725   2              }
1726   1      
1727   1              if(minutesUpdated == SET)
1728   1              {
1729   2                      sharedDataTx[RTC_START_ADDR + MINUTES] = convertDecimalToBCD(adjustedMinutes);  // Get updated minutes fr
             -om user on screen
1730   2                      writeBytesToRealTimeClock(RTC_START_ADDR + MINUTES, 1);                                                 // Set minutes only (1 byte)
1731   2                      minutesUpdated = CLEAR;
1732   2              }
1733   1      
1734   1              realTimeClockItems = MONTH_ADJUST;                                                                                                      // Set starting item = Month for adjustment
1735   1      
1736   1              getClockData();                                                                                                                                     // Get current month, date, year set by user
1737   1      
1738   1              //clockSetupDisplayRepeat = 0;                                                                                                          // Display clock updates on screen                                                                                                                                              // Syste
             -m goes back to main page                                      
1739   1      }
1740          
1741          //-------------------------------------------------------------------------------------------------------
1742          // Function Name: resetClock
1743          // Return Value: None 
1744          // Parmeters: None
1745          // Function Description: This function resets the real time clock to 0:00:00 1/1/2000
1746          //-------------------------------------------------------------------------------------------------------
1747          void resetClock(void)
1748          {
1749   1              seconds = 0;
1750   1              minutes = 0;
1751   1              hours = 0;
1752   1              amPm = 'P';
1753   1              day = 1;
1754   1              date = 1;
1755   1              month = 1;
1756   1              year = 0;
1757   1              century = 0;
1758   1              timeMode = 1;
1759   1      
1760   1              setClock();                                                                                                                                     // Set real time clock
1761   1      }
1762          
1763          //-------------------------------------------------------------------------------------------------------
1764          // Function Name: convertDecimalToBCD
1765          // Return Value: bcd 
1766          // Parmeters: decimal
1767          // Function Description: This function converts a decimal number to a BCD when writing the new value to th
C51 COMPILER V9.56.0.0   MAIN                                                              11/25/2017 12:12:32 PAGE 31  

             -e real time clock
1768          //-------------------------------------------------------------------------------------------------------
1769          unsigned char convertDecimalToBCD(unsigned char decimal)
1770          {
1771   1              unsigned char bcd;
1772   1      
1773   1              bcd = (decimal / 10) << 4;                                                                                                                      // Get upper 4 bits
1774   1              bcd = bcd | (decimal % 10);                                                                                                                     // Get a BCD
1775   1      
1776   1              return bcd;
1777   1      }
1778          
1779          //-------------------------------------------------------------------------------------------------------
1780          // Function Name: convertBCDToDecimal
1781          // Return Value: decimal value 
1782          // Parmeters: bcd
1783          // Function Description: This function converts a BCD to a decimal number when reading the current value f
             -rom the real time clock
1784          //-------------------------------------------------------------------------------------------------------
1785          unsigned char convertBCDToDecimal(unsigned char bcd)
1786          {
1787   1              unsigned char decimal;
1788   1      
1789   1              decimal = ((bcd >> 4) * 10) + (bcd & 0x0F);                                                                                     // Combine upper and lower nibbles to get
1790   1                                                                                                                                                                                      // 8 bit number
1791   1              return decimal;
1792   1      }
1793          
1794          //-------------------------------------------------------------------------------------------------------
1795          // Function Name: displayClock
1796          // Return Value: None 
1797          // Parmeters: None
1798          // Function Description: This function displays clock data on the touch screen
1799          // The clock format is MM/DD/YYYY hour/minute/second
1800          //-------------------------------------------------------------------------------------------------------
1801          void displayClock(void)
1802          {
1803   1              char str[SPRINTF_SIZE];
1804   1              
1805   1              //if(screen == MAIN_PAGE)
1806   1              //{
1807   1              getClockData();
1808   1      
1809   1              sprintf(str, "%s %02bu, 20%02bu", monthOfYear[month], date, year);
1810   1              displayText(SETTINGS_DATE_FG, SETTINGS_DATE_BG, SETTINGS_DATE_FONT, str, SETTINGS_DATE_X, SETTINGS
             -_DATE_Y);
1811   1              monthDateYearUpdated = CLEAR;
1812   1              
1813   1              sprintf(str, "%2bu:%02bu:%02bu %cM ", hours, minutes, seconds, amPm);
1814   1              displayText(SETTINGS_TIME_FG, SETTINGS_TIME_BG, SETTINGS_TIME_FONT, str, SETTINGS_TIME_X, SETTINGS
             -_TIME_Y);
1815   1              //}
1816   1              /*else if(screen == CLOCK_SETUP_PAGE)
1817   1              {
1818   1                      if(buttonPressed == CLEAR)
1819   1                      {
1820   1                              getClockData();
1821   1              
1822   1                              sprintf(str, "%s %02bu, 20%02bu", monthOfYear[month], date, year);
1823   1                              displayText(DATE_DISPLAY_FG, DATE_DISPLAY_BG, DATE_DISPLAY_FONT, str, DATE_DISPLAY_X, DATE_DISPLAY_Y);
1824   1                              monthDateYearUpdated = CLEAR;
1825   1      
C51 COMPILER V9.56.0.0   MAIN                                                              11/25/2017 12:12:32 PAGE 32  

1826   1                              sprintf(str, "%2bu:%02bu:%02bu %cM ", hours, minutes, seconds, amPm);
1827   1                              displayText(TIME_DISPLAY_FG, TIME_DISPLAY_BG, TIME_DISPLAY_FONT, str, TIME_DISPLAY_X, TIME_DISPLAY_Y);
1828   1                              timeUpdated = CLEAR;
1829   1                      }
1830   1              }*/
1831   1      }
1832          
1833          void display_text(const char * fg, const char * bg, const unsigned char size, const char * message, const 
             -int x, const int y)
1834          {
1835   1          char str[128] = { 0 };
1836   1          
1837   1          int i = 0;
1838   1          while(i < 10000) i++;
1839   1              
1840   1          sprintf(str, "S %s %s\r", fg, bg);
1841   1          sendCommand(str);
1842   1          sprintf(str, "f %s\r", Font[size]);
1843   1          sendCommand(str);
1844   1          sprintf(str, "t \"%s\" %u %u\r", message, x, y);
1845   1          sendCommand(str);
1846   1      }
1847          
1848          static void send_macro(const unsigned int macro_index)
1849          {
1850   1          char str[8] = { 0 };
1851   1          
1852   1          int i = 0;
1853   1          while(i < 10000) i++;
1854   1              
1855   1          sprintf(str, "m %u\r", macro_index);
1856   1          sendCommand(str);
1857   1      }
1858          
1859          //-------------------------------------------------------------------------------------------------------
1860          // Main
1861          //-------------------------------------------------------------------------------------------------------
1862          #define NOOP(x)              // do nothings
1863          
1864          #define PAGE_SPLASH          0
1865          #define PAGE_MAIN            1
1866          #define PAGE_SETTINGS        2
1867          #define PAGE_SERVICE         3
1868          #define PAGE_CONFIG          4
1869          int current_page = PAGE_MAIN;
1870          
1871          static int user_cmd_equals(char * cmd)
1872          {
1873   1          return (cmd[0] == userCommand[1] && cmd[1] == userCommand[2] && cmd[2] == userCommand[3]);
1874   1      }
1875          
1876          void main()
1877          {
1878   1          int i = 0;
1879   1          int count = 0;
1880   1          int prev_temp = 0;
1881   1          int display_celsius = 0;
1882   1          int state_changed = 1;
1883   1          char str[SPRINTF_SIZE];
1884   1          
1885   1          disableWatchdog();
1886   1          systemClockInit();
C51 COMPILER V9.56.0.0   MAIN                                                              11/25/2017 12:12:32 PAGE 33  

1887   1          portInit();
1888   1          enableInterrupts();
1889   1          uart0Init();
1890   1          smbInit();
1891   1          timer3Init();
1892   1          
1893   1          tsLastCharGone = 1;
1894   1          tsTxOut = tsTxIn = 0;
1895   1          tsTxEmpty = 1;
1896   1          
1897   1          sprintf(str, "z\r");
1898   1          sendCommand(str);
1899   1      
1900   1          // send_macro(Splash);
1901   1          
1902   1          #define change_state(state) \
1903   1              current_page = state;   \
1904   1              state_changed = 1
1905   1          
1906   1          while(1)
1907   1          {
1908   2              //scanUserInput();                                                        // Detect a string input
             - from the touch screen
1909   2              
1910   2              #define change_state(state) \
1911   2                  current_page = state;   \
1912   2                  state_changed = 1
1913   2      
1914   2      
1915   2              switch(current_page) 
1916   2              {
1917   3                  case (PAGE_SETTINGS):
1918   3                  {
1919   4                      if (state_changed) {
1920   5                          state_changed = 0;
1921   5                          display_text("000000", "FFFFFF", 8, "set!", 240, 110);
1922   5                      }
1923   4      
1924   4                      if ('1' == userCommand[1] && '3' == userCommand[2] && '1' == userCommand[3]) {
1925   5                          change_state(PAGE_SETTINGS);
1926   5                      }
1927   4                      else if ('1' == userCommand[1] && '2' == userCommand[2] && '8' == userCommand[3]) {
1928   5                          change_state(PAGE_MAIN);
1929   5                      }
1930   4                      else if ('1' == userCommand[1] && '3' == userCommand[2] && '2' == userCommand[3]) {
1931   5                          change_state(PAGE_SERVICE);
1932   5                      }
1933   4                      else {
1934   5                          // NOOP
1935   5                      }
1936   4                      break;
1937   4                  }
1938   3                  case (PAGE_CONFIG):
1939   3                  {
1940   4                      if (state_changed) {
1941   5                          state_changed = 0;
1942   5                          display_text("000000", "FFFFFF", 8, "cfg!", 240, 110);
1943   5                      }
1944   4              
1945   4                      if ('1' == userCommand[1] && '3' == userCommand[2] && '1' == userCommand[3]) {
1946   5                          change_state(PAGE_SETTINGS);
1947   5                      }
C51 COMPILER V9.56.0.0   MAIN                                                              11/25/2017 12:12:32 PAGE 34  

1948   4                      else if ('1' == userCommand[1] && '2' == userCommand[2] && '8' == userCommand[3]) {
1949   5                          change_state(PAGE_MAIN);
1950   5                      }
1951   4                      else if ('1' == userCommand[1] && '3' == userCommand[2] && '2' == userCommand[3]) {
1952   5                          change_state(PAGE_SERVICE);
1953   5                      }
1954   4                      else {
1955   5                          // NOOP
1956   5                      }
1957   4                      break;
1958   4                  }
1959   3                  case (PAGE_SERVICE):
1960   3                  {
1961   4                      if (state_changed) {
1962   5                          state_changed = 0;
1963   5                          display_text("000000", "FFFFFF", 8, "svc!", 240, 110);
1964   5                      }
1965   4                                                                      
1966   4                                                                      
1967   4                                                                /*for (k = 0; k < 4 ; k++){
1968   4                                                                              if (passcode[k][0] == userCommand[1] && passcode[k][1] == userCommand[2] && passcode[k][2] == use
             -rCommand[3]) {
1969   4                                                                              tsCommandReceived  = 0;
1970   4                                                                                      if (k == 3)
1971   4                                                                                              display_text("000000","FFFFFF",8,"OK!", 240,200);
1972   4                                                                              while(tsCommandReceived == 0);
1973   4                                                                       }
1974   4                                                                              else{
1975   4                                                                                      continue;
1976   4                                                                              }
1977   4                                                               }      */                                                      
1978   4                      if ('1' == userCommand[1] && '3' == userCommand[2] && '1' == userCommand[3]) {
1979   5                          change_state(PAGE_SETTINGS);
1980   5                      }
1981   4                      else if ('1' == userCommand[1] && '2' == userCommand[2] && '8' == userCommand[3]) {
1982   5                          change_state(PAGE_MAIN);
1983   5                      }
1984   4                      else if ('1' == userCommand[1] && '3' == userCommand[2] && '2' == userCommand[3]) {
1985   5                          change_state(PAGE_SERVICE);
1986   5                      }
1987   4                      else {
1988   5                          // NOOP
1989   5                      }
1990   4                      break;
1991   4                  }
1992   3                  default:            // no break
1993   3                  case (PAGE_MAIN) :
1994   3                  {
1995   4                      roomTemp1 = readOneByteFromSlave(ROOM_TEMP_1);
1996   4      
1997   4                      if (state_changed) {
1998   5                          state_changed = 0;
1999   5                          sprintf(str, "%-3buC", roomTemp1);
2000   5                          display_text("000000", "FFFFFF", 8, str, 240, 110);
2001   5                      }
2002   4                      
2003   4                      if (tsCommandReceived || roomTemp1 != prev_temp) 
2004   4                      {
2005   5                          prev_temp = roomTemp1;
2006   5                          
2007   5                          if ('1' == userCommand[1] && '2' == userCommand[2] && '9' == userCommand[3]) {
2008   6                              display_celsius = 1;
C51 COMPILER V9.56.0.0   MAIN                                                              11/25/2017 12:12:32 PAGE 35  

2009   6                              sprintf(str, "%-3buC", roomTemp1);
2010   6                              display_text("000000", "FFFFFF", 8, str, 240, 110);
2011   6                          }
2012   5                          else if ('1' == userCommand[1] && '3' == userCommand[2] && '0' == userCommand[3]) {
2013   6                              display_celsius = 0;
2014   6                              roomTemp1 = (roomTemp1 * 9) / 5 + 32;
2015   6                              sprintf(str, "%-3buF", roomTemp1);
2016   6                              display_text("000000", "FFFFFF", 8, str, 240, 110);
2017   6                          }
2018   5                          else if ('1' == userCommand[1] && '3' == userCommand[2] && '1' == userCommand[3]) {
2019   6                              change_state(PAGE_SETTINGS);
2020   6                          }
2021   5                          else if ('1' == userCommand[1] && '2' == userCommand[2] && '8' == userCommand[3]) {
2022   6                              change_state(PAGE_MAIN);
2023   6                          }
2024   5                          else if ('1' == userCommand[1] && '3' == userCommand[2] && '2' == userCommand[3]) {
2025   6                              change_state(PAGE_SERVICE);
2026   6                          }
2027   5                          else {
2028   6                              // Noop
2029   6                          }
2030   5                      }
2031   4                      break;
2032   4                  }
2033   3              }
2034   2          }
2035   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   7044    ----
   CONSTANT SIZE    =    603    ----
   XDATA SIZE       =   3507     912
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =     20       1
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)

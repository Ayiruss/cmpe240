C51 COMPILER V9.56.0.0   MAIN                                                              11/25/2017 11:54:57 PAGE 1   


C51 COMPILER V9.56.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE main.c LARGE OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listing
                    -s\main.lst) OBJECT(.\Objects\main.obj)

line level    source

   1          #include <main.h>
   2          
   3          //-------------------------------------------------------------------------------------------------------
   4          // Global Declarations
   5          //-------------------------------------------------------------------------------------------------------
   6          unsigned char tsByte;
   7          
   8          bit splashEnd = 0;
   9          bit screenReset = 0;
  10          bit ackFromScreen = 0;
  11          bit tsCommandReceived = 0;
  12          bit tsCommandTransmitted = 0;
  13          bit SMB_RW;                                                                                     // Software flag to indicate Read or Writ
             -e
  14          
  15          unsigned char sharedDataRx[SHARED_DATA_MAX];
  16          unsigned char sharedDataTx[SHARED_DATA_MAX];
  17          unsigned char eepromTx[EEPROM_TX_BUFFER];
  18          unsigned char eepromRx[EEPROM_RX_BUFFER];
  19          unsigned char eepromPageTx[EEPROM_PAGE_SIZE];
  20          
  21          unsigned int pageCount;
  22          unsigned int bytesExtra;
  23          unsigned int eepromPageCounter;
  24          unsigned int startAddr;
  25          unsigned char slaveAddr;                                                                        // Target SMBus slave address
  26          unsigned char eepromDataByte;
  27          
  28          unsigned int numBytesRD;
  29          unsigned int numBytesWR;
  30          unsigned char slaveWriteDone;
  31          unsigned char slaveReadDone;
  32          unsigned char eepromWriteDone;
  33          unsigned char eepromReaddone;
  34          unsigned char rtcWriteDone;
  35          unsigned char rtcReadDone;
  36          
  37          unsigned char tsRxBuffer[RX_BUFFER_SIZE];
  38          unsigned char tsTxBuffer[TX_BUFFER_SIZE];
  39          unsigned char userCommand[RX_BUFFER_SIZE];
  40          
  41          unsigned int tsRxIn;
  42          unsigned int tsRxOut; 
  43          unsigned int tsTxIn;
  44          unsigned int tsTxOut;
  45          
  46          bit tsRxEmpty;
  47          bit tsTxEmpty;
  48          bit tsLastCharGone;     
  49          
  50          bit screenChanged;
  51          unsigned char screen;
  52          unsigned char lastScreen;
  53          
C51 COMPILER V9.56.0.0   MAIN                                                              11/25/2017 11:54:57 PAGE 2   

  54          const char code * Font[] = {/*0*/       "m10B", 
  55                                                                  /*1*/   "m12B",
  56                                                                  /*2*/   "m14B",
  57                                                                  /*3*/   "m16B",
  58                                                                  /*4*/   "m20B",
  59                                                                  /*5*/   "m24B",
  60                                                                  /*6*/   "m32B",
  61                                                                  /*7*/   "m48",
  62                                                                  /*8*/   "m64"};
  63          
  64          bit SMB_BUSY = 0;                                                                               // Set to claim the bus, clear to free
  65          bit SMB_RW;                                                                     // Software flag to indica
             -te Read or Write
  66          
  67          unsigned int startAddr;
  68          unsigned char slaveAddr;                                                                        // Target SMBus slave address
  69          
  70          unsigned int numBytesRD;
  71          unsigned int numBytesWR;
  72          
  73          unsigned char slaveWriteDone;
  74          unsigned char slaveReadDone;
  75                                      
  76          unsigned char roomTemp1;
  77          unsigned char roomTemp2;
  78          unsigned char roomTemp3;
  79                                      
  80          unsigned char seconds;
  81          unsigned char minutes;
  82          unsigned char hours;
  83          unsigned char hours24;
  84          unsigned char amPm;
  85          unsigned char day;
  86          unsigned char date;
  87          unsigned char month;
  88          unsigned char year;
  89          unsigned char century;
  90          unsigned char timeMode;
  91          unsigned char currentIndex = 0;
  92          unsigned char minuteIndex = 0;
  93          unsigned char hourIndex = 0;
  94          
  95          unsigned char currentDate;
  96          unsigned char currentMonth;
  97          unsigned char currentYear;
  98          
  99          unsigned char realTimeClockItems;
 100          
 101          unsigned char adjustedSeconds;
 102          unsigned char adjustedMinutes;
 103          unsigned char adjustedHours;
 104          unsigned char adjustedAmPm;
 105          unsigned char adjustedDay;
 106          unsigned char adjustedDate;
 107          unsigned char adjustedMonth;
 108          unsigned char adjustedYear;
 109          unsigned char adjustedCentury;
 110          unsigned char adjustedTimeMode;
 111          
 112          bit monthUpdated;
 113          bit dateUpdated;
 114          bit yearUpdated;
C51 COMPILER V9.56.0.0   MAIN                                                              11/25/2017 11:54:57 PAGE 3   

 115          bit hoursUpdated;
 116          bit minutesUpdated;
 117          bit secondsUpdated;
 118          bit amPmUpdated;
 119          bit timeUpdated;
 120          bit monthDateYearUpdated;
 121          
 122          const char code * dayOfWeek[] =         {/*0*/  "NON",
 123                                                                                   /*1*/  "SUN",
 124                                                                                   /*2*/  "MON", 
 125                                                                                   /*3*/  "TUE",
 126                                                                                   /*4*/  "WED", 
 127                                                                                   /*5*/  "THU",
 128                                                                                   /*6*/  "FRI", 
 129                                                                                   /*7*/  "SAT"}; 
 130          
 131          const char code * monthOfYear[] =       {/*0*/  "NON",
 132                                                                                   /*1*/  "JAN",
 133                                                                                   /*2*/  "FEB", 
 134                                                                                   /*3*/  "MAR",
 135                                                                                   /*4*/  "APR", 
 136                                                                                   /*5*/  "MAY",
 137                                                                                   /*6*/  "JUN", 
 138                                                                                   /*7*/  "JUL",
 139                                                                                   /*8*/  "AUG",
 140                                                                                   /*9*/  "SEP",
 141                                                                                   /*10*/ "OCT", 
 142                                                                                   /*11*/ "NOV",
 143                                                                                   /*12*/ "DEC"};
 144          
 145          const char code * clockSetupMsg[] = {/*0*/      "SET DATE AND TIME      ",
 146                                                                                  /*1*/   "WRITING DATA... WAIT!  ",
 147                                                                                  /*2*/   "DATA SUCCESSFULLY SAVED",
 148                                                                                  /*3*/   "ERROR                  "};
 149          
 150          //-------------------------------------------------------------------------------------------------------
 151          // System Configurations
 152          //-------------------------------------------------------------------------------------------------------
 153          void systemClockInit(void)
 154          {
 155   1          char SFRPAGE_SAVE = SFRPAGE;                                                                                        // Save Current SFR page
 156   1              int i = 0;
 157   1          
 158   1              SFRPAGE  = CONFIG_PAGE;
 159   1              
 160   1          OSCICN    = 0x83;
 161   1      
 162   1              SFRPAGE = SFRPAGE_SAVE;                                                                                         // Restore SFRPAGE
 163   1      }
 164          
 165          void portInit(void)
 166          {
 167   1              char SFRPAGE_SAVE = SFRPAGE;                                                            // Save Current SFR page
 168   1      
 169   1              SFRPAGE = CONFIG_PAGE;                                                                  // Set SFR page
 170   1      
 171   1              XBR0 = 0x2F;                                                                                                                            // Enable UART0, UART1, SPI0, SMB, CEX0 - CEX4                                                                                                                                                  
 172   1              XBR1 = 0x01;                                                                            
 173   1          XBR2 = 0xC4;                                                                                                                                // Enable crossbar and disable weak pull-up                                                                                             
 174   1          
 175   1              P0MDOUT = 0x01;                                                                                 // Set TX0 pin to push-pull
 176   1                                                                                                                                                                      // TX0 = P0.0; RX0 = P0.1
C51 COMPILER V9.56.0.0   MAIN                                                              11/25/2017 11:54:57 PAGE 4   

 177   1              P1MDOUT = 0x01;                                                                                                                         // Set TX1 pin to push-pull, P1.0
 178   1                                                                                                                                                                      // TX1 = P1.0; RX1 = P1.1
 179   1              P3MDOUT = 0xCA;                                                                                                                         // P3.0, P3.2, P3.4, P3.5: open drain; P3.1, P3.3, P3.6, P3.7: push pull
 180   1              
 181   1              P4MDOUT = 0x0F;                                                                                                                         // P4.0, P4.1, P4.2, P4.3: push pull
 182   1                                                                                                                                                                      
 183   1              P5MDOUT = 0x04;                                                                                                                         // P5.0 open drain; P5.1 Open drain; P5.2 Push pull
 184   1              
 185   1              P6MDOUT = 0x00;
 186   1                                                                                                                                                                                                                                                                                                                              
 187   1              P7MDOUT = 0x80;                                                                                                                         // Set P7.7 push-pull (smb error line)
 188   1              
 189   1              P0 = 0xFF;                                                                                                                                      // Initialize port P0 latch
 190   1              P1 = 0xFF;                                                                                                                                      // Initialize port P1 latch
 191   1              P2 = 0xFF;                                                                                                                                      // Initialize port P2 latch
 192   1              P3 = 0xFF;                                                                                                                                      // Initialize port P3 latch
 193   1              P4 = 0xFF;                                                                                                                                      // Initialize port P4 latch
 194   1              P5 = 0xFF;                                                                                                                                      // Initialize port P5 latch
 195   1              P6 = 0xFF;                                                                                                                                      // Initialize port P6 latch
 196   1              P7 = 0xFF;                                                                                                                                      // Initialize port P7 latch
 197   1      
 198   1              RHW = 0;                                                                                                                                        // Pull low SMB error line
 199   1      
 200   1          SFRPAGE = SFRPAGE_SAVE;                                                                     // Restore SFR page
 201   1      }
 202          
 203          void enableInterrupts(void)
 204          {
 205   1              IE = 0x92;                                                                                                                                      // Enable all interrupts + UART0 + Timer 0
 206   1              EIE2 |= 0x01;                                                                                   // Enable Timer 3 interrupt
 207   1              EIE2 |= 0x40;                                                                                                                           // Enable UART1 interrupt
 208   1              EIE1 |= 0x0A;                                                                                                                           // Enable SMBus interrupt
 209   1      }
 210          
 211          void uart0Init(void)
 212          {
 213   1         char SFRPAGE_SAVE;
 214   1      
 215   1         SFRPAGE_SAVE = SFRPAGE;                                                                      // Preserve SFRPAGE
 216   1      
 217   1         SFRPAGE = TMR2_PAGE;
 218   1         TMR2CN = 0x00;                                                                               // Stop timer. Timer 2 in 16-bit auto-
             -reload up timer mode
 219   1         TMR2CF = 0x08;                                                                               // SYSCLK is time base; no output; up 
             -count only
 220   1         RCAP2L = 0xF3;                                                               // Low byte
 221   1         RCAP2H = 0xFF;                                                               // High byte
 222   1         TMR2 = RCAP2;                                                                // Load 16 bit reload valu
             -e into timer 2
 223   1         TMR2CN = 0x04;                                                               // Enable timer 2 (Start t
             -imer 2)
 224   1      
 225   1         SFRPAGE = UART0_PAGE;
 226   1         SCON0 = 0x50;                                                                                // 8-bit variable baud rate; 9th bit i
             -gnored; RX enabled
 227   1         SSTA0 = 0x05;                                                                                // Enable baud rate                   
             -                                                                      
 228   1                                                                                                      // Use timer 2 as RX and TX baud rate 
             -source
 229   1         IE = 0x90;                                                                   // Enable all interrupts a
             -nd UART0 Interrupt
 230   1      
C51 COMPILER V9.56.0.0   MAIN                                                              11/25/2017 11:54:57 PAGE 5   

 231   1         SFRPAGE = SFRPAGE_SAVE;                                                                      // Restore SFRPAGE
 232   1      }
 233          
 234          void disableWatchdog(void)
 235          {
 236   1              WDTCN = 0xDE;                                                                                           // Disable watchdog timer
 237   1          WDTCN = 0xAD;
 238   1      }
 239          
 240          void uart0Interrupt(void) interrupt INTERRUPT_UART_0 using 2
 241          {
 242   1              char SFRPAGE_SAVE = SFRPAGE;
 243   1              unsigned int i = 0;
 244   1              unsigned long txWaitCounter = 0;
 245   1      
 246   1              SFRPAGE = UART0_PAGE;
 247   1      
 248   1              if(RI0 == 1)                                                                                    // There is a char in SBUF
 249   1              {
 250   2              RI0 = 0;                                                                                        // Clear interrupt flag
 251   2      
 252   2              tsByte = SBUF0;                                                                         // Read a character from UART
 253   2      
 254   2              if(tsRxIn < RX_BUFFER_SIZE)                                                                                             // If buffer size is within limit
 255   2              {
 256   3                      if(tsByte != '\r')                                                                                                      // Check end of a command from touch screen
 257   3                              {
 258   4                                      tsRxBuffer[tsRxIn] = tsByte;                                                                    // Store a character in software buffer
 259   4                                      tsRxIn++;                                                                                                               // Increment index
 260   4                              }
 261   3                      else                                                                                                                            // If it is CR character, it marks end of command
 262   3                              {                                                                                                                               
 263   4                                      if(tsRxBuffer[0] == '{')                                        // Splash screen indicator
 264   4                                      {
 265   5                                              if(tsRxBuffer[1] == 'c' && tsRxBuffer[2] == 'm' && tsRxBuffer[3] == 'p' && tsRxBuffer[4] == 'e' && ts
             -RxBuffer[5] == '}')
 266   5                                              {
 267   6                                                      splashEnd = 1;                                          // Detect end of splash screen
 268   6                                                      screenReset = 1;                                                                                // Screen was reset, so touch screen sends {babe\r}
 269   6                                              }
 270   5                                              else
 271   5                                              {
 272   6                                                      splashEnd = 0;                                          // End of splash screen NOT detected
 273   6                                                      screenReset = 0;                                                                        
 274   6                                              }
 275   5                                      }
 276   4                                      else if(tsRxBuffer[0] == '(')                                                                   // It is a command from touch screen controller
 277   4                                      {                                                                                                                               // A command starts with '('
 278   5                                              for(i = 0; i < tsRxIn; i++)
 279   5                                              {
 280   6                                                      userCommand[i] = tsRxBuffer[i];                                                 // Copy to command array for later evaluation
 281   6                                              }
 282   5      
 283   5                                              ackFromScreen = 0;                                                                                      // This is a command, NOT an ACK
 284   5                                              tsCommandReceived = 1;                                                                          // Set flag when a complete command is received
 285   5                                      }
 286   4                                      else                                                                                                                    // Not a command from touch screen controller
 287   4                                      {
 288   5                                              ackFromScreen = 1;                                                                                      // Set a flag to indicate it is an ACK from screen
 289   5                                              tsCommandReceived = 0;                                                                          // No need to set flag because it is not a command
 290   5                                      }
 291   4      
C51 COMPILER V9.56.0.0   MAIN                                                              11/25/2017 11:54:57 PAGE 6   

 292   4                                      for(i = 0; i < tsRxIn; i++)
 293   4                                      {
 294   5                                              tsRxBuffer[i] = '\0';                                                                           // Delete all contents
 295   5                                      }
 296   4                                      
 297   4                                      tsRxOut = 0;                                                                                                    // Reset index Out
 298   4                                      tsRxIn = 0;                                                                                                             // Reset index In
 299   4                              }       
 300   3              }
 301   2                      else                                                                                                                                    // Reset all indexes
 302   2                      {       
 303   3                              while(tsRxOut < tsRxIn)
 304   3                              {
 305   4                                      tsRxBuffer[tsRxOut] = '\0';
 306   4                                      tsRxOut++;
 307   4                              }
 308   3                              tsRxOut = 0;
 309   3                              tsRxIn = 0;
 310   3                              tsCommandReceived = 0;
 311   3                      }
 312   2         }
 313   1      
 314   1         if(TI0 == 1)                                                                                                 // Check if one character is successfully sent out
 315   1         {
 316   2              TI0 = 0;                                                                                        // Clear interrupt flag
 317   2      
 318   2                      if(tsTxEmpty == 0)                                                                                                              // TX buffer has something to send
 319   2                      {
 320   3                              SBUF0 = tsTxBuffer[tsTxOut];                                                                            // Send a character in TX buffer
 321   3                              tsTxOut++;                                                                                                                      // Move to next character
 322   3      
 323   3                              while(TI0 == 0 && txWaitCounter++ < TX_WAIT_LIMIT);                                     // Wait until completion of transmission TI0 = 
             -1
 324   3                              if(txWaitCounter >= TX_WAIT_LIMIT)
 325   3                              {
 326   4                                      TI0 = 1;                                                                                                                // TI0 is not set by hardware, set it by software
 327   4                              }                                                                                                                                       // When TI0 is set to 1, this ISR is executed again
 328   3                              
 329   3                              txWaitCounter = 0;                                                                                                      // Reset counter for next execution     
 330   3      
 331   3                              if(tsTxOut >= TX_BUFFER_SIZE)
 332   3                              {
 333   4                                      tsTxOut = 0;                                                                                                    // Reset index to 0
 334   4                              }                                                               
 335   3      
 336   3                              if(tsTxOut == tsTxIn)                                                                                           // If two indexes are equal
 337   3                              {
 338   4                                      tsTxEmpty = 1;                                                                                                  // No more character in buffer. Empty
 339   4                              }
 340   3                      }
 341   2                      else
 342   2                      {
 343   3                              tsLastCharGone = 1;                                                                                                     // Last character has gone. Buffer is empty
 344   3                      }
 345   2              }
 346   1              
 347   1              SFRPAGE = SFRPAGE_SAVE;                                                                         // Restore SFR page detector
 348   1      }
 349          
 350          //-------------------------------------------------------------------------------------------------------
 351          // Function Name: sendCommand
 352          // Return Value: None 
C51 COMPILER V9.56.0.0   MAIN                                                              11/25/2017 11:54:57 PAGE 7   

 353          // Parmeters: s (a string to send)
 354          // Function Description: This function sends a command from the touch screen
 355          //-------------------------------------------------------------------------------------------------------
 356          void sendCommand(const char * s)
 357          {       
 358   1              char SFRPAGE_SAVE = SFRPAGE;
 359   1              
 360   1              while(*s != '\0')                                                                                                                       // Search for end of touch screen command in buffer
 361   1          {
 362   2              if(tsTxEmpty == 1 || (tsTxOut != tsTxIn))                                                               // Tx is empty or two indexes are not equal
 363   2                      {
 364   3                              tsTxBuffer[tsTxIn++] = *s;
 365   3                              if(tsTxIn >= TX_BUFFER_SIZE)                                                                            // Check for limit
 366   3                              {
 367   4                                      tsTxIn = 0;                                                                                                             // Reset if limit reached
 368   4                              }
 369   3      
 370   3                              if(tsTxEmpty == 1)                                                                                                      // If buffer is empty
 371   3                              {
 372   4                                      tsTxEmpty = 0;                                                                                                  // Now buffer has at leat 1 character, set flag
 373   4                              }
 374   3                      }
 375   2              
 376   2                      s++;                                                                                                                                    // Point to next char to send out
 377   2          }
 378   1                                                                                                                                                                      
 379   1              if(tsLastCharGone == 1)                                                                                                         // All characters in buffer has sent out
 380   1              {
 381   2                      tsLastCharGone = 0;                                                                                                             // Reset flag to indicate no char left in buffer
 382   2                      SFRPAGE = UART0_PAGE;                                                                                                                                                   
 383   2                      TI0 = 1;                                                                        // Set this flage to call ISR to send 
             -out one character
 384   2              }                                                                                                                                                       
 385   1                                                                                                                                                                      
 386   1              SFRPAGE = SFRPAGE_SAVE;                                                                 // Restore SFRPAGE
 387   1      }
 388          
 389          //-------------------------------------------------------------------------------------------------------
 390          // Function Name: displayText
 391          // Return Value: None 
 392          // Parmeters: fg, bg, size, message, x, y
 393          // Function Description: This function displays a text on the touch screen
 394          //-------------------------------------------------------------------------------------------------------
 395          void displayText(const char* fg, const char* bg, const unsigned char size, const char* message, const unsi
             -gned int x, const unsigned int y)
 396          {
 397   1              char str[TS_BUFFER_SIZE];                                                                                                       // String
 398   1                      
 399   1              sprintf(str, "S %s %s\r", fg, bg);                                                                                      // Set forground and background color
 400   1              sendCommand(str);                                                                                                               
 401   1              sprintf(str, "f %s\r", Font[size]);                                                                                     // Set text font
 402   1              sendCommand(str);                                                                                                               
 403   1              sprintf(str, "t \"%s\" %u %u\r", message, x, y);                                                        // Display text
 404   1              sendCommand(str);                                                                                                               
 405   1      }
 406          
 407          //-------------------------------------------------------------------------------------------------------
 408          // Function Name: showBitmap
 409          // Return Value: None 
 410          // Parmeters: index, x, y (bitmap index and coordinates)
 411          // Function Description: This function displays a bitmap image
 412          //-------------------------------------------------------------------------------------------------------
C51 COMPILER V9.56.0.0   MAIN                                                              11/25/2017 11:54:57 PAGE 8   

 413          void showBitmap(const unsigned int index, const unsigned int x, const unsigned int y)
 414          {
 415   1              char str[TS_BUFFER_SIZE];
 416   1      
 417   1              sprintf(str, "xi %u %u %u\r", index, x, y);                                                                     // Bitmap index
 418   1              sendCommand(str);
 419   1      }
 420          
 421          //-------------------------------------------------------------------------------------------------------
 422          // Function Name: changeScreen
 423          // Return Value: None 
 424          // Parmeters: screenIndex (macro number)
 425          // Function Description: This function switches to the new screen
 426          //-------------------------------------------------------------------------------------------------------
 427          void changeScreen(const unsigned char screenIndex)
 428          {
 429   1              callMacro(screenIndex);                                                                                                         // Change screen                
 430   1      }
 431          
 432          //-------------------------------------------------------------------------------------------------------
 433          // Function Name: callMacro
 434          // Return Value: None 
 435          // Parmeters: macroNumber (macro number in the macro file)
 436          // Function Description: This function calls a macro
 437          //-------------------------------------------------------------------------------------------------------
 438          void callMacro(const unsigned int macroNumber)
 439          {
 440   1              char str[TS_BUFFER_SIZE];
 441   1      
 442   1              sprintf(str, "m %u\r", macroNumber);                                                                            // Execute macro number
 443   1              sendCommand(str);
 444   1      }
 445          
 446          //-------------------------------------------------------------------------------------------------------
 447          // Function Name: scanUserInput
 448          // Return Value: None 
 449          // Parmeters: None
 450          // Function Description: This function processes commands from the touch screen
 451          //-------------------------------------------------------------------------------------------------------
 452          void scanUserInput(void)
 453          {       
 454   1              int i = 0;
 455   1      
 456   1              if(screen == MAIN_PAGE)                                                                                                         // Main screen
 457   1              {                
 458   2                      if(userCommand[0] == '(')                                                                                               // Check for an actual command followed by this '(' character
 459   2                      {
 460   3                              switch (userCommand[1])                                                                                         // Scan a command type
 461   3                              {
 462   4                                      case '1':                                                                                                               // Main page
 463   4                                              changeScreen(MAIN_PAGE);                                                                        // Stay in main page if main button is pressed again
 464   4                                              break;
 465   4                                      case '2':                                                                                                               // Settings page
 466   4                                              changeScreen(SETTINGS_PAGE);
 467   4                                              break;
 468   4                                      case '3':                                                                                                               // Service page
 469   4                                              changeScreen(SERVICE_PAGE);
 470   4                                              break;
 471   4                                      case 'A':
 472   4                                              // Call a function here or do something here                    
 473   4                                              break;
 474   4                                      case 'B':
C51 COMPILER V9.56.0.0   MAIN                                                              11/25/2017 11:54:57 PAGE 9   

 475   4                                              // Call a function here or do something here
 476   4                                              break;
 477   4                                      case 'C':
 478   4                                              // Call a function here or do something here
 479   4                                              break;  
 480   4                                      default:                                                                                                                // Other options
 481   4                                              break;
 482   4                                      }
 483   3                      }
 484   2                      else                                                                                                                                    // Not a command, empty buffer with null char
 485   2                      {
 486   3                              i = 0;
 487   3                              while(userCommand[i] != '\0')
 488   3                              {
 489   4                                      userCommand[i] = '\0';
 490   4                                      i++;
 491   4                              }
 492   3                      }       
 493   2              }
 494   1              else if(screen == SETTINGS_PAGE)                                                                                        // Settings page
 495   1              {
 496   2                      if(userCommand[0] == '(')
 497   2                      {
 498   3                              switch (userCommand[1])
 499   3                              {
 500   4                                      case '1':
 501   4                                              changeScreen(MAIN_PAGE);
 502   4                                              break;
 503   4                                      case '2':
 504   4                                              changeScreen(SETTINGS_PAGE);
 505   4                                              break;
 506   4                                      case '3':
 507   4                                              changeScreen(SERVICE_PAGE);
 508   4                                              break;
 509   4                                      case 'A':
 510   4                                              // Call a function here or do something here
 511   4                                              break;
 512   4                                      case 'B':
 513   4                                              // Call a function here or do something here
 514   4                                              break;
 515   4                                      case 'C':
 516   4                                              // Call a function here or do something here
 517   4                                              break;
 518   4                                      default:
 519   4                                              break;
 520   4                              }
 521   3                      }
 522   2                      else                                                                                                                                    // Not a command, empty buffer with null
 523   2                      {
 524   3                              i = 0;
 525   3                              while(userCommand[i] != '\0')
 526   3                              {
 527   4                                      userCommand[i] = '\0';
 528   4                                      i++;
 529   4                              }
 530   3                      }                               
 531   2              }
 532   1              else if(screen == SERVICE_PAGE)
 533   1              {
 534   2                      if(userCommand[0] == '(')
 535   2                      {
 536   3                              switch (userCommand[1])
C51 COMPILER V9.56.0.0   MAIN                                                              11/25/2017 11:54:57 PAGE 10  

 537   3                              {
 538   4                                      case '1':
 539   4                                              changeScreen(MAIN_PAGE);
 540   4                                              break;
 541   4                                      case '2':
 542   4                                              changeScreen(SETTINGS_PAGE);
 543   4                                              break;
 544   4                                      case '3':
 545   4                                              changeScreen(SERVICE_PAGE);
 546   4                                              break;
 547   4                                      case 'A':
 548   4                                              // Call a function here or do something here
 549   4                                      case 'B':
 550   4                                              // Call a function here or do something here
 551   4                                      case 'C':
 552   4                                              // Call a function here or do something here
 553   4                                      default:
 554   4                                              break;
 555   4                              }
 556   3                      }
 557   2                      else                                                                                                                                    // Not a command, empty buffer with null
 558   2                      {                                                                                                                       
 559   3                              i = 0;
 560   3                              while(userCommand[i] != '\0')
 561   3                              {
 562   4                                      userCommand[i] = '\0';
 563   4                                      i++;
 564   4                              }
 565   3                      }                               
 566   2              }       
 567   1              else
 568   1              {
 569   2      
 570   2              }
 571   1      
 572   1              i = 0;
 573   1              while(userCommand[i] != '\0')
 574   1              {
 575   2                      userCommand[i] = '\0';                                                                                                  // Delete all contents in array
 576   2                      i++;
 577   2              }
 578   1      }
 579          
 580          //-------------------------------------------------------------------------------------------------------
 581          // Function Name: smbInit
 582          // Return Value: None 
 583          // Parmeters: None
 584          // Function Description: This function initializes the SMB bus 
 585          //-------------------------------------------------------------------------------------------------------
 586          void smbInit(void)
 587          {
 588   1              int i;
 589   1              unsigned long pollingCounter = 0;
 590   1              char SFRPAGE_SAVE = SFRPAGE;
 591   1      
 592   1              SFRPAGE = SMB0_PAGE;
 593   1              while(SDA == 0 && pollingCounter++ < SMB_POLLING_LIMIT)                                                 // If slave is holding SDA low because of e
             -rror or reset
 594   1              {
 595   2              SCL = 0;                                                                                        // Drive the clock low
 596   2              for(i = 0; i < 255; i++);                                                                       // Hold the clock low
 597   2              SCL = 1;                                                                                        // Release the clock
C51 COMPILER V9.56.0.0   MAIN                                                              11/25/2017 11:54:57 PAGE 11  

 598   2              while(SCL == 0 && pollingCounter++ < SMB_POLLING_LIMIT);                                        // Wait for open-drain
 599   2              for(i = 0; i < 10; i++);                                                                        // Hold the clock high
 600   2              }
 601   1                              
 602   1              SMB0CN = 0x07;                                                                                          // Assert Acknowledge low (AA bit = 1b);
 603   1                                                                                                              // Enable SMBus Free timeout detect;
 604   1              SMB0CR = 267 - (SYSTEM_CLOCK / (8 * SMB_FREQUENCY));                                                    // Derived approximation from the Tlow and Thi
             -gh equations
 605   1                                                                                                                                              
 606   1              SMB0CN |= 0x40;                                                                                         // Enable SMBus;
 607   1      
 608   1              SFRPAGE = SFRPAGE_SAVE;                                                                                 // Restore SFR page detector
 609   1              
 610   1              SMB_BUSY = 0;
 611   1                                                                                          // Release SMB
 612   1          slaveWriteDone = FALSE;
 613   1              slaveReadDone = FALSE;
 614   1              eepromWriteDone = FALSE;
 615   1              eepromReadDone = FALSE;
 616   1              rtcWriteDone = FALSE;
 617   1              rtcReadDone = FALSE;
 618   1      }
 619          
 620          //-------------------------------------------------------------------------------------------------------
 621          // Function Name: timer3Init
 622          // Return Value: None 
 623          // Parmeters: None
 624          // Function Description: This function nitializes timer 3 which is used to time out the SMB if errors occu
             -r
 625          //-------------------------------------------------------------------------------------------------------
 626          void timer3Init (void)
 627          {
 628   1              char SFRPAGE_SAVE = SFRPAGE;        
 629   1      
 630   1              SFRPAGE = TMR3_PAGE;
 631   1      
 632   1              TMR3CN = 0x00;                                                                                          // Timer 3 in timer mode
 633   1                                                                                                                                                                              // Timer 3 auto reload
 634   1              TMR3CF = 0x00;                                                                                          // Timer 3 prescaler = 12
 635   1      
 636   1              RCAP3 = -(SYSTEM_CLOCK / 12 / 40);                                                              // Timer 3 overflows after 25 ms
 637   1              TMR3 = RCAP3;                                                                                   
 638   1      
 639   1              TR3 = 1;                                                                                                // Start Timer 3
 640   1      
 641   1              SFRPAGE = SFRPAGE_SAVE;                                                                                 // Restore SFR page
 642   1      }
 643          
 644          //-------------------------------------------------------------------------------------------------------
 645          // Function Name: timer3ISR
 646          // Return Value: None 
 647          // Parmeters: None
 648          // Function Description: This function is timer 3 ISR which is used to reset the SMB bus if the clock line
             - is held for too long
 649          //-------------------------------------------------------------------------------------------------------
 650          void timer3ISR(void) interrupt INTERRUPT_Timer_3
 651          {
 652   1              char SFRPAGE_SAVE = SFRPAGE;                                                                            // Save Current SFR page
 653   1      
 654   1              SFRPAGE = SMB0_PAGE;
 655   1              SMB0CN &= ~0x40;                                                                                        // Disable SMBus
 656   1              SMB0CN |= 0x40;                                                                                         // Re-enable SMBus
C51 COMPILER V9.56.0.0   MAIN                                                              11/25/2017 11:54:57 PAGE 12  

 657   1      
 658   1              SFRPAGE = SFRPAGE_SAVE;                                                                                 // Switch back to the Timer3 SFRPAGE
 659   1              TF3 = 0;                                                                                                // Clear Timer3 interrupt-pending flag
 660   1              SMB_BUSY = 0;                                                                                           // Free bus
 661   1         
 662   1              SFRPAGE = SFRPAGE_SAVE;                                                                                 // Restore SFR page detector
 663   1      }
 664          
 665          //-------------------------------------------------------------------------------------------------------
 666          // Function Name: writeOneByteToSlave
 667          // Return Value: None 
 668          // Parmeters: target, startAddr, content
 669          // Function Description: This function writes one to the slave microprocessor
 670          //-------------------------------------------------------------------------------------------------------
 671          void writeOneByteToSlave(unsigned char startAddr, unsigned char content)
 672          {               
 673   1              sharedDataTx[startAddr] = content;
 674   1              smbWrite(MCU_SLAVE_ADDR, startAddr, 1);
 675   1      }
 676          
 677          //-------------------------------------------------------------------------------------------------------
 678          // Function Name: readOneByteFromSlave
 679          // Return Value: long 
 680          // Parmeters: startAddr, bytes
 681          // Function Description: This function reads one from the slave microprocessor
 682          //-------------------------------------------------------------------------------------------------------
 683          unsigned char readOneByteFromSlave(unsigned char startAddr)
 684          {
 685   1              smbRead(MCU_SLAVE_ADDR, startAddr, 1);
 686   1              return sharedDataRx[startAddr];                                                                                                                                                                                         
 687   1      }
 688          
 689          //-------------------------------------------------------------------------------------------------------
 690          // Function Name: writeBytesToRealTimeClock
 691          // Return Value: None 
 692          // Parmeters: target, startAddr, bytes
 693          // Function Description: This function writes data byte to the real time clock DS3232
 694          //-------------------------------------------------------------------------------------------------------
 695          void writeBytesToRealTimeClock(unsigned char startAddr, unsigned char numBytes)
 696          {
 697   1              smbWrite(REAL_TIME_CLOCK_ADDR, startAddr, numBytes);
 698   1      }
 699          
 700          //-------------------------------------------------------------------------------------------------------
 701          // Function Name: readBytesFromRealTimeClock
 702          // Return Value: None 
 703          // Parmeters: target, startAddr, bytes
 704          // Function Description: This function reads data byte from the real time clock DS3232
 705          //-------------------------------------------------------------------------------------------------------
 706          void readBytesFromRealTimeClock(unsigned char startAddr, unsigned char numBytes)
 707          {
 708   1              smbRead(REAL_TIME_CLOCK_ADDR, startAddr, numBytes);
 709   1      }
 710          
 711          //-------------------------------------------------------------------------------------------------------
 712          // Function Name: smbRead
 713          // Return Value: unsigned char * 
 714          // Parmeters: target, startAddr, bytes
 715          // Function Description: This function reads from SM bus
 716          //-------------------------------------------------------------------------------------------------------
 717          void smbRead(unsigned char deviceId, unsigned int location, unsigned int bytes)
 718          {
C51 COMPILER V9.56.0.0   MAIN                                                              11/25/2017 11:54:57 PAGE 13  

 719   1              char SFRPAGE_SAVE = SFRPAGE;
 720   1      
 721   1              SFRPAGE = SMB0_PAGE;
 722   1              
 723   1              while(BUSY || SMB_BUSY);                                                                        // Wait for free SMB
 724   1      
 725   1              SFRPAGE = SFRPAGE_SAVE;
 726   1                      
 727   1          switch(deviceId)
 728   1          {
 729   2              case MCU_SLAVE_ADDR:
 730   2              case REAL_TIME_CLOCK_ADDR:
 731   2              case EEPROM_ADDR:
 732   2                  smbWrite(deviceId, location, 0);                                                                        // Write address before reading
 733   2                  break;
 734   2              default:
 735   2                  break;      
 736   2          }
 737   1      
 738   1          SFRPAGE = SMB0_PAGE;
 739   1                      
 740   1          while(BUSY || SMB_BUSY);
 741   1          slaveAddr = deviceId;                                                                       // Address of MCU slave
 742   1          startAddr = location;                                                                                                               // Starting address to read from slave
 743   1          numBytesRD = bytes;                                                                                                                 // Number of bytes to read
 744   1          
 745   1          SMB_BUSY = 1;                                                                               // Claim SMBus (set to busy)
 746   1          SMB_RW = 1;                                                                                 // Mark this transfer as a READ
 747   1          STA = 1;
 748   1      
 749   1              while(BUSY || SMB_BUSY);                                                                // Wait for SMB
 750   1                      
 751   1              SFRPAGE = SFRPAGE_SAVE;
 752   1                              
 753   1          switch(deviceId)
 754   1          {
 755   2              case MCU_SLAVE_ADDR:
 756   2                  while(slaveReadDone == 0);                                                  // Wait until slave write 
             -completed
 757   2                  break;
 758   2              case REAL_TIME_CLOCK_ADDR:
 759   2                              while(rtcReadDone == 0);                                                        // Wait until real time clock write c
             -ompleted or timeout occurs
 760   2                              break;
 761   2              case EEPROM_ADDR:
 762   2                  while(eepromReadDone == 0);                                                 // Wait until EEPROM writ
             -e completed
 763   2                  break;
 764   2              default:
 765   2                  break;      
 766   2          }    
 767   1      }
 768          
 769          //-------------------------------------------------------------------------------------------------------
 770          // Function Name: smbWrite
 771          // Return Value: unsigned char * 
 772          // Parmeters: target, startAddr, bytes
 773          // Function Description: This function reads to SM bus
 774          //-------------------------------------------------------------------------------------------------------
 775          void smbWrite(unsigned char deviceId, unsigned int location, unsigned int bytes)
 776          {
 777   1              unsigned char i = 0;
C51 COMPILER V9.56.0.0   MAIN                                                              11/25/2017 11:54:57 PAGE 14  

 778   1              unsigned int pageWrittenDelay = 0;
 779   1              char SFRPAGE_SAVE = SFRPAGE;
 780   1                      
 781   1              SFRPAGE = SMB0_PAGE;
 782   1              
 783   1              while(BUSY || SMB_BUSY);                                                                        // Wait for SMB to be free
 784   1          slaveAddr = deviceId;                                                                           // Address of MCU slave board
 785   1          startAddr = location;                                                                                                                   // Starting address to write to slave
 786   1      
 787   1          switch(deviceId)
 788   1          {
 789   2              case MCU_SLAVE_ADDR:                                                                                                        // Pass through
 790   2              case DEVICE_DUMP_ADDR:                                                                                                      // Pass through
 791   2                  numBytesWR = bytes;                                                                                                     // Number of bytes to read
 792   2                  SMB_BUSY = 1;                                                                   // Claim SMBus (set to busy)
 793   2                  SMB_RW = 0;                                                                     // Mark this transfer as a WRIT
             -E
 794   2                  STA = 1;                                                                        // Start transfer
 795   2                  while(slaveWriteDone == 0);                                             // Wait until SRAM wri
             -te completed or timeout occurs
 796   2                  break;
 797   2              case REAL_TIME_CLOCK_ADDR:
 798   2                  numBytesWR = bytes;                                                                                                     // Number of bytes to read
 799   2                  SMB_BUSY = 1;                                                                   // Claim SMBus (set to busy)
 800   2                  SMB_RW = 0;                                                                     // Mark this transfer as a WRIT
             -E
 801   2                  STA = 1;                                                                        // Start transfer
 802   2                  while(rtcWriteDone == 0);                                               // Wait until SRAM write
             - completed or timeout occurs
 803   2                  break;
 804   2              default:
 805   2                  break;              
 806   2              }
 807   1      
 808   1              SFRPAGE = SFRPAGE_SAVE;                                                                                                                 // Restore SFR page
 809   1      }
 810          
 811          //-------------------------------------------------------------------------------------------------------
 812          // Function Name: smbISR
 813          // Return Value: None 
 814          // Parmeters: None
 815          // Function Description: 
 816          // SMBus Interrupt Service Routine (ISR)
 817          // Anytime the SDA is pulled low by the master, this ISR will be called. For example, if STA = 1,
 818          // this ISR is called and SMB0STA = SMB_START = SMB_REPEAT_START. These cases are executed within the swit
             -ch statement.
 819          //-------------------------------------------------------------------------------------------------------
 820          void smbISR (void) interrupt INTERRUPT_SMB using 2
 821          {
 822   1              bit FAIL = 0;                                                                                           // Used by the ISR to flag failed trans
             -fers
 823   1              static unsigned int TxCounter;                                                                                                  // Initialize counter
 824   1              static unsigned int RxCounter;                                                                                                  // Initialize counter
 825   1              static unsigned int slaveCount = 0;
 826   1              static unsigned int realTimeClockCount = 0;
 827   1              static unsigned int eepromCount = 0;
 828   1              static unsigned char eepromAddrDone;
 829   1              
 830   1              switch (SMB0STA >> 3)                                                                                                                   // Check SMB bus status
 831   1              {
 832   2      //-------------------------------------------------------------------------------------------------------
 833   2      // Master Transmitter/Receiver: START condition transmitted. Load SMB0DAT with slave device address
C51 COMPILER V9.56.0.0   MAIN                                                              11/25/2017 11:54:57 PAGE 15  

 834   2      //-------------------------------------------------------------------------------------------------------
 835   2              case SMB_START:                                                                                                                         // Master initiates a transfer
 836   2      
 837   2      //-------------------------------------------------------------------------------------------------------
 838   2      // Master Transmitter/Receiver: repeated START condition transmitted. Load SMB0DAT with slave device addre
             -ss
 839   2      //-------------------------------------------------------------------------------------------------------
 840   2              case SMB_REPEAT_START:
 841   2                              SMB0DAT = slaveAddr;                                                                    // Load address of the slave.
 842   2                      SMB0DAT &= 0xFE;                                                                                // Clear the LSB of the address for the
             - R/W bit
 843   2                      SMB0DAT |= SMB_RW;                                                                              // Load R/W bit (Read = 1; Write = 0)
 844   2                              STA = 0;                                                                                        // Manually clear STA bit
 845   2      
 846   2                      RxCounter = 0;                                                                                  // Reset the counter
 847   2                      TxCounter = 0;                                                                                  // Reset the counter
 848   2                              eepromAddrDone = CLEAR;                                                                                                 // For 2 byte EEPROM address    
 849   2                      
 850   2                              break;
 851   2      
 852   2      //-------------------------------------------------------------------------------------------------------
 853   2      // Master Transmitter: Slave address + WRITE transmitted.  ACK received. For a READ: N/A
 854   2      // For a WRITE: Send the first data byte to the slave
 855   2      //-------------------------------------------------------------------------------------------------------
 856   2              case SMB_ADDR_W_TX_ACK_RX:
 857   2                              if(slaveAddr == MCU_SLAVE_ADDR)
 858   2                              {
 859   3                                      if(startAddr == DEVICE_DUMP_ADDR)                                                                       // Dump device address to check slave presence only
 860   3                                      {
 861   4                                              STO = 1;                                                                                                                // Stop this transfer
 862   4                                              SMB_BUSY = 0;                                                                                                   // Releas SMB
 863   4                                      }
 864   3                                      else
 865   3                                      {
 866   4                                              SMB0DAT = startAddr;                                                                                    // Send 1 byte address to slave
 867   4                                              slaveWriteDone = 0;                                                                                             // Mark start of slave write
 868   4                                      }
 869   3                              }
 870   2                  else if(slaveAddr == REAL_TIME_CLOCK_ADDR)
 871   2                              {
 872   3                                      SMB0DAT = startAddr;                                                                                            // Point to byte address to write on real time clock
 873   3                                      rtcWriteDone = 0;                                                                                                       // Mark start of rtc write
 874   3                              }
 875   2                  else{}
 876   2                      break;
 877   2      
 878   2      //-------------------------------------------------------------------------------------------------------
 879   2      // Master Transmitter: Slave address + WRITE transmitted.  NACK received. Restart the transfer
 880   2      //-------------------------------------------------------------------------------------------------------
 881   2              case SMB_ADDR_W_TX_NACK_RX:
 882   2                              if(slaveAddr == MCU_SLAVE_ADDR)
 883   2                              {
 884   3                                      if(slaveCount < MAX_NACK_RETRY)
 885   3                                      {
 886   4                                              slaveCount++;                                                                                                   // Increment number of attempts when NACK is received
 887   4                                              STA = 1;                                                                                                                // Restart a new transfer
 888   4                                      }
 889   3                                      else
 890   3                                      {
 891   4                                              slaveCount = 0;                                                                                                 // Reset this counter to keep retry seeking slave response
 892   4                                              slaveWriteDone = 1;
 893   4                                              STO = 1;
C51 COMPILER V9.56.0.0   MAIN                                                              11/25/2017 11:54:57 PAGE 16  

 894   4                                              SMB_BUSY = 0;
 895   4                                              FAIL = 1;
 896   4                                      }       
 897   3                              }
 898   2                  else if(slaveAddr == REAL_TIME_CLOCK_ADDR)
 899   2                              {
 900   3                                      if(realTimeClockCount < MAX_NACK_RETRY)
 901   3                                      {
 902   4                                              realTimeClockCount++;                                                                                   // Increment number of attempts when NACK is received
 903   4                                              STA = 1;                                                                                                                // Restart a new transfer
 904   4                                      }
 905   3                                      else
 906   3                                      {
 907   4                                              realTimeClockCount = 0;
 908   4                                              rtcWriteDone = 1;
 909   4                                              STO = 1;
 910   4                                              SMB_BUSY = 0;
 911   4                                              FAIL = 1;
 912   4                                      }       
 913   3                              }
 914   2                              else if(slaveAddr == EEPROM_ADDR)
 915   2                              {
 916   3                                      if(eepromCount < MAX_NACK_RETRY)
 917   3                                      {
 918   4                                              eepromCount++;                                                                                                  // Increment number of attempts when NACK is received
 919   4                                              STA = 1;                                                                                                                // Restart a new transfer
 920   4                                      }
 921   3                                      else
 922   3                                      {
 923   4                                              eepromCount = 0;
 924   4                                              eepromWriteDone = 1;
 925   4                                              STO = 1;
 926   4                                              SMB_BUSY = 0;
 927   4                                              FAIL = 1;
 928   4                                      }       
 929   3                              }
 930   2                              else
 931   2                              {}
 932   2      
 933   2                      break;
 934   2      
 935   2      //-------------------------------------------------------------------------------------------------------
 936   2      //Master Transmitter: Data byte transmitted.  ACK received. For a READ: N/A
 937   2      //For a WRITE: Send all data.  After the last data byte, send the stop bit
 938   2      //-------------------------------------------------------------------------------------------------------
 939   2              case SMB_DATA_TX_ACK_RX:
 940   2                      if(slaveAddr == MCU_SLAVE_ADDR)
 941   2                              {
 942   3                                      if(TxCounter < numBytesWR)
 943   3                              {
 944   4                                              SMB0DAT = sharedDataTx[startAddr + TxCounter];                                  // Send data byte
 945   4                              TxCounter++;
 946   4                              }
 947   3                              else
 948   3                              {
 949   4                              STO = 1;                                                                        // Set STO to terminate transfer                                                                
             -                                
 950   4                              SMB_BUSY = 0;                                                                   // And free SMBus interface
 951   4                                              slaveWriteDone = 1;                                                                                             // Mark end of slave write
 952   4                              }
 953   3                              }
 954   2                  else if(slaveAddr == REAL_TIME_CLOCK_ADDR)
C51 COMPILER V9.56.0.0   MAIN                                                              11/25/2017 11:54:57 PAGE 17  

 955   2                              {
 956   3                                      if(TxCounter < numBytesWR)
 957   3                              {
 958   4                                              SMB0DAT = sharedDataTx[startAddr + TxCounter];                                  // Send data byte
 959   4                              TxCounter++;
 960   4                              }
 961   3                              else
 962   3                              {
 963   4                              STO = 1;                                                                        // Set STO to terminate transfer                                                                
             -                                
 964   4                              SMB_BUSY = 0;                                                                   // And free SMBus interface
 965   4                                              rtcWriteDone = 1;                                                                                               // Mark end of slave write
 966   4                              }
 967   3                              }
 968   2                      break;
 969   2      
 970   2      //-------------------------------------------------------------------------------------------------------
 971   2      // Master Transmitter: Data byte transmitted.  NACK received. Restart the transfer
 972   2      //-------------------------------------------------------------------------------------------------------
 973   2              case SMB_DATA_TX_NACK_RX:
 974   2                              if(slaveAddr == MCU_SLAVE_ADDR)
 975   2                              {
 976   3                                      if(slaveCount < MAX_NACK_RETRY)
 977   3                                      {
 978   4                                              slaveCount++;                                                                                                   // Increment number of attempts when NACK is received
 979   4                                              STA = 1;                                                                                                                // Restart a new transfer
 980   4                                      }
 981   3                                      else
 982   3                                      {
 983   4                                              slaveCount = 0;
 984   4                                              STO = 1;
 985   4                                              SMB_BUSY = 0;
 986   4                                              FAIL = 1;
 987   4                                      }       
 988   3                              }
 989   2                  else if(slaveAddr == REAL_TIME_CLOCK_ADDR)
 990   2                              {
 991   3                                      if(realTimeClockCount < MAX_NACK_RETRY)
 992   3                                      {
 993   4                                              realTimeClockCount++;                                                                                   // Increment number of attempts when NACK is received
 994   4                                              STA = 1;                                                                                                                // Restart a new transfer
 995   4                                      }
 996   3                                      else
 997   3                                      {
 998   4                                              realTimeClockCount = 0;
 999   4                                              STO = 1;
1000   4                                              SMB_BUSY = 0;
1001   4                                              FAIL = 1;
1002   4                                      }       
1003   3                              }
1004   2                              else if(slaveAddr == EEPROM_ADDR)
1005   2                              {
1006   3                                      if(eepromCount < MAX_NACK_RETRY)
1007   3                                      {
1008   4                                              eepromCount++;                                                                                                  // Increment number of attempts when NACK is received
1009   4                                              STA = 1;                                                                                                                // Restart a new transfer
1010   4                                      }
1011   3                                      else
1012   3                                      {
1013   4                                              eepromCount = 0;
1014   4                                              STO = 1;
1015   4                                              SMB_BUSY = 0;
C51 COMPILER V9.56.0.0   MAIN                                                              11/25/2017 11:54:57 PAGE 18  

1016   4                                              FAIL = 1;
1017   4                                      }       
1018   3                              }
1019   2                              else
1020   2                              {}
1021   2                      break;
1022   2      
1023   2      //-------------------------------------------------------------------------------------------------------
1024   2      // Master Receiver: Slave address + READ transmitted.  ACK received. 
1025   2      // For a READ: check if this is a one-byte transfer. if so, set the NACK after the data byte
1026   2      // is received to end the transfer. if not, set the ACK and receive the other data bytes
1027   2      //-------------------------------------------------------------------------------------------------------
1028   2              case SMB_ADDR_R_TX_ACK_RX:
1029   2                      if(numBytesRD == 1)                                                                                                             // If there is one byte to transfer, send a NACK and go to
1030   2                      {                                                                                                                                               // SMB_DATA_RX_NACK_TX case to accept data from slave
1031   3                      AA = 0;                                                                                 // Clear AA flag before data byte is rec
             -eived
1032   3                                                                                                              // send NACK signal to slave after byte 
             -is received
1033   3                      }
1034   2                      else
1035   2                      {
1036   3                      AA = 1;                                                                                 // More than one byte in this transfer,
1037   3                                                                                                              // send ACK after byte is received
1038   3                      }
1039   2                      break;
1040   2      
1041   2      //-------------------------------------------------------------------------------------------------------
1042   2      // Master Receiver: Slave address + READ transmitted.  NACK received. Restart the transfer
1043   2      //-------------------------------------------------------------------------------------------------------
1044   2              case SMB_ADDR_R_TX_NACK_RX:
1045   2                              if(slaveAddr == MCU_SLAVE_ADDR)
1046   2                              {
1047   3                                      if(slaveCount < MAX_NACK_RETRY)
1048   3                                      {
1049   4                                              slaveCount++;                                                                                                   // Increment number of attempts when NACK is received
1050   4                                              STA = 1;                                                                                                                // Restart transfer after receiving a NACK
1051   4                                      }
1052   3                                      else
1053   3                                      {
1054   4                                              slaveCount = 0;                                                                                                 // Reset counter
1055   4                                              STO = 1;
1056   4                                              SMB_BUSY = 0;
1057   4                                              FAIL = 1;
1058   4                                      }       
1059   3                              }
1060   2                  else if(slaveAddr == REAL_TIME_CLOCK_ADDR)
1061   2                              {
1062   3                                      if(realTimeClockCount < MAX_NACK_RETRY)
1063   3                                      {
1064   4                                              realTimeClockCount++;                                                                                   // Increment number of attempts when NACK is received
1065   4                                              STA = 1;                                                                                                                // Restart a new transfer
1066   4                                      }
1067   3                                      else
1068   3                                      {
1069   4                                              realTimeClockCount = 0;
1070   4                                              STO = 1;
1071   4                                              SMB_BUSY = 0;
1072   4                                              FAIL = 1;
1073   4                                      }       
1074   3                              }
1075   2                              else if(slaveAddr == EEPROM_ADDR)
C51 COMPILER V9.56.0.0   MAIN                                                              11/25/2017 11:54:57 PAGE 19  

1076   2                              {
1077   3                                      if(eepromCount < MAX_NACK_RETRY)
1078   3                                      {
1079   4                                              eepromCount++;                                                                                                  // Increment number of attempts when NACK is received
1080   4                                              STA = 1;                                                                                                                // Restart a new transfer
1081   4                                      }
1082   3                                      else
1083   3                                      {
1084   4                                              eepromCount = 0;
1085   4                                              STO = 1;
1086   4                                              SMB_BUSY = 0;
1087   4                                              FAIL = 1;
1088   4                                      }       
1089   3                              }
1090   2                              else
1091   2                              {}
1092   2                      break;
1093   2      
1094   2      //-------------------------------------------------------------------------------------------------------
1095   2      // Master Receiver: Data byte received. If AA flag was set beforehand, then ACK transmitted.
1096   2      // For a READ: receive each byte from the slave.  if this is the last byte, send a NACK and set the STOP b
             -it
1097   2      //-------------------------------------------------------------------------------------------------------
1098   2              case SMB_DATA_RX_ACK_TX:
1099   2                              
1100   2                              if(slaveAddr == MCU_SLAVE_ADDR)
1101   2                              {
1102   3                                      if (RxCounter < numBytesRD)
1103   3                              {
1104   4                                              sharedDataRx[startAddr + RxCounter] = SMB0DAT;
1105   4                              AA = 1;                                                                         // Send ACK to indicate byte received
1106   4                              RxCounter++;                                                                    // Increment the byte counter
1107   4                                              slaveReadDone = 0;                                                                                              // Mark start of slave read
1108   4                              }
1109   3                              else
1110   3                              {
1111   4                              AA = 0;                                                                         // Send NACK to indicate last byte is re
             -ceived
1112   4                                              slaveReadDone = 1;                                                                                              // Mark end of slave read
1113   4                              }
1114   3                              }
1115   2                  else if(slaveAddr == REAL_TIME_CLOCK_ADDR)
1116   2                              {
1117   3                                      if(RxCounter < numBytesRD)
1118   3                                      {
1119   4                                              sharedDataRx[startAddr + RxCounter] = SMB0DAT;                                  // RTC
1120   4                                              rtcReadDone = 0;
1121   4                                              
1122   4                                              AA = 1;                                                                                                                 // Send ACK to indicate byte received
1123   4                                              RxCounter++;                                                                                                    // Increment the byte counter
1124   4                                      }
1125   3                                      else
1126   3                                      {
1127   4                                              rtcReadDone = 1;
1128   4                                              AA = 0;                                                                                                                 // Send NACK to indicate last byte is received
1129   4                                      }
1130   3                              }
1131   2                              else if(slaveAddr == EEPROM_ADDR)
1132   2                              {
1133   3                                      if(RxCounter < numBytesRD)
1134   3                                      {
1135   4                                              eepromDataByte = eepromRx[RxCounter] = SMB0DAT;
C51 COMPILER V9.56.0.0   MAIN                                                              11/25/2017 11:54:57 PAGE 20  

1136   4                                              AA = 1;                                                                                                                 // Send ACK to indicate byte received
1137   4                                              RxCounter++;                                                                                                    // Increment the byte counter
1138   4                                              eepromReadDone = 0;                                                                                             // Mark start of fram read
1139   4                                      }
1140   3                                      else
1141   3                                      {
1142   4                                              AA = 0;                                                                                                                 // Send NACK to indicate last byte is received
1143   4                                              eepromReadDone = 1;                                                                                             // Mark end of fram read
1144   4                                      }
1145   3                              }
1146   2                      break;
1147   2      
1148   2      //-------------------------------------------------------------------------------------------------------
1149   2      // Master Receiver: Data byte received. If AA flag was cleared, then NACK transmitted.
1150   2      // For a READ: Read operation has completed.  Read data register and send STOP
1151   2      //-------------------------------------------------------------------------------------------------------
1152   2              case SMB_DATA_RX_NACK_TX:
1153   2                              if(slaveAddr == MCU_SLAVE_ADDR)
1154   2                              {
1155   3                                      sharedDataRx[startAddr + RxCounter] = SMB0DAT;
1156   3                              STO = 1;                                                                                                                        // Stop transfer
1157   3                              SMB_BUSY = 0;                                                                                                           // Release SMB
1158   3                              AA = 1;
1159   3                                      slaveReadDone = 1;                                                                                                      // Mark end of slave read                                                                                                                               // Set AA for next transfer   
             -                                                                      
1160   3                              }
1161   2                  else if(slaveAddr == REAL_TIME_CLOCK_ADDR)
1162   2                              {
1163   3                                      sharedDataRx[startAddr + RxCounter] = SMB0DAT;                                          // RTC
1164   3                                      rtcReadDone = 1;
1165   3      
1166   3                                      STO = 1;                                                                                                                        // Stop transfer
1167   3                                      SMB_BUSY = 0;                                                                                                           // Release SMB
1168   3                                      AA = 1;                                                                                                                         // Send ACK to indicate byte received
1169   3                              }
1170   2                              else if(slaveAddr == EEPROM_ADDR)
1171   2                              {
1172   3                                      eepromRx[RxCounter] = SMB0DAT;
1173   3                                      STO = 1;                                                                                                                        // Stop transfer
1174   3                                      SMB_BUSY = 0;                                                                                                           // Release SMB
1175   3                                      AA = 1;
1176   3                                      eepromReadDone = 1;                                                                                                     // Mark end of eeprom read      
1177   3                              }
1178   2                      break;
1179   2      
1180   2      //-------------------------------------------------------------------------------------------------------
1181   2      // Master Transmitter: Arbitration lost
1182   2      //-------------------------------------------------------------------------------------------------------
1183   2              case SMB_ARBITRATION_LOST:
1184   2                      FAIL = 1;                                                                                       // Indicate failed transfer
1185   2                                                                                                              // and handle at end of ISR
1186   2                      break;
1187   2      
1188   2      //-------------------------------------------------------------------------------------------------------
1189   2      // All other status codes invalid.  Reset communication
1190   2      //-------------------------------------------------------------------------------------------------------
1191   2              default:
1192   2                      FAIL = 1;
1193   2                      break;
1194   2         }
1195   1      //-------------------------------------------------------------------------------------------------------
1196   1      // If all failed, reset everything
C51 COMPILER V9.56.0.0   MAIN                                                              11/25/2017 11:54:57 PAGE 21  

1197   1      //-------------------------------------------------------------------------------------------------------
1198   1              if(FAIL)                                                                                                // If the transfer failed,
1199   1              {
1200   2              SMB0CN &= ~0x40;                                                                                // Reset communication
1201   2              SMB0CN |= 0x40;
1202   2              STA = 0;
1203   2              STO = 0;
1204   2              AA = 0;
1205   2      
1206   2              SMB_BUSY = 0;                                                                                   // Free SMBus
1207   2      
1208   2              FAIL = 0;
1209   2                                                                                                                                                                              // Set to finish all pending processes
1210   2                      slaveWriteDone = 1;                                                                                                                     // Mark end of slave write
1211   2                      slaveReadDone = 1;                                                                                                                      // Mark end of slave read
1212   2              rtcWriteDone = 1;
1213   2                      rtcReadDone = 1;
1214   2                      eepromWriteDone = 1;                                                                                                            // Mark end of eeprom write
1215   2                      eepromReadDone = 1;                                                                                                                     // Mark end of eeprom read
1216   2              }
1217   1      
1218   1              SI = 0;                                                                                                 // Clear interrupt flag
1219   1      }
1220          
1221          //-------------------------------------------------------------------------------------------------------
1222          // Function Name: setClockControl
1223          // Return Value: None 
1224          // Parmeters: None
1225          // Function Description: This function sets values to the real time clock control register
1226          // Check DS3232 documentation for more details of this this control register
1227          //-------------------------------------------------------------------------------------------------------
1228          void setClockControl(void)
1229          {
1230   1              sharedDataTx[RTC_START_ADDR + RTC_CONTROL] = 0x04;
*** ERROR C202 IN LINE 1230 OF main.c: 'RTC_START_ADDR': undefined identifier
1231   1              sharedDataTx[RTC_START_ADDR + RTC_CONTROL_STATUS] = 0x30; 
*** ERROR C202 IN LINE 1231 OF main.c: 'RTC_START_ADDR': undefined identifier
1232   1              writeBytesToRealTimeClock(RTC_START_ADDR + RTC_CONTROL, 2);                                                     // Set control registers (2 byte)
*** ERROR C202 IN LINE 1232 OF main.c: 'RTC_START_ADDR': undefined identifier
1233   1      }
1234                                                                            
1235          //-------------------------------------------------------------------------------------------------------
1236          // Function Name: setClock
1237          // Return Value: None 
1238          // Parmeters: None
1239          // Function Description: This function sets the new values to the real time clock
1240          //-------------------------------------------------------------------------------------------------------
1241          void setClock(void)
1242          {       
1243   1              unsigned char hoursAux;
1244   1              
1245   1              sharedDataTx[RTC_START_ADDR + SECONDS] = convertDecimalToBCD(seconds);                          // Load all data from PC to arr
             -ay before writing
*** ERROR C202 IN LINE 1245 OF main.c: 'RTC_START_ADDR': undefined identifier
1246   1              sharedDataTx[RTC_START_ADDR + MINUTES] = convertDecimalToBCD(minutes);                          // All data: seconds,.... are a
             -lready converted to BCD
*** ERROR C202 IN LINE 1246 OF main.c: 'RTC_START_ADDR': undefined identifier
1247   1              sharedDataTx[RTC_START_ADDR + DAY] = convertDecimalToBCD(day);
*** ERROR C202 IN LINE 1247 OF main.c: 'RTC_START_ADDR': undefined identifier
1248   1              sharedDataTx[RTC_START_ADDR + DATE] = convertDecimalToBCD(date);
*** ERROR C202 IN LINE 1248 OF main.c: 'RTC_START_ADDR': undefined identifier
1249   1              sharedDataTx[RTC_START_ADDR + MONTH] = convertDecimalToBCD(month);
C51 COMPILER V9.56.0.0   MAIN                                                              11/25/2017 11:54:57 PAGE 22  

*** ERROR C202 IN LINE 1249 OF main.c: 'RTC_START_ADDR': undefined identifier
1250   1              sharedDataTx[RTC_START_ADDR + YEAR] = convertDecimalToBCD(year);
*** ERROR C202 IN LINE 1250 OF main.c: 'RTC_START_ADDR': undefined identifier
1251   1              
1252   1              hoursAux = convertDecimalToBCD(hours);                                                                                          // Get updated hours from user on screen
1253   1      
1254   1              hoursAux = hoursAux | 0x40;                                                                                                                     // Set 12/24 bit --> 12 hour mode
1255   1              
1256   1              if(amPm == 'P')
1257   1              {
1258   2                       hoursAux = hoursAux | 0x60;                                                                                                    // Set AM/PM bit --> PM mode
1259   2              }
1260   1              else if(amPm == 'A')
1261   1              {
1262   2                       hoursAux = hoursAux & 0x5F;                                                                                                    // Clear AM/PM bit --> AM mode
1263   2              }
1264   1              
1265   1              sharedDataTx[RTC_START_ADDR + HOURS] = hoursAux;
*** ERROR C202 IN LINE 1265 OF main.c: 'RTC_START_ADDR': undefined identifier
1266   1              
1267   1              writeBytesToRealTimeClock(RTC_START_ADDR, 7);                                       // Write 7 bytes to R
             -TC
*** ERROR C202 IN LINE 1267 OF main.c: 'RTC_START_ADDR': undefined identifier
1268   1      
1269   1              //resetAllDisplayCounters();                                                                                                                    // Update new values on screen
1270   1      }                       
1271          
1272          //-------------------------------------------------------------------------------------------------------
1273          // Function Name: getClockData()
1274          // Return Value: None 
1275          // Parmeters: None
1276          // Function Description: This function gets the new values from the real time clock
1277          //-------------------------------------------------------------------------------------------------------
1278          void getClockData()
1279          {
1280   1              static unsigned char previousMonth = 0;
1281   1              static unsigned char previousDate = 0;
1282   1              static unsigned char previousYear = 0;
1283   1              static unsigned char previousHours = 0;
1284   1              static unsigned char previousMinutes = 0;
1285   1              static unsigned char previousSeconds = 0;
1286   1              
1287   1              unsigned int currentIndex = 0;
1288   1              unsigned char tempHours;
1289   1              
1290   1              readBytesFromRealTimeClock(RTC_START_ADDR, 7);                                                                          // Get date and time (7 bytes)
*** ERROR C202 IN LINE 1290 OF main.c: 'RTC_START_ADDR': undefined identifier
1291   1      
1292   1              seconds = convertBCDToDecimal(sharedDataRx[RTC_START_ADDR + SECONDS]);                          // Convert BCD to decimal for s
             -econds (1 byte)
*** ERROR C202 IN LINE 1292 OF main.c: 'RTC_START_ADDR': undefined identifier
1293   1              minutes = convertBCDToDecimal(sharedDataRx[RTC_START_ADDR + MINUTES]);                          // Convert BCD to decimal for m
             -inutes (1 byte)
*** ERROR C202 IN LINE 1293 OF main.c: 'RTC_START_ADDR': undefined identifier
1294   1      
1295   1              tempHours = sharedDataRx[RTC_START_ADDR + HOURS];                                                                       // Get BCD without conversion and check AM/PM
*** ERROR C202 IN LINE 1295 OF main.c: 'RTC_START_ADDR': undefined identifier
1296   1      
1297   1              if(tempHours & 0x40)                                                                                                                            // 12/24 bit (bit 6) is set --> 12 hour mode
1298   1              {
1299   2                      timeMode = TWELVE_HR_MODE;
*** ERROR C202 IN LINE 1299 OF main.c: 'TWELVE_HR_MODE': undefined identifier
C51 COMPILER V9.56.0.0   MAIN                                                              11/25/2017 11:54:57 PAGE 23  

1300   2      
1301   2                      if(tempHours & 0x20)                                                                                                                    // PM/AM bit (bit 5) is set --> PM
1302   2                      {
1303   3                              amPm = 'P';
1304   3                      }
1305   2                      else
1306   2                      {
1307   3                          amPm = 'A';
1308   3                      }
1309   2              }
1310   1              else
1311   1              {
1312   2                      timeMode = TWENTY_FOUR_HR_MODE;
*** ERROR C202 IN LINE 1312 OF main.c: 'TWENTY_FOUR_HR_MODE': undefined identifier
1313   2              }
1314   1      
1315   1              hours = convertBCDToDecimal(tempHours & 0x1F);                                                                          // Get hours (bit 4 to bit 0 only. Ignore others)
1316   1      
1317   1              if(hours == 12)
1318   1              {
1319   2                      if(amPm == 'A')
1320   2                      {
1321   3                              hours24 = 0;
1322   3                      }
1323   2                      else
1324   2                      {
1325   3                              hours24 = hours;
1326   3                      }       
1327   2              }
1328   1              else
1329   1              {
1330   2                      if(amPm == 'P')
1331   2                      {
1332   3                              hours24 = hours + 12;                                                                                                           // Twenty four hour format if PM
1333   3                      }
1334   2                      else
1335   2                      {
1336   3                              hours24 = hours;                                                                                                                        // Twenty four hour format if AM
1337   3                      }
1338   2              }
1339   1      
1340   1              day = convertBCDToDecimal(sharedDataRx[RTC_START_ADDR + DAY]);                                          // Convert BCD to decimal for day (1 
             -byte)
*** ERROR C202 IN LINE 1340 OF main.c: 'RTC_START_ADDR': undefined identifier
1341   1              date = convertBCDToDecimal(sharedDataRx[RTC_START_ADDR + DATE]);                                        // Convert BCD to decimal for date (
             -1 byte)
*** ERROR C202 IN LINE 1341 OF main.c: 'RTC_START_ADDR': undefined identifier
1342   1              month = convertBCDToDecimal(sharedDataRx[RTC_START_ADDR + MONTH]);                                      // Convert BCD to decimal for mont
             -h (1 byte)
*** ERROR C202 IN LINE 1342 OF main.c: 'RTC_START_ADDR': undefined identifier
1343   1              year = convertBCDToDecimal(sharedDataRx[RTC_START_ADDR + YEAR]);                                        // Convert BCD to decimal for year (
             -1 byte)
*** ERROR C202 IN LINE 1343 OF main.c: 'RTC_START_ADDR': undefined identifier
1344   1      
1345   1              if(month != previousMonth || date != previousDate || year != previousYear)
1346   1              {
1347   2                      monthDateYearUpdated = SET;     
1348   2              }
1349   1              if(hours != previousHours || minutes != previousMinutes || seconds != previousSeconds)
1350   1              {
1351   2                      timeUpdated = SET;
1352   2              }
C51 COMPILER V9.56.0.0   MAIN                                                              11/25/2017 11:54:57 PAGE 24  

1353   1      
1354   1              if(amPm == 'P')
1355   1              {
1356   2                      currentIndex = ((12 + hours) * 60) + minutes;
1357   2              }
1358   1              else if(amPm == 'A')
1359   1              {
1360   2                      if(hours == 12)
1361   2                      {
1362   3                              hours = 0;
1363   3                      }
1364   2                      
1365   2                      currentIndex = (hours * 60) + minutes;
1366   2              }
1367   1              else
1368   1              {}
1369   1      
1370   1              minuteIndex = currentIndex % 60;                                                                                                        // Get minute index from 0 - 59
1371   1              hourIndex = currentIndex / 60;                                                                                                          // Get hour index from 0 - 23
1372   1      
1373   1              previousDate = date;
1374   1              previousMonth = month;
1375   1              previousYear = year;
1376   1              previousHours = hours;
1377   1              previousMinutes = minutes;
1378   1              previousSeconds = seconds;
1379   1      }
1380          
1381          //-------------------------------------------------------------------------------------------------------
1382          // Function Name: moveDateTimeUp
1383          // Return Value: None 
1384          // Parmeters: None
1385          // Function Description: This function sets date and time of the clock from the touch screen by pressing t
             -he up button
1386          //-------------------------------------------------------------------------------------------------------
1387          void moveDateTimeUp(void)
1388          {
1389   1              char str[SPRINTF_SIZE];
1390   1              
1391   1              if(realTimeClockItems == MONTH_ADJUST)
*** ERROR C202 IN LINE 1391 OF main.c: 'MONTH_ADJUST': undefined identifier
1392   1              {
1393   2                      adjustedMonth++;
1394   2                      monthUpdated = SET;
1395   2      
1396   2                      if(adjustedMonth > 12)
1397   2                      {
1398   3                              adjustedMonth = 1;                                                                                                                      // Roll over
1399   3                      }
1400   2      
1401   2                      sprintf(str, "%s ", monthOfYear[adjustedMonth]);
1402   2                      displayText(VALUE_DISPLAY_FG, VALUE_DISPLAY_BG, VALUE_DISPLAY_FONT, str, VALUE_DISPLAY_X, VALUE_DISPLAY_
             -Y);
*** ERROR C202 IN LINE 1402 OF main.c: 'VALUE_DISPLAY_FG': undefined identifier
1403   2              }
1404   1              else if(realTimeClockItems == DATE_ADJUST)
*** ERROR C202 IN LINE 1404 OF main.c: 'DATE_ADJUST': undefined identifier
1405   1              {
1406   2                      adjustedDate++;
1407   2                      dateUpdated = SET;
1408   2      
1409   2                      if(adjustedDate > 31)
C51 COMPILER V9.56.0.0   MAIN                                                              11/25/2017 11:54:57 PAGE 25  

1410   2                      {
1411   3                              adjustedDate = 1;                                                                                                                       // Roll over
1412   3                      }
1413   2      
1414   2                      sprintf(str, "%bu   ", adjustedDate);
1415   2                      displayText(VALUE_DISPLAY_FG, VALUE_DISPLAY_BG, VALUE_DISPLAY_FONT, str, VALUE_DISPLAY_X, VALUE_DISPLAY_
             -Y);
*** ERROR C202 IN LINE 1415 OF main.c: 'VALUE_DISPLAY_FG': undefined identifier
1416   2              }
1417   1              else if(realTimeClockItems == YEAR_ADJUST)
*** ERROR C202 IN LINE 1417 OF main.c: 'YEAR_ADJUST': undefined identifier
1418   1              {
1419   2                      adjustedYear++;
1420   2                      yearUpdated = SET;
1421   2      
1422   2                      if(adjustedYear > 99)
1423   2                      {
1424   3                              adjustedYear = 99;
1425   3                      }
1426   2      
1427   2                      sprintf(str, "20%02bu", adjustedYear);
1428   2                      displayText(VALUE_DISPLAY_FG, VALUE_DISPLAY_BG, VALUE_DISPLAY_FONT, str, VALUE_DISPLAY_X, VALUE_DISPLAY_
             -Y);
*** ERROR C202 IN LINE 1428 OF main.c: 'VALUE_DISPLAY_FG': undefined identifier
1429   2              }
1430   1              else if(realTimeClockItems == HOUR_ADJUST)
*** ERROR C202 IN LINE 1430 OF main.c: 'HOUR_ADJUST': undefined identifier
1431   1              {
1432   2                      adjustedHours++;
1433   2                      hoursUpdated = SET;
1434   2      
1435   2                      if(adjustedHours > 12)
1436   2                      {
1437   3                              adjustedHours = 1;                                                                                                                      // Roll over
1438   3                      }
1439   2      
1440   2                      sprintf(str, "%bu   ", adjustedHours);
1441   2                      displayText(VALUE_DISPLAY_FG, VALUE_DISPLAY_BG, VALUE_DISPLAY_FONT, str, VALUE_DISPLAY_X, VALUE_DISPLAY_
             -Y);
*** ERROR C202 IN LINE 1441 OF main.c: 'VALUE_DISPLAY_FG': undefined identifier
1442   2              }
1443   1              else if(realTimeClockItems == MINUTE_ADJUST)
*** ERROR C202 IN LINE 1443 OF main.c: 'MINUTE_ADJUST': undefined identifier
1444   1              {
1445   2                      adjustedMinutes++;
1446   2                      minutesUpdated = SET;
1447   2      
1448   2                      if(adjustedMinutes > 59)
1449   2                      {
1450   3                              adjustedMinutes = 0;
1451   3                      }
1452   2      
1453   2                      sprintf(str, "%bu   ", adjustedMinutes);
1454   2                      displayText(VALUE_DISPLAY_FG, VALUE_DISPLAY_BG, VALUE_DISPLAY_FONT, str, VALUE_DISPLAY_X, VALUE_DISPLAY_
             -Y);
*** ERROR C202 IN LINE 1454 OF main.c: 'VALUE_DISPLAY_FG': undefined identifier
1455   2              }
1456   1              else if(realTimeClockItems == AMPM_ADJUST)
*** ERROR C202 IN LINE 1456 OF main.c: 'AMPM_ADJUST': undefined identifier
1457   1              {
1458   2                      if(adjustedAmPm == 'P')
1459   2                      {
C51 COMPILER V9.56.0.0   MAIN                                                              11/25/2017 11:54:57 PAGE 26  

1460   3                              adjustedAmPm = 'A';
1461   3                      }
1462   2                      else if(adjustedAmPm == 'A')
1463   2                      {
1464   3                              adjustedAmPm = 'P';
1465   3                      }
1466   2                      else
1467   2                      {}
1468   2      
1469   2                      amPmUpdated = SET;
1470   2      
1471   2                      sprintf(str, "%cM  ", adjustedAmPm);
1472   2                      displayText(VALUE_DISPLAY_FG, VALUE_DISPLAY_BG, VALUE_DISPLAY_FONT, str, VALUE_DISPLAY_X, VALUE_DISPLAY_
             -Y);
*** ERROR C202 IN LINE 1472 OF main.c: 'VALUE_DISPLAY_FG': undefined identifier
1473   2              }
1474   1              else
1475   1              {}
1476   1      }
1477          
1478          //-------------------------------------------------------------------------------------------------------
1479          // Function Name: moveDateTimeDown
1480          // Return Value: None 
1481          // Parmeters: None
1482          // Function Description: This function sets date and time of the clock from the touch screen by pressing t
             -he down button
1483          //-------------------------------------------------------------------------------------------------------
1484          void moveDateTimeDown(void)
1485          {
1486   1              char str[SPRINTF_SIZE];
1487   1      
1488   1              if(realTimeClockItems == MONTH_ADJUST)
*** ERROR C202 IN LINE 1488 OF main.c: 'MONTH_ADJUST': undefined identifier
1489   1              {
1490   2                      adjustedMonth--;
1491   2                      monthUpdated = SET;
1492   2      
1493   2                      if(adjustedMonth < 1)
1494   2                      {
1495   3                              adjustedMonth = 12;                                                                                                                     // Roll over to hour 12
1496   3                      }
1497   2                      sprintf(str, "%s ", monthOfYear[adjustedMonth]);
1498   2                      displayText(VALUE_DISPLAY_FG, VALUE_DISPLAY_BG, VALUE_DISPLAY_FONT, str, VALUE_DISPLAY_X, VALUE_DISPLAY_
             -Y);
*** ERROR C202 IN LINE 1498 OF main.c: 'VALUE_DISPLAY_FG': undefined identifier
1499   2              }
1500   1              else if(realTimeClockItems == DATE_ADJUST)
*** ERROR C202 IN LINE 1500 OF main.c: 'DATE_ADJUST': undefined identifier
1501   1              {
1502   2                      adjustedDate--;
1503   2                      dateUpdated = SET;
1504   2      
1505   2                      if(adjustedDate < 1)
1506   2                      {
1507   3                              adjustedDate = 31;                                                                                                                      // Roll over to day 31
1508   3                      }
1509   2      
1510   2                      sprintf(str, "%bu   ", adjustedDate);
1511   2                      displayText(VALUE_DISPLAY_FG, VALUE_DISPLAY_BG, VALUE_DISPLAY_FONT, str, VALUE_DISPLAY_X, VALUE_DISPLAY_
             -Y);
*** ERROR C202 IN LINE 1511 OF main.c: 'VALUE_DISPLAY_FG': undefined identifier
1512   2              }
C51 COMPILER V9.56.0.0   MAIN                                                              11/25/2017 11:54:57 PAGE 27  

1513   1              else if(realTimeClockItems == YEAR_ADJUST)
*** ERROR C202 IN LINE 1513 OF main.c: 'YEAR_ADJUST': undefined identifier
1514   1              {
1515   2                      if(adjustedYear > 0)
1516   2                      {
1517   3                              adjustedYear--;                                                                                                                         // Check if it is greater than 0 before decrementing                                                                                            
1518   3                      }                                                                                                                                                               // to avoid a negative number
1519   2                      else
1520   2                      {
1521   3                              adjustedYear = 0;                                                                                                                       // Roll over to 99
1522   3                      }
1523   2                      
1524   2                      yearUpdated = SET;
1525   2      
1526   2                      sprintf(str, "20%02bu", adjustedYear);
1527   2                      displayText(VALUE_DISPLAY_FG, VALUE_DISPLAY_BG, VALUE_DISPLAY_FONT, str, VALUE_DISPLAY_X, VALUE_DISPLAY_
             -Y);
*** ERROR C202 IN LINE 1527 OF main.c: 'VALUE_DISPLAY_FG': undefined identifier
1528   2              }
1529   1              else if(realTimeClockItems == HOUR_ADJUST)
*** ERROR C202 IN LINE 1529 OF main.c: 'HOUR_ADJUST': undefined identifier
1530   1              {
1531   2                      if(adjustedHours > 0)
1532   2                      {
1533   3                              adjustedHours--;                                                                                                                        // Check if it is greater than 0 before decrementing
1534   3                      }                                                                                                                                                               // to avoid a negative number
1535   2                      else
1536   2                      {
1537   3                              adjustedHours = 12;
1538   3                      }
1539   2      
1540   2                      hoursUpdated = SET;
1541   2      
1542   2                      sprintf(str, "%bu   ", adjustedHours);
1543   2                      displayText(VALUE_DISPLAY_FG, VALUE_DISPLAY_BG, VALUE_DISPLAY_FONT, str, VALUE_DISPLAY_X, VALUE_DISPLAY_
             -Y);
*** ERROR C202 IN LINE 1543 OF main.c: 'VALUE_DISPLAY_FG': undefined identifier
1544   2              }
1545   1              else if(realTimeClockItems == MINUTE_ADJUST)
*** ERROR C202 IN LINE 1545 OF main.c: 'MINUTE_ADJUST': undefined identifier
1546   1              {
1547   2                      if(adjustedMinutes > 0)
1548   2                      {
1549   3                              adjustedMinutes--;                                                                                                                      // Check if it is greater than 0 before decrementing
1550   3                      }                                                                                                                                                               // to avoid a negative number
1551   2                      else
1552   2                      {
1553   3                              adjustedMinutes = 59;
1554   3                      }
1555   2      
1556   2                      minutesUpdated = SET;
1557   2      
1558   2                      sprintf(str, "%bu   ", adjustedMinutes);
1559   2                      displayText(VALUE_DISPLAY_FG, VALUE_DISPLAY_BG, VALUE_DISPLAY_FONT, str, VALUE_DISPLAY_X, VALUE_DISPLAY_
             -Y);
*** ERROR C202 IN LINE 1559 OF main.c: 'VALUE_DISPLAY_FG': undefined identifier
1560   2              }
1561   1              else if(realTimeClockItems == AMPM_ADJUST)
*** ERROR C202 IN LINE 1561 OF main.c: 'AMPM_ADJUST': undefined identifier
1562   1              {
1563   2                      if(adjustedAmPm == 'P')
1564   2                      {
C51 COMPILER V9.56.0.0   MAIN                                                              11/25/2017 11:54:57 PAGE 28  

1565   3                              adjustedAmPm = 'A';
1566   3                      }
1567   2                      else if(adjustedAmPm == 'A')
1568   2                      {
1569   3                              adjustedAmPm = 'P';
1570   3                      }
1571   2                      else
1572   2                      {}
1573   2      
1574   2                      amPmUpdated = SET;
1575   2      
1576   2                      sprintf(str, "%cM  ", adjustedAmPm);
1577   2                      displayText(VALUE_DISPLAY_FG, VALUE_DISPLAY_BG, VALUE_DISPLAY_FONT, str, VALUE_DISPLAY_X, VALUE_DISPLAY_
             -Y);
*** ERROR C202 IN LINE 1577 OF main.c: 'VALUE_DISPLAY_FG': undefined identifier
1578   2              }
1579   1              else
1580   1              {}
1581   1      }
1582          
1583          //-------------------------------------------------------------------------------------------------------
1584          // Function Name: enterDateTime
1585          // Return Value: None 
1586          // Parmeters: None
1587          // Function Description: This function confirms the date or time set by the user on the touch screen
1588          //-------------------------------------------------------------------------------------------------------
1589          void enterDateTime(void)
1590          {
1591   1              char str[SPRINTF_SIZE];
1592   1              
1593   1              realTimeClockItems++;                                                                                                                           // Move to next item
1594   1              
1595   1              if(realTimeClockItems == MONTH_ADJUST)
*** ERROR C202 IN LINE 1595 OF main.c: 'MONTH_ADJUST': undefined identifier
1596   1              {
1597   2                      monthUpdated = SET;
1598   2                      displayText(TITLE_DISPLAY_FG, TITLE_DISPLAY_BG, TITLE_DISPLAY_FONT, "SET MONTH ", TITLE_DISPLAY_X, TITLE
             -_DISPLAY_Y);
*** ERROR C202 IN LINE 1598 OF main.c: 'TITLE_DISPLAY_FG': undefined identifier
1599   2                      sprintf(str, "%s ", monthOfYear[adjustedMonth]);
1600   2                      displayText(VALUE_DISPLAY_FG, VALUE_DISPLAY_BG, VALUE_DISPLAY_FONT, str, VALUE_DISPLAY_X, VALUE_DISPLAY_
             -Y);
*** ERROR C202 IN LINE 1600 OF main.c: 'VALUE_DISPLAY_FG': undefined identifier
1601   2              }
1602   1              else if(realTimeClockItems == DATE_ADJUST)
*** ERROR C202 IN LINE 1602 OF main.c: 'DATE_ADJUST': undefined identifier
1603   1              {
1604   2                      dateUpdated = SET;
1605   2                      displayText(TITLE_DISPLAY_FG, TITLE_DISPLAY_BG, TITLE_DISPLAY_FONT, "SET DATE  ", TITLE_DISPLAY_X, TITLE
             -_DISPLAY_Y);
*** ERROR C202 IN LINE 1605 OF main.c: 'TITLE_DISPLAY_FG': undefined identifier
1606   2                      sprintf(str, "%bu   ", adjustedDate);
1607   2                      displayText(VALUE_DISPLAY_FG, VALUE_DISPLAY_BG, VALUE_DISPLAY_FONT, str, VALUE_DISPLAY_X, VALUE_DISPLAY_
             -Y);
*** ERROR C202 IN LINE 1607 OF main.c: 'VALUE_DISPLAY_FG': undefined identifier
1608   2              }
1609   1              else if(realTimeClockItems == YEAR_ADJUST)
*** ERROR C202 IN LINE 1609 OF main.c: 'YEAR_ADJUST': undefined identifier
1610   1              {
1611   2                      yearUpdated = SET;
1612   2                      displayText(TITLE_DISPLAY_FG, TITLE_DISPLAY_BG, TITLE_DISPLAY_FONT, "SET YEAR  ", TITLE_DISPLAY_X, TITLE
             -_DISPLAY_Y);
C51 COMPILER V9.56.0.0   MAIN                                                              11/25/2017 11:54:57 PAGE 29  

*** ERROR C202 IN LINE 1612 OF main.c: 'TITLE_DISPLAY_FG': undefined identifier
1613   2                      sprintf(str, "20%02bu", adjustedYear);
1614   2                      displayText(VALUE_DISPLAY_FG, VALUE_DISPLAY_BG, VALUE_DISPLAY_FONT, str, VALUE_DISPLAY_X, VALUE_DISPLAY_
             -Y);
*** ERROR C202 IN LINE 1614 OF main.c: 'VALUE_DISPLAY_FG': undefined identifier
1615   2              }
1616   1              else if(realTimeClockItems == HOUR_ADJUST)
*** ERROR C202 IN LINE 1616 OF main.c: 'HOUR_ADJUST': undefined identifier
1617   1              {
1618   2                      hoursUpdated = SET;
1619   2                      displayText(TITLE_DISPLAY_FG, TITLE_DISPLAY_BG, TITLE_DISPLAY_FONT, "SET HOUR  ", TITLE_DISPLAY_X, TITLE
             -_DISPLAY_Y);
*** ERROR C202 IN LINE 1619 OF main.c: 'TITLE_DISPLAY_FG': undefined identifier
1620   2                      sprintf(str, "%bu   ", adjustedHours);
1621   2                      displayText(VALUE_DISPLAY_FG, VALUE_DISPLAY_BG, VALUE_DISPLAY_FONT, str, VALUE_DISPLAY_X, VALUE_DISPLAY_
             -Y);
*** ERROR C202 IN LINE 1621 OF main.c: 'VALUE_DISPLAY_FG': undefined identifier
1622   2              }
1623   1              else if(realTimeClockItems == MINUTE_ADJUST)
*** ERROR C202 IN LINE 1623 OF main.c: 'MINUTE_ADJUST': undefined identifier
1624   1              {
1625   2                      minutesUpdated = SET;
1626   2                      amPmUpdated = SET;                                                                                                                              // Set it anyway because user usually does not set at the end
1627   2                      displayText(TITLE_DISPLAY_FG, TITLE_DISPLAY_BG, TITLE_DISPLAY_FONT, "SET MINUTE", TITLE_DISPLAY_X, TITLE
             -_DISPLAY_Y);
*** ERROR C202 IN LINE 1627 OF main.c: 'TITLE_DISPLAY_FG': undefined identifier
1628   2                      sprintf(str, "%bu   ", adjustedMinutes);
1629   2                      displayText(VALUE_DISPLAY_FG, VALUE_DISPLAY_BG, VALUE_DISPLAY_FONT, str, VALUE_DISPLAY_X, VALUE_DISPLAY_
             -Y);
*** ERROR C202 IN LINE 1629 OF main.c: 'VALUE_DISPLAY_FG': undefined identifier
1630   2              }
1631   1              else if(realTimeClockItems == AMPM_ADJUST)
*** ERROR C202 IN LINE 1631 OF main.c: 'AMPM_ADJUST': undefined identifier
1632   1              {
1633   2                      amPmUpdated = SET;                                                                                                                              // Set it anyway because user usually does not set at the end
1634   2                      displayText(TITLE_DISPLAY_FG, TITLE_DISPLAY_BG, TITLE_DISPLAY_FONT, "SET AM/PM ", TITLE_DISPLAY_X, TITLE
             -_DISPLAY_Y);
*** ERROR C202 IN LINE 1634 OF main.c: 'TITLE_DISPLAY_FG': undefined identifier
1635   2                      sprintf(str, "%cM  ", adjustedAmPm);
1636   2                      displayText(VALUE_DISPLAY_FG, VALUE_DISPLAY_BG, VALUE_DISPLAY_FONT, str, VALUE_DISPLAY_X, VALUE_DISPLAY_
             -Y);
*** ERROR C202 IN LINE 1636 OF main.c: 'VALUE_DISPLAY_FG': undefined identifier
1637   2              }
1638   1              else if(realTimeClockItems == DONE_ADJUST)
*** ERROR C202 IN LINE 1638 OF main.c: 'DONE_ADJUST': undefined identifier
1639   1              {
1640   2                      amPmUpdated = SET;                                                                                                                              // Set it if user explicitly press enter button
1641   2                      displayText(TITLE_DISPLAY_FG, TITLE_DISPLAY_BG, TITLE_DISPLAY_FONT, "PRESS DONE", TITLE_DISPLAY_X, TITLE
             -_DISPLAY_Y);
*** ERROR C202 IN LINE 1641 OF main.c: 'TITLE_DISPLAY_FG': undefined identifier
1642   2                      displayText(VALUE_DISPLAY_FG, VALUE_DISPLAY_BG, VALUE_DISPLAY_FONT, "----", VALUE_DISPLAY_X, VALUE_DISPL
             -AY_Y);
*** ERROR C202 IN LINE 1642 OF main.c: 'VALUE_DISPLAY_FG': undefined identifier
1643   2              }
1644   1              else if(realTimeClockItems == ROLL_OVER_ADJUST)
*** ERROR C202 IN LINE 1644 OF main.c: 'ROLL_OVER_ADJUST': undefined identifier
1645   1              {
1646   2                      realTimeClockItems = MONTH_ADJUST;                                                                                              // Set it for next round of real time clock items
*** ERROR C202 IN LINE 1646 OF main.c: 'MONTH_ADJUST': undefined identifier
1647   2                      monthUpdated = SET;
1648   2                      displayText(TITLE_DISPLAY_FG, TITLE_DISPLAY_BG, TITLE_DISPLAY_FONT, "SET MONTH ", TITLE_DISPLAY_X, TITLE
             -_DISPLAY_Y);
C51 COMPILER V9.56.0.0   MAIN                                                              11/25/2017 11:54:57 PAGE 30  

*** ERROR C202 IN LINE 1648 OF main.c: 'TITLE_DISPLAY_FG': undefined identifier
1649   2                      sprintf(str, "%s ", monthOfYear[adjustedMonth]);
1650   2                      displayText(VALUE_DISPLAY_FG, VALUE_DISPLAY_BG, VALUE_DISPLAY_FONT, str, VALUE_DISPLAY_X, VALUE_DISPLAY_
             -Y);
*** ERROR C202 IN LINE 1650 OF main.c: 'VALUE_DISPLAY_FG': undefined identifier
1651   2              }
1652   1              else
1653   1              {}
1654   1      }
1655          
1656          //-------------------------------------------------------------------------------------------------------
1657          // Function Name: setClockOnScreen
1658          // Return Value: None 
1659          // Parmeters: None
1660          // Function Description: This function sets the real time clock on the touch screen
1661          //-------------------------------------------------------------------------------------------------------
1662          void setClockOnScreen(void)
1663          {               
1664   1              unsigned char hoursAux;
1665   1              
1666   1              if(monthUpdated == SET)
1667   1              {
1668   2                      sharedDataTx[RTC_START_ADDR + MONTH] = convertDecimalToBCD(adjustedMonth);              // Get updated month from us
             -er on screen
*** ERROR C202 IN LINE 1668 OF main.c: 'RTC_START_ADDR': undefined identifier
1669   2                      writeBytesToRealTimeClock(RTC_START_ADDR + MONTH, 1);                                                   // Set month only (1 byte)
*** ERROR C202 IN LINE 1669 OF main.c: 'RTC_START_ADDR': undefined identifier
1670   2                      monthUpdated = CLEAR;                                                                                                                   //Clear flag after writing to real time clock                                                                                                   
1671   2              }
1672   1              
1673   1              if(dateUpdated == SET)
1674   1              {
1675   2                      sharedDataTx[RTC_START_ADDR + DATE] = convertDecimalToBCD(adjustedDate);                // Get updated date from user 
             -on screen
*** ERROR C202 IN LINE 1675 OF main.c: 'RTC_START_ADDR': undefined identifier
1676   2                      writeBytesToRealTimeClock(RTC_START_ADDR + DATE, 1);                                                    // Set date only (1 byte)
*** ERROR C202 IN LINE 1676 OF main.c: 'RTC_START_ADDR': undefined identifier
1677   2                      dateUpdated = CLEAR;
1678   2              }
1679   1      
1680   1              if(yearUpdated == SET)
1681   1              {
1682   2                      sharedDataTx[RTC_START_ADDR + YEAR] = convertDecimalToBCD(adjustedYear);                // Get updated year from user 
             -on screen
*** ERROR C202 IN LINE 1682 OF main.c: 'RTC_START_ADDR': undefined identifier
1683   2                      writeBytesToRealTimeClock(RTC_START_ADDR + YEAR, 1);                                                    // Set year only (1 byte)
*** ERROR C202 IN LINE 1683 OF main.c: 'RTC_START_ADDR': undefined identifier
1684   2                      yearUpdated = CLEAR;
1685   2              }
1686   1      
1687   1              if(hoursUpdated == SET || amPmUpdated == SET)
1688   1              {
1689   2                      hoursAux = convertDecimalToBCD(adjustedHours);                                                                  // Get updated hours from user on screen
1690   2                      
1691   2                      if(amPmUpdated == SET)
1692   2                      {
1693   3                              amPm = adjustedAmPm;                                                                                                            // Set updated amPm from user on screen
1694   3                      
1695   3                              hoursAux = hoursAux | 0x40;                                                                                                     // Set 12/24 bit --> 12 hour mode
1696   3                              
1697   3                              if(adjustedAmPm == 'P')
1698   3                              {                                                                                                                                       
C51 COMPILER V9.56.0.0   MAIN                                                              11/25/2017 11:54:57 PAGE 31  

1699   4                                      hoursAux = hoursAux | 0x60;                                                                                             // Set AM/PM bit --> PM mode
1700   4                              }
1701   3                              else if(adjustedAmPm == 'A')
1702   3                              {                                                                                                                                       
1703   4                                      hoursAux = hoursAux & 0x5F;                                                                                             // Clear AM/PM bit --> AM mode
1704   4                              }
1705   3                              else
1706   3                              {}
1707   3      
1708   3                              amPmUpdated = CLEAR;
1709   3                      }
1710   2                      
1711   2                      sharedDataTx[RTC_START_ADDR + HOURS] = hoursAux;
*** ERROR C202 IN LINE 1711 OF main.c: 'RTC_START_ADDR': undefined identifier
1712   2                      writeBytesToRealTimeClock(RTC_START_ADDR + HOURS, 1);                                                   // Set hours only (1 byte)
*** ERROR C202 IN LINE 1712 OF main.c: 'RTC_START_ADDR': undefined identifier
1713   2                      hoursUpdated = CLEAR; 
1714   2              }
1715   1      
1716   1              if(minutesUpdated == SET)
1717   1              {
1718   2                      sharedDataTx[RTC_START_ADDR + MINUTES] = convertDecimalToBCD(adjustedMinutes);  // Get updated minutes fr
             -om user on screen
*** ERROR C202 IN LINE 1718 OF main.c: 'RTC_START_ADDR': undefined identifier
1719   2                      writeBytesToRealTimeClock(RTC_START_ADDR + MINUTES, 1);                                                 // Set minutes only (1 byte)
*** ERROR C202 IN LINE 1719 OF main.c: 'RTC_START_ADDR': undefined identifier
1720   2                      minutesUpdated = CLEAR;
1721   2              }
1722   1      
1723   1              realTimeClockItems = MONTH_ADJUST;                                                                                                      // Set starting item = Month for adjustment
*** ERROR C202 IN LINE 1723 OF main.c: 'MONTH_ADJUST': undefined identifier
1724   1      
1725   1              getClockData();                                                                                                                                     // Get current month, date, year set by user
1726   1      
1727   1              //clockSetupDisplayRepeat = 0;                                                                                                          // Display clock updates on screen                                                                                                                                              // Syste
             -m goes back to main page                                      
1728   1      }
1729          
1730          //-------------------------------------------------------------------------------------------------------
1731          // Function Name: resetClock
1732          // Return Value: None 
1733          // Parmeters: None
1734          // Function Description: This function resets the real time clock to 0:00:00 1/1/2000
1735          //-------------------------------------------------------------------------------------------------------
1736          void resetClock(void)
1737          {
1738   1              seconds = 0;
1739   1              minutes = 0;
1740   1              hours = 0;
1741   1              amPm = 'P';
1742   1              day = 1;
1743   1              date = 1;
1744   1              month = 1;
1745   1              year = 0;
1746   1              century = 0;
1747   1              timeMode = 1;
1748   1      
1749   1              setClock();                                                                                                                                     // Set real time clock
1750   1      }
1751          
1752          //-------------------------------------------------------------------------------------------------------
1753          // Function Name: convertDecimalToBCD
C51 COMPILER V9.56.0.0   MAIN                                                              11/25/2017 11:54:57 PAGE 32  

1754          // Return Value: bcd 
1755          // Parmeters: decimal
1756          // Function Description: This function converts a decimal number to a BCD when writing the new value to th
             -e real time clock
1757          //-------------------------------------------------------------------------------------------------------
1758          unsigned char convertDecimalToBCD(unsigned char decimal)
1759          {
1760   1              unsigned char bcd;
1761   1      
1762   1              bcd = (decimal / 10) << 4;                                                                                                                      // Get upper 4 bits
1763   1              bcd = bcd | (decimal % 10);                                                                                                                     // Get a BCD
1764   1      
1765   1              return bcd;
1766   1      }
1767          
1768          //-------------------------------------------------------------------------------------------------------
1769          // Function Name: convertBCDToDecimal
1770          // Return Value: decimal value 
1771          // Parmeters: bcd
1772          // Function Description: This function converts a BCD to a decimal number when reading the current value f
             -rom the real time clock
1773          //-------------------------------------------------------------------------------------------------------
1774          unsigned char convertBCDToDecimal(unsigned char bcd)
1775          {
1776   1              unsigned char decimal;
1777   1      
1778   1              decimal = ((bcd >> 4) * 10) + (bcd & 0x0F);                                                                                     // Combine upper and lower nibbles to get
1779   1                                                                                                                                                                                      // 8 bit number
1780   1              return decimal;
1781   1      }
1782          
1783          //-------------------------------------------------------------------------------------------------------
1784          // Function Name: displayClock
1785          // Return Value: None 
1786          // Parmeters: None
1787          // Function Description: This function displays clock data on the touch screen
1788          // The clock format is MM/DD/YYYY hour/minute/second
1789          //-------------------------------------------------------------------------------------------------------
1790          void displayClock(void)
1791          {
1792   1              char str[SPRINTF_SIZE];
1793   1              
1794   1              //if(screen == MAIN_PAGE)
1795   1              //{
1796   1              getClockData();
1797   1      
1798   1              sprintf(str, "%s %02bu, 20%02bu", monthOfYear[month], date, year);
1799   1              displayText(SETTINGS_DATE_FG, SETTINGS_DATE_BG, SETTINGS_DATE_FONT, str, SETTINGS_DATE_X, SETTINGS
             -_DATE_Y);
*** ERROR C202 IN LINE 1799 OF main.c: 'SETTINGS_DATE_FG': undefined identifier
1800   1              monthDateYearUpdated = CLEAR;
1801   1              
1802   1              sprintf(str, "%2bu:%02bu:%02bu %cM ", hours, minutes, seconds, amPm);
1803   1              displayText(SETTINGS_TIME_FG, SETTINGS_TIME_BG, SETTINGS_TIME_FONT, str, SETTINGS_TIME_X, SETTINGS
             -_TIME_Y);
*** ERROR C202 IN LINE 1803 OF main.c: 'SETTINGS_TIME_FG': undefined identifier
1804   1              //}
1805   1              /*else if(screen == CLOCK_SETUP_PAGE)
1806   1              {
1807   1                      if(buttonPressed == CLEAR)
1808   1                      {
1809   1                              getClockData();
C51 COMPILER V9.56.0.0   MAIN                                                              11/25/2017 11:54:57 PAGE 33  

1810   1              
1811   1                              sprintf(str, "%s %02bu, 20%02bu", monthOfYear[month], date, year);
1812   1                              displayText(DATE_DISPLAY_FG, DATE_DISPLAY_BG, DATE_DISPLAY_FONT, str, DATE_DISPLAY_X, DATE_DISPLAY_Y);
1813   1                              monthDateYearUpdated = CLEAR;
1814   1      
1815   1                              sprintf(str, "%2bu:%02bu:%02bu %cM ", hours, minutes, seconds, amPm);
1816   1                              displayText(TIME_DISPLAY_FG, TIME_DISPLAY_BG, TIME_DISPLAY_FONT, str, TIME_DISPLAY_X, TIME_DISPLAY_Y);
1817   1                              timeUpdated = CLEAR;
1818   1                      }
1819   1              }*/
1820   1      }
1821          
1822          void display_text(const char * fg, const char * bg, const unsigned char size, const char * message, const 
             -int x, const int y)
1823          {
1824   1          char str[128] = { 0 };
1825   1          
1826   1          int i = 0;
1827   1          while(i < 10000) i++;
1828   1              
1829   1          sprintf(str, "S %s %s\r", fg, bg);
1830   1          sendCommand(str);
1831   1          sprintf(str, "f %s\r", Font[size]);
1832   1          sendCommand(str);
1833   1          sprintf(str, "t \"%s\" %u %u\r", message, x, y);
1834   1          sendCommand(str);
1835   1      }
1836          
1837          static void send_macro(const unsigned int macro_index)
1838          {
1839   1          char str[8] = { 0 };
1840   1          
1841   1          int i = 0;
1842   1          while(i < 10000) i++;
1843   1              
1844   1          sprintf(str, "m %u\r", macro_index);
1845   1          sendCommand(str);
1846   1      }
1847          
1848          //-------------------------------------------------------------------------------------------------------
1849          // Main
1850          //-------------------------------------------------------------------------------------------------------
1851          #define NOOP(x)              // do nothings
1852          
1853          #define PAGE_SPLASH          0
1854          #define PAGE_MAIN            1
1855          #define PAGE_SETTINGS        2
1856          #define PAGE_SERVICE         3
1857          #define PAGE_CONFIG          4
1858          int current_page = PAGE_SPLASH;
1859          
1860          static bool user_cmd_equals(char * cmd)
*** ERROR C129 IN LINE 1860 OF main.c: missing ';' before 'user_cmd_equals'
1861          {
1862              return (cmd[0] == userCommand[1] && cmd[1] == userCommand[2] && cmd[2] == userCommand[3]);
1863          }
1864          
1865          void main()
1866          {
1867              int i = 0;
1868              int count = 0;
1869              int prev_temp = 0;
C51 COMPILER V9.56.0.0   MAIN                                                              11/25/2017 11:54:57 PAGE 34  

1870              int display_celsius = 0;
1871              int state_changed = 1;
1872              char str[SPRINTF_SIZE];
1873              
1874              disableWatchdog();
1875              systemClockInit();
1876              portInit();
1877              enableInterrupts();
1878              uart0Init();
1879              smbInit();
1880              timer3Init();
1881              
1882              tsLastCharGone = 1;
1883              tsTxOut = tsTxIn = 0;
1884              tsTxEmpty = 1;
1885              
1886              sprintf(str, "z\r");
1887              sendCommand(str);
1888              
1889              #define change_state(state) \
1890                  current_page = state;   \
1891                  state_changed = 1
1892              
1893              while(1)
1894              {
1895                  //scanUserInput();                                                        // Detect a string input
             - from the touch screen
1896                  
1897                  #define change_state(state) \
1898                      current_page = state;   \
1899                      state_changed = 1
1900          
1901          
1902                  switch(current_page) 
1903                  {
1904                      case (PAGE_SETTINGS):
1905                      {
1906                          if (state_changed) {
1907                              state_changed = 0;
1908                              display_text("000000", "FFFFFF", 8, "set!", 240, 110);
1909                          }
1910          
1911                          if ('1' == userCommand[1] && '3' == userCommand[2] && '1' == userCommand[3]) {
1912                              change_state(PAGE_SETTINGS);
1913                          }
1914                          else if ('1' == userCommand[1] && '2' == userCommand[2] && '8' == userCommand[3]) {
1915                              change_state(PAGE_MAIN);
1916                          }
1917                          else if ('1' == userCommand[1] && '3' == userCommand[2] && '2' == userCommand[3]) {
1918                              change_state(PAGE_SERVICE);
1919                          }
1920                          else {
1921                              // NOOP
1922                          }
1923                          break;
1924                      }
1925                      case (PAGE_CONFIG):
1926                      {
1927                          if (state_changed) {
1928                              state_changed = 0;
1929                              display_text("000000", "FFFFFF", 8, "cfg!", 240, 110);
1930                          }
C51 COMPILER V9.56.0.0   MAIN                                                              11/25/2017 11:54:57 PAGE 35  

1931                  
1932                          if ('1' == userCommand[1] && '3' == userCommand[2] && '1' == userCommand[3]) {
1933                              change_state(PAGE_SETTINGS);
1934                          }
1935                          else if ('1' == userCommand[1] && '2' == userCommand[2] && '8' == userCommand[3]) {
1936                              change_state(PAGE_MAIN);
1937                          }
1938                          else if ('1' == userCommand[1] && '3' == userCommand[2] && '2' == userCommand[3]) {
1939                              change_state(PAGE_SERVICE);
1940                          }
1941                          else {
1942                              // NOOP
1943                          }
1944                          break;
1945                      }
1946                      case (PAGE_SERVICE):
1947                      {
1948                          if (state_changed) {
1949                              state_changed = 0;
1950                              display_text("000000", "FFFFFF", 8, "svc!", 240, 110);
1951                          }
1952                                                                          
1953                                                                          
1954                                                                    /*for (k = 0; k < 4 ; k++){
1955                                                                                  if (passcode[k][0] == userCommand[1] && passcode[k][1] == userCommand[2] && passcode[k][2] == use
             -rCommand[3]) {
1956                                                                                  tsCommandReceived  = 0;
1957                                                                                          if (k == 3)
1958                                                                                                  display_text("000000","FFFFFF",8,"OK!", 240,200);
1959                                                                                  while(tsCommandReceived == 0);
1960                                                                           }
1961                                                                                  else{
1962                                                                                          continue;
1963                                                                                  }
1964                                                                   }      */                                                      
1965                          if ('1' == userCommand[1] && '3' == userCommand[2] && '1' == userCommand[3]) {
1966                              change_state(PAGE_SETTINGS);
1967                          }
1968                          else if ('1' == userCommand[1] && '2' == userCommand[2] && '8' == userCommand[3]) {
1969                              change_state(PAGE_MAIN);
1970                          }
1971                          else if ('1' == userCommand[1] && '3' == userCommand[2] && '2' == userCommand[3]) {
1972                              change_state(PAGE_SERVICE);
1973                          }
1974                          else {
1975                              // NOOP
1976                          }
1977                          break;
1978                      }
1979                      default:            // no break
1980                      case (PAGE_MAIN) :
1981                      {
1982                          roomTemp = readOneByteFromSlave(ROOM_TEMP);
1983          
1984                          if (state_changed) {
1985                              state_changed = 0;
1986                              sprintf(str, "%-3buC", roomTemp);
1987                              display_text("000000", "FFFFFF", 8, str, 240, 110);
1988                          }
1989                          
1990                          if (tsCommandReceived || roomTemp != prev_temp) 
1991                          {
C51 COMPILER V9.56.0.0   MAIN                                                              11/25/2017 11:54:57 PAGE 36  

1992                              prev_temp = roomTemp;
1993                              
1994                              if ('1' == userCommand[1] && '2' == userCommand[2] && '9' == userCommand[3]) {
1995                                  display_celsius = 1;
1996                                  sprintf(str, "%-3buC", roomTemp);
1997                                  display_text("000000", "FFFFFF", 8, str, 240, 110);
1998                              }
1999                              else if ('1' == userCommand[1] && '3' == userCommand[2] && '0' == userCommand[3]) {
2000                                  display_celsius = 0;
2001                                  roomTemp = (roomTemp * 9) / 5 + 32;
2002                                  sprintf(str, "%-3buF", roomTemp);
2003                                  display_text("000000", "FFFFFF", 8, str, 240, 110);
2004                              }
2005                              else if ('1' == userCommand[1] && '3' == userCommand[2] && '1' == userCommand[3]) {
2006                                  change_state(PAGE_SETTINGS);
2007                              }
2008                              else if ('1' == userCommand[1] && '2' == userCommand[2] && '8' == userCommand[3]) {
2009                                  change_state(PAGE_MAIN);
2010                              }
2011                              else if ('1' == userCommand[1] && '3' == userCommand[2] && '2' == userCommand[3]) {
2012                                  change_state(PAGE_SERVICE);
2013                              }
2014                              else {
2015                                  // Noop
2016                              }
2017                          }
2018                          break;
2019                      }
2020                  }
2021              }
2022          }

C51 COMPILATION COMPLETE.  0 WARNING(S),  84 ERROR(S)

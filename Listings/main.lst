C51 COMPILER V9.56.0.0   MAIN                                                              10/31/2017 19:33:32 PAGE 1   


C51 COMPILER V9.56.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE main.c LARGE OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listing
                    -s\main.lst) OBJECT(.\Objects\main.obj)

line level    source

   1          #include <c8051f120.h>
   2          #include <stdio.h> 
   3          #include <math.h>
   4          #include <stdlib.h>
   5          #include <string.h>
   6          #include <absacc.h>
   7          
   8          #include "macros.h"
   9          #include "laser.h"
  10          #include "motor.h"
  11          
  12          #define     SYSTEM_CLOCK                24500000
  13          #define         BAUD_RATE                           115200
  14          #define         RX_BUFFER_SIZE              256
  15          #define         TX_BUFFER_SIZE              256
  16          
  17          #define         TX_WAIT_LIMIT                           100 * (SYSTEM_CLOCK / 1000000)          // Waiting limit for TI0 and TI1 flags to be set
             - (10 microseconds max)
  18          #define         RX_WAIT_LIMIT                           100 * (SYSTEM_CLOCK / 1000000)          // Waiting limit for TI0 and TI1 flags to be set
             - (10 microseconds max)
  19          
  20          sfr16           RCAP2                                           = 0xCA;                                         // Timer 2 capture/reload
  21          sfr16           TMR2                                            = 0xCC;                                 // Timer 2
  22          sfr16           RCAP3                                           = 0xCA;                             // Timer 3 reload registers
  23          sfr16           TMR3                                            = 0xCC;                             // Timer 3 counter registers
  24          sfr16           RCAP4                                           = 0xCA;                             // Timer 3 reload registers
  25          sfr16           TMR4                                            = 0xCC;                                                         // Timer 4
  26          sfr16           DAC0                                            = 0xD2;                                         // DAC0 data
  27          sfr16           DAC1                                            = 0xD2;                                         // DAC1 data
  28          sfr16           ADC0                                            = 0xBE;                                         // ADC0 data
  29          sfr16           PCA0                                            = 0xF9;                                                         // PCA register
  30          
  31          #define         INTERRUPT_Timer_0                       1
  32          #define         INTERRUPT_Timer_1                       3
  33          #define         INTERRUPT_UART_0                        4
  34          #define         INTERRUPT_Timer_2                       5
  35          #define         INTERRUPT_SMB                           7
  36          #define         INTERRUPT_CPA                           9
  37          #define         INTERRUPT_COMP0_FALLING         10
  38          #define         INTERRUPT_COMP0_RISING          11
  39          #define         INTERRUPT_COMP1_FALLING         12
  40          #define         INTERRUPT_COMP1_RISING          13
  41          #define         INTERRUPT_Timer_3                       14
  42          #define         INTERRUPT_Timer_4                       16
  43          #define         INTERRUPT_ADC_0                         15
  44          #define         INTERRUPT_ADC_2                         18
  45          #define         INTERRUPT_UART_1                        20
  46          
  47          //-------------------------------------------------------------------------------------------------------
  48          // Global Declarations
  49          //-------------------------------------------------------------------------------------------------------
  50          unsigned char tsByte;
  51          
  52          bit splashEnd = 0;
C51 COMPILER V9.56.0.0   MAIN                                                              10/31/2017 19:33:32 PAGE 2   

  53          bit screenReset = 0;
  54          bit ackFromScreen = 0;
  55          bit tsCommandReceived = 0;
  56          bit tsCommandTransmitted = 0;
  57          
  58          unsigned char tsRxBuffer[RX_BUFFER_SIZE];
  59          unsigned char tsTxBuffer[TX_BUFFER_SIZE];
  60          unsigned char userCommand[RX_BUFFER_SIZE];
  61          
  62          unsigned int tsRxIn;
  63          unsigned int tsRxOut; 
  64          unsigned int tsTxIn;
  65          unsigned int tsTxOut;
  66          
  67          bit tsRxEmpty;
  68          bit tsTxEmpty;
  69          bit tsLastCharGone;                                             
  70          
  71          void systemClockInit(void)
  72          {
  73   1          char SFRPAGE_SAVE = SFRPAGE;                                                                                        // Save Current SFR page
  74   1              int i = 0;
  75   1          
  76   1              SFRPAGE  = CONFIG_PAGE;
  77   1              
  78   1          OSCICN    = 0x83;
  79   1      
  80   1              SFRPAGE = SFRPAGE_SAVE;                                                                                         // Restore SFRPAGE
  81   1      }
  82          
  83          void portInit(void)
  84          {
  85   1              char SFRPAGE_SAVE = SFRPAGE;                                                            // Save Current SFR page
  86   1      
  87   1              SFRPAGE = CONFIG_PAGE;                                                                  // Set SFR page
  88   1      
  89   1              XBR0 = 0x2F;                                                                                                                            // Enable UART0, UART1, SPI0, SMB, CEX0 - CEX4                                                                                                                                                  
  90   1              XBR1 = 0x01;                                                                            
  91   1          XBR2 = 0xC4;                                                                                                                                // Enable crossbar and disable weak pull-up                                                                                             
  92   1          
  93   1              P0MDOUT = 0x01;                                                                                 // Set TX0 pin to push-pull
  94   1                                                                                                                                                                      // TX0 = P0.0; RX0 = P0.1
  95   1              P0 = 0xFF;                                                                                                                                      // Initialize port P0 latch
  96   1              P1 = 0xFF;                                                                                                                                      // Initialize port P1 latch
  97   1              P2 = 0xFF;                                                                                                                                      // Initialize port P2 latch
  98   1              P3 = 0xFF;                                                                                                                                      // Initialize port P3 latch
  99   1              P4 = 0xFF;                                                                                                                                      // Initialize port P4 latch
 100   1              P5 = 0xFF;                                                                                                                                      // Initialize port P5 latch
 101   1              P6 = 0xFF;                                                                                                                                      // Initialize port P6 latch
 102   1              P7 = 0xFF;                                                                                                                                      // Initialize port P7 latch
 103   1      
 104   1          SFRPAGE = SFRPAGE_SAVE;                                                                     // Restore SFR page
 105   1      }
 106          
 107          void enableInterrupts(void)
 108          {
 109   1              IE = 0x92;                                                                                                                                      // Enable all interrupts + UART0 + Timer 0
 110   1      }
 111          
 112          void uart0Init(void)
 113          {
 114   1         char SFRPAGE_SAVE;
C51 COMPILER V9.56.0.0   MAIN                                                              10/31/2017 19:33:32 PAGE 3   

 115   1      
 116   1         SFRPAGE_SAVE = SFRPAGE;                                                                      // Preserve SFRPAGE
 117   1      
 118   1         SFRPAGE = TMR2_PAGE;
 119   1         TMR2CN = 0x00;                                                                               // Stop timer. Timer 2 in 16-bit auto-
             -reload up timer mode
 120   1         TMR2CF = 0x08;                                                                               // SYSCLK is time base; no output; up 
             -count only
 121   1         RCAP2L = 0xF3;                                                               // Low byte
 122   1         RCAP2H = 0xFF;                                                               // High byte
 123   1         TMR2 = RCAP2;                                                                // Load 16 bit reload valu
             -e into timer 2
 124   1         TMR2CN = 0x04;                                                               // Enable timer 2 (Start t
             -imer 2)
 125   1      
 126   1         SFRPAGE = UART0_PAGE;
 127   1         SCON0 = 0x50;                                                                                // 8-bit variable baud rate; 9th bit i
             -gnored; RX enabled
 128   1         SSTA0 = 0x05;                                                                                // Enable baud rate                   
             -                                                                      
 129   1                                                                                                      // Use timer 2 as RX and TX baud rate 
             -source
 130   1         IE = 0x90;                                                                   // Enable all interrupts a
             -nd UART0 Interrupt
 131   1      
 132   1         SFRPAGE = SFRPAGE_SAVE;                                                                      // Restore SFRPAGE
 133   1      }
 134          
 135          void disableWatchdog(void)
 136          {
 137   1          WDTCN = 0xDE;                                                    
 138   1          // Disable watchdog timer
 139   1          WDTCN = 0xAD;
 140   1      }
 141              
 142          void uart0Interrupt(void) interrupt INTERRUPT_UART_0 using 2
 143          {
 144   1              char SFRPAGE_SAVE = SFRPAGE;
 145   1              unsigned int i = 0;
 146   1              unsigned long txWaitCounter = 0;
 147   1      
 148   1              SFRPAGE = UART0_PAGE;
 149   1      
 150   1              if(RI0 == 1)                                                                                    // There is a char in SBUF
 151   1              {
 152   2              RI0 = 0;                                                                                        // Clear interrupt flag
 153   2      
 154   2              tsByte = SBUF0;                                                                         // Read a character from UART
 155   2      
 156   2              if(tsRxIn < RX_BUFFER_SIZE)                                                                                             // If buffer size is within limit
 157   2              {
 158   3                      if(tsByte != '\r')                                                                                                      // Check end of a command from touch screen
 159   3                              {
 160   4                                      tsRxBuffer[tsRxIn] = tsByte;                                                                    // Store a character in software buffer
 161   4                                      tsRxIn++;                                                                                                               // Increment index
 162   4                              }
 163   3                      else                                                                                                                            // If it is CR character, it marks end of command
 164   3                              {                                                                                                                               
 165   4                                      if(tsRxBuffer[0] == '{')
 166   4                                      {
 167   5                                              if(tsRxBuffer[1] == 'c' && tsRxBuffer[2] == 'm' && tsRxBuffer[3] == 'p' && tsRxBuffer[4] == 'e' && ts
             -RxBuffer[5] == '}')
C51 COMPILER V9.56.0.0   MAIN                                                              10/31/2017 19:33:32 PAGE 4   

 168   5                                              {
 169   6                                                      splashEnd = 1;                                          // Detect end of splash screen
 170   6                                                      screenReset = 1;                                                                                // Screen was reset, so touch screen sends {babe\r}
 171   6                                              }
 172   5                                              else
 173   5                                              {
 174   6                                                      splashEnd = 0;                                          // End of splash screen NOT detected
 175   6                                                      screenReset = 0;                                                                        
 176   6                                              }
 177   5                                      }
 178   4                                      else if(tsRxBuffer[0] == '(')                                                                   // It is a command from touch screen controller
 179   4                                      {                                                                                                                               // A command starts with '('
 180   5                                              for(i = 0; i < tsRxIn; i++)
 181   5                                              {
 182   6                                                      userCommand[i] = tsRxBuffer[i];                                                 // Copy to command array for later evaluation
 183   6                                              }
 184   5      
 185   5                                              ackFromScreen = 0;                                                                                      // This is a command, NOT an ACK
 186   5                                              tsCommandReceived = 1;                                                                          // Set flag when a complete command is received
 187   5                                      }
 188   4                                      else                                                                                                                    // Not a command from touch screen controller
 189   4                                      {
 190   5                                              ackFromScreen = 1;                                                                                      // Set a flag to indicate it is an ACK from screen
 191   5                                              tsCommandReceived = 0;                                                                          // No need to set flag because it is not a command
 192   5                                      }
 193   4      
 194   4                                      for(i = 0; i < tsRxIn; i++)
 195   4                                      {
 196   5                                              tsRxBuffer[i] = '\0';                                                                           // Delete all contents
 197   5                                      }
 198   4                                      
 199   4                                      tsRxOut = 0;                                                                                                    // Reset index Out
 200   4                                      tsRxIn = 0;                                                                                                             // Reset index In
 201   4                              }       
 202   3              }
 203   2                      else                                                                                                                                    // Reset all indexes
 204   2                      {       
 205   3                              while(tsRxOut < tsRxIn)
 206   3                              {
 207   4                                      tsRxBuffer[tsRxOut] = '\0';
 208   4                                      tsRxOut++;
 209   4                              }
 210   3                              tsRxOut = 0;
 211   3                              tsRxIn = 0;
 212   3                              tsCommandReceived = 0;
 213   3                      }
 214   2         }
 215   1      
 216   1         if(TI0 == 1)                                                                                                 // Check if one character is successfully sent out
 217   1         {
 218   2              TI0 = 0;                                                                                        // Clear interrupt flag
 219   2      
 220   2                      if(tsTxEmpty == 0)                                                                                                              // TX buffer has something to send
 221   2                      {
 222   3                              SBUF0 = tsTxBuffer[tsTxOut];                                                                            // Send a character in TX buffer
 223   3                              tsTxOut++;                                                                                                                      // Move to next character
 224   3      
 225   3                              while(TI0 == 0 && txWaitCounter++ < TX_WAIT_LIMIT);                                     // Wait until completion of transmission TI0 = 
             -1
 226   3                              if(txWaitCounter >= TX_WAIT_LIMIT)
 227   3                              {
 228   4                                      TI0 = 1;                                                                                                                // TI0 is not set by hardware, set it by software
C51 COMPILER V9.56.0.0   MAIN                                                              10/31/2017 19:33:32 PAGE 5   

 229   4                              }                                                                                                                                       // When TI0 is set to 1, this ISR is executed again
 230   3                              
 231   3                              txWaitCounter = 0;                                                                                                      // Reset counter for next execution     
 232   3      
 233   3                              if(tsTxOut >= TX_BUFFER_SIZE)
 234   3                              {
 235   4                                      tsTxOut = 0;                                                                                                    // Reset index to 0
 236   4                              }                                                               
 237   3      
 238   3                              if(tsTxOut == tsTxIn)                                                                                           // If two indexes are equal
 239   3                              {
 240   4                                      tsTxEmpty = 1;                                                                                                  // No more character in buffer. Empty
 241   4                              }
 242   3                      }
 243   2                      else
 244   2                      {
 245   3                              tsLastCharGone = 1;                                                                                                     // Last character has gone. Buffer is empty
 246   3                      }
 247   2              }
 248   1              
 249   1              SFRPAGE = SFRPAGE_SAVE;                                                                         // Restore SFR page detector
 250   1      }
 251          
 252          //-------------------------------------------------------------------------------------------------------
 253          // Function Name: sendCommand
 254          // Return Value: None 
 255          // Parmeters: s (a string to send)
 256          // Function Description: This function sends a command from the touch screen
 257          //-------------------------------------------------------------------------------------------------------
 258          void sendCommand(const char * s)
 259          {       
 260   1              char SFRPAGE_SAVE = SFRPAGE;
 261   1              
 262   1              while(*s != '\0')                                                                                                                       // Search for end of touch screen command in buffer
 263   1          {
 264   2              if(tsTxEmpty == 1 || (tsTxOut != tsTxIn))                                                               // Tx is empty or two indexes are not equal
 265   2                      {
 266   3                              tsTxBuffer[tsTxIn++] = *s;
 267   3                              if(tsTxIn >= TX_BUFFER_SIZE)                                                                            // Check for limit
 268   3                              {
 269   4                                      tsTxIn = 0;                                                                                                             // Reset if limit reached
 270   4                              }
 271   3      
 272   3                              if(tsTxEmpty == 1)                                                                                                      // If buffer is empty
 273   3                              {
 274   4                                      tsTxEmpty = 0;                                                                                                  // Now buffer has at leat 1 character, set flag
 275   4                              }
 276   3                      }
 277   2              
 278   2                      s++;                                                                                                                                    // Point to next char to send out
 279   2          }
 280   1                                                                                                                                                                      
 281   1              if(tsLastCharGone == 1)                                                                                                         // All characters in buffer has sent out
 282   1              {
 283   2                      tsLastCharGone = 0;                                                                                                             // Reset flag to indicate no char left in buffer
 284   2                      SFRPAGE = UART0_PAGE;                                                                                                                                                   
 285   2                      TI0 = 1;                                                                        // Set this flage to call ISR to send 
             -out one character
 286   2              }                                                                                                                                                       
 287   1                                                                                                                                                                      
 288   1              SFRPAGE = SFRPAGE_SAVE;                                                                 // Restore SFRPAGE
 289   1      }
C51 COMPILER V9.56.0.0   MAIN                                                              10/31/2017 19:33:32 PAGE 6   

 290          
 291          const char code * Font[] = { "m10B",    ///< Font size 0 
 292                                       "m12B",    ///< Font size 1 
 293                                       "m14B",    ///< Font size 2 
 294                                       "m16B",    ///< Font size 3 
 295                                       "m20B",    ///< Font size 4 
 296                                       "m24B",    ///< Font size 5 
 297                                       "m32B",    ///< Font size 6 
 298                                       "m48B",    ///< Font size 7 
 299                                       "m64B"};   ///< Font size 8
 300          
 301          
 302          void display_text(const char * fg, const char * bg, const unsigned char size, const char * message, const 
             -int x, const int y)
 303          {
 304   1          char str[256] = { 0 };
 305   1          
 306   1          int i = 0;
 307   1          while(i < 10000) i++;
 308   1              
 309   1          sprintf(str, "S %s %s\r", fg, bg);
 310   1          sendCommand(str);
 311   1          sprintf(str, "f %s\r", Font[size]);
 312   1          sendCommand(str);
 313   1          sprintf(str, "t \"%s\" %u %u\r", message, x, y);
 314   1          sendCommand(str);
 315   1      }
 316          
 317          static void display_image(const unsigned int image_num, const int x, const int y)
 318          {
 319   1          char str[32] = { 0 };
 320   1          
 321   1          int i = 0;
 322   1          while(i < 10000) i++;
 323   1              
 324   1          sprintf(str, "xi %u %u %u\r", image_num, x, y);
 325   1          sendCommand(str);
 326   1      }
 327          
 328          static void send_macro(const unsigned int macro_index)
 329          {
 330   1          char str[8] = { 0 };
 331   1          
 332   1          int i = 0;
 333   1          while(i < 10000) i++;
 334   1              
 335   1          sprintf(str, "m %u\r", macro_index);
 336   1          sendCommand(str);
 337   1      }
 338          
 339          void displayText(const char* fg, const char* bg, const unsigned char size, const char* message, const unsi
             -gned int x, const unsigned int y)
 340          {
 341   1              char str[TX_BUFFER_SIZE];                                                                                                       // String
 342   1      
 343   1              //delay(5);                                                                                                                                     // Do not remove this delay
 344   1                      
 345   1              sprintf(str, "S %s %s\r", fg, bg);                                                                                      // Set forground and background color
 346   1              sendCommand(str);                                                                                                               
 347   1              sprintf(str, "f %s\r", Font[size]);                                                                                     // Set text font
 348   1              sendCommand(str);                                                                                                               
 349   1              sprintf(str, "t \"%s\" %u %u\r", message, x, y);                                                        // Display text
C51 COMPILER V9.56.0.0   MAIN                                                              10/31/2017 19:33:32 PAGE 7   

 350   1              sendCommand(str);                                                                                                               
 351   1      }
 352          /*
 353          void showBitmap(const unsigned int index, const unsigned int x, const unsigned int y)
 354          {
 355                  char str[TX_BUFFER_SIZE];
 356          
 357                  sprintf(str, "xi %u %u %u\r", index, x, y);                                                                     // Bitmap index
 358                  sendCommand(str);
 359          }
 360          
 361          void changeScreen(const unsigned char screenIndex)
 362          {
 363                  callMacro(screenIndex);                                                                                                         // Change screen                
 364          }
 365          
 366          void callMacro(const unsigned int macroNumber)
 367          {
 368                  char str[TX_BUFFER_SIZE];
 369          
 370                  sprintf(str, "m %u\r", macroNumber);                                                                            // Execute macro number
 371                  sendCommand(str);
 372          }
 373          */
 374          
 375          int main()
 376          {
 377   1              int i = 0;
 378   1          char str[64];
 379   1          
 380   1          //disableWatchdog();
 381   1          systemClockInit();
 382   1              portInit();
 383   1              enableInterrupts();
 384   1              uart0Init();
 385   1          tsLastCharGone = 1;
 386   1          tsTxOut = tsTxIn = 0;
 387   1          tsTxEmpty = 1;
 388   1          
 389   1          //send_macro(Splash);
 390   1          
 391   1              while(1)
 392   1              {
 393   2                      sprintf(str, "z\r");
 394   2              sendCommand(str);
 395   2              
 396   2              i = 0;
 397   2              
 398   2              while(i < 10000)
 399   2                  i++;
 400   2              
 401   2              //sprintf(str, "t \"San Jose State University, 1234\" 100 100\r");
 402   2              //sendCommand(str);
 403   2              
 404   2              display_text("FFFFFF", "000000", 2, "SJSU", 100, 100);
 405   2              
 406   2              //if (splashEnd) 
 407   2              //{
 408   2              //send_macro(display_home);
 409   2              //}
 410   2              
 411   2              i = 0;
C51 COMPILER V9.56.0.0   MAIN                                                              10/31/2017 19:33:32 PAGE 8   

 412   2              
 413   2              while(i < 10000)
 414   2                  i++;
 415   2              }
 416   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1565    ----
   CONSTANT SIZE    =    411    ----
   XDATA SIZE       =    795     660
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      8    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)

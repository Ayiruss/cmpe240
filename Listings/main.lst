C51 COMPILER V9.56.0.0   MAIN                                                              10/31/2017 20:24:37 PAGE 1   


C51 COMPILER V9.56.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE main.c LARGE OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listing
                    -s\main.lst) OBJECT(.\Objects\main.obj)

line level    source

   1          #include <c8051f120.h>
   2          #include <stdio.h> 
   3          #include <stdlib.h>
   4          #include <math.h>
   5          #include <string.h>
   6          #include <absacc.h>
   7          
   8          #include "macros.h"
   9          #include "laser.h"
  10          #include "motor.h"
  11          
  12          #define     SYSTEM_CLOCK                24500000
  13          #define         BAUD_RATE                           115200
  14          #define         RX_BUFFER_SIZE              256
  15          #define         TX_BUFFER_SIZE              256
  16          
  17          #define         TX_WAIT_LIMIT                           100 * (SYSTEM_CLOCK / 1000000)          // Waiting limit for TI0 and TI1 flags to be set
             - (10 microseconds max)
  18          #define         RX_WAIT_LIMIT                           100 * (SYSTEM_CLOCK / 1000000)          // Waiting limit for TI0 and TI1 flags to be set
             - (10 microseconds max)
  19          
  20          sfr16           RCAP2                                           = 0xCA;                                         // Timer 2 capture/reload
  21          sfr16           TMR2                                            = 0xCC;                                 // Timer 2
  22          sfr16           RCAP3                                           = 0xCA;                             // Timer 3 reload registers
  23          sfr16           TMR3                                            = 0xCC;                             // Timer 3 counter registers
  24          sfr16           RCAP4                                           = 0xCA;                             // Timer 3 reload registers
  25          sfr16           TMR4                                            = 0xCC;                                                         // Timer 4
  26          sfr16           DAC0                                            = 0xD2;                                         // DAC0 data
  27          sfr16           DAC1                                            = 0xD2;                                         // DAC1 data
  28          sfr16           ADC0                                            = 0xBE;                                         // ADC0 data
  29          sfr16           PCA0                                            = 0xF9;                                                         // PCA register
  30          
  31          #define         INTERRUPT_Timer_0                       1
  32          #define         INTERRUPT_Timer_1                       3
  33          #define         INTERRUPT_UART_0                        4
  34          #define         INTERRUPT_Timer_2                       5
  35          #define         INTERRUPT_SMB                           7
  36          #define         INTERRUPT_CPA                           9
  37          #define         INTERRUPT_COMP0_FALLING         10
  38          #define         INTERRUPT_COMP0_RISING          11
  39          #define         INTERRUPT_COMP1_FALLING         12
  40          #define         INTERRUPT_COMP1_RISING          13
  41          #define         INTERRUPT_Timer_3                       14
  42          #define         INTERRUPT_Timer_4                       16
  43          #define         INTERRUPT_ADC_0                         15
  44          #define         INTERRUPT_ADC_2                         18
  45          #define         INTERRUPT_UART_1                        20
  46          
  47          //-------------------------------------------------------------------------------------------------------
  48          // Global Declarations
  49          //-------------------------------------------------------------------------------------------------------
  50          unsigned char tsByte;
  51          
  52          bit splashEnd = 0;
C51 COMPILER V9.56.0.0   MAIN                                                              10/31/2017 20:24:37 PAGE 2   

  53          bit screenReset = 0;
  54          bit ackFromScreen = 0;
  55          bit tsCommandReceived = 0;
  56          bit tsCommandTransmitted = 0;
  57          
  58          unsigned char tsRxBuffer[RX_BUFFER_SIZE];
  59          unsigned char tsTxBuffer[TX_BUFFER_SIZE];
  60          unsigned char userCommand[RX_BUFFER_SIZE];
  61          
  62          unsigned int tsRxIn;
  63          unsigned int tsRxOut; 
  64          unsigned int tsTxIn;
  65          unsigned int tsTxOut;
  66          
  67          bit tsRxEmpty;
  68          bit tsTxEmpty;
  69          bit tsLastCharGone;                                             
  70          
  71          void systemClockInit(void)
  72          {
  73   1          char SFRPAGE_SAVE = SFRPAGE;                                                                                        // Save Current SFR page
  74   1              int i = 0;
  75   1          
  76   1              SFRPAGE  = CONFIG_PAGE;
  77   1              
  78   1          OSCICN    = 0x83;
  79   1      
  80   1              SFRPAGE = SFRPAGE_SAVE;                                                                                         // Restore SFRPAGE
  81   1      }
  82          
  83          void portInit(void)
  84          {
  85   1              char SFRPAGE_SAVE = SFRPAGE;                                                            // Save Current SFR page
  86   1      
  87   1              SFRPAGE = CONFIG_PAGE;                                                                  // Set SFR page
  88   1      
  89   1              XBR0 = 0x2F;                                                                                                                            // Enable UART0, UART1, SPI0, SMB, CEX0 - CEX4                                                                                                                                                  
  90   1              XBR1 = 0x01;                                                                            
  91   1          XBR2 = 0xC4;                                                                                                                                // Enable crossbar and disable weak pull-up                                                                                             
  92   1          
  93   1              P0MDOUT = 0x01;                                                                                 // Set TX0 pin to push-pull
  94   1                                                                                                                                                                      // TX0 = P0.0; RX0 = P0.1
  95   1              P0 = 0xFF;                                                                                                                                      // Initialize port P0 latch
  96   1              P1 = 0xFF;                                                                                                                                      // Initialize port P1 latch
  97   1              P2 = 0xFF;                                                                                                                                      // Initialize port P2 latch
  98   1              P3 = 0xFF;                                                                                                                                      // Initialize port P3 latch
  99   1              P4 = 0xFF;                                                                                                                                      // Initialize port P4 latch
 100   1              P5 = 0xFF;                                                                                                                                      // Initialize port P5 latch
 101   1              P6 = 0xFF;                                                                                                                                      // Initialize port P6 latch
 102   1              P7 = 0xFF;                                                                                                                                      // Initialize port P7 latch
 103   1      
 104   1          SFRPAGE = SFRPAGE_SAVE;                                                                     // Restore SFR page
 105   1      }
 106          
 107          void enableInterrupts(void)
 108          {
 109   1              IE = 0x92;                                                                                                                                      // Enable all interrupts + UART0 + Timer 0
 110   1      }
 111          
 112          void uart0Init(void)
 113          {
 114   1         char SFRPAGE_SAVE;
C51 COMPILER V9.56.0.0   MAIN                                                              10/31/2017 20:24:37 PAGE 3   

 115   1      
 116   1         SFRPAGE_SAVE = SFRPAGE;                                                                      // Preserve SFRPAGE
 117   1      
 118   1         SFRPAGE = TMR2_PAGE;
 119   1         TMR2CN = 0x00;                                                                               // Stop timer. Timer 2 in 16-bit auto-
             -reload up timer mode
 120   1         TMR2CF = 0x08;                                                                               // SYSCLK is time base; no output; up 
             -count only
 121   1         RCAP2L = 0xF3;                                                               // Low byte
 122   1         RCAP2H = 0xFF;                                                               // High byte
 123   1         TMR2 = RCAP2;                                                                // Load 16 bit reload valu
             -e into timer 2
 124   1         TMR2CN = 0x04;                                                               // Enable timer 2 (Start t
             -imer 2)
 125   1      
 126   1         SFRPAGE = UART0_PAGE;
 127   1         SCON0 = 0x50;                                                                                // 8-bit variable baud rate; 9th bit i
             -gnored; RX enabled
 128   1         SSTA0 = 0x05;                                                                                // Enable baud rate                   
             -                                                                      
 129   1                                                                                                      // Use timer 2 as RX and TX baud rate 
             -source
 130   1         IE = 0x90;                                                                   // Enable all interrupts a
             -nd UART0 Interrupt
 131   1      
 132   1         SFRPAGE = SFRPAGE_SAVE;                                                                      // Restore SFRPAGE
 133   1      }
 134          
 135          void disableWatchdog(void)
 136          {
 137   1          WDTCN = 0xDE;                                                    
 138   1          // Disable watchdog timer
 139   1          WDTCN = 0xAD;
 140   1      }
 141              
 142          void uart0Interrupt(void) interrupt INTERRUPT_UART_0 using 2
 143          {
 144   1              char SFRPAGE_SAVE = SFRPAGE;
 145   1              unsigned int i = 0;
 146   1              unsigned long txWaitCounter = 0;
 147   1      
 148   1              SFRPAGE = UART0_PAGE;
 149   1      
 150   1              if(RI0 == 1)                                                                                    // There is a char in SBUF
 151   1              {
 152   2              RI0 = 0;                                                                                        // Clear interrupt flag
 153   2      
 154   2              tsByte = SBUF0;                                                                         // Read a character from UART
 155   2      
 156   2              if(tsRxIn < RX_BUFFER_SIZE)                                                                                             // If buffer size is within limit
 157   2              {
 158   3                      if(tsByte != '\r')                                                                                                      // Check end of a command from touch screen
 159   3                              {
 160   4                                      tsRxBuffer[tsRxIn] = tsByte;                                                                    // Store a character in software buffer
 161   4                                      tsRxIn++;                                                                                                               // Increment index
 162   4                              }
 163   3                      else                                                                                                                            // If it is CR character, it marks end of command
 164   3                              {                                                                                                                               
 165   4                                      if(tsRxBuffer[0] == '{')
 166   4                                      {
 167   5                                              if(tsRxBuffer[1] == 'c' && tsRxBuffer[2] == 'm' && tsRxBuffer[3] == 'p' && tsRxBuffer[4] == 'e' && ts
             -RxBuffer[5] == '}')
C51 COMPILER V9.56.0.0   MAIN                                                              10/31/2017 20:24:37 PAGE 4   

 168   5                                              {
 169   6                                                      splashEnd = 1;                                          // Detect end of splash screen
 170   6                                                      screenReset = 1;                                                                                // Screen was reset, so touch screen sends {babe\r}
 171   6                                              }
 172   5                                              else
 173   5                                              {
 174   6                                                      splashEnd = 0;                                          // End of splash screen NOT detected
 175   6                                                      screenReset = 0;                                                                        
 176   6                                              }
 177   5                                      }
 178   4                                      else if(tsRxBuffer[0] == 'x')                                                                   // It is a command from touch screen controller
 179   4                                      {                                                                                                                               // A command starts with '('
 180   5                                              for(i = 0; i < tsRxIn; i++)
 181   5                                              {
 182   6                                                      userCommand[i] = tsRxBuffer[i];                                                 // Copy to command array for later evaluation
 183   6                                              }
 184   5      
 185   5                                              ackFromScreen = 0;                                                                                      // This is a command, NOT an ACK
 186   5                                              tsCommandReceived = 1;                                                                          // Set flag when a complete command is received
 187   5                                      }
 188   4                                      else if(tsRxBuffer[0] == '(')                                                                   // It is a command from touch screen controller
 189   4                                      {                                                                                                                               // A command starts with '('
 190   5                                              for(i = 0; i < tsRxIn; i++)
 191   5                                              {
 192   6                                                      userCommand[i] = tsRxBuffer[i];                                                 // Copy to command array for later evaluation
 193   6                                              }
 194   5      
 195   5                                              ackFromScreen = 0;                                                                                      // This is a command, NOT an ACK
 196   5                                              tsCommandReceived = 1;                                                                          // Set flag when a complete command is received
 197   5                                      }
 198   4                                      else                                                                                                                    // Not a command from touch screen controller
 199   4                                      {
 200   5                                              ackFromScreen = 1;                                                                                      // Set a flag to indicate it is an ACK from screen
 201   5                                              tsCommandReceived = 0;                                                                          // No need to set flag because it is not a command
 202   5                                      }
 203   4      
 204   4                                      for(i = 0; i < tsRxIn; i++)
 205   4                                      {
 206   5                                              tsRxBuffer[i] = '\0';                                                                           // Delete all contents
 207   5                                      }
 208   4                                      
 209   4                                      tsRxOut = 0;                                                                                                    // Reset index Out
 210   4                                      tsRxIn = 0;                                                                                                             // Reset index In
 211   4                              }       
 212   3              }
 213   2                      else                                                                                                                                    // Reset all indexes
 214   2                      {       
 215   3                              while(tsRxOut < tsRxIn)
 216   3                              {
 217   4                                      tsRxBuffer[tsRxOut] = '\0';
 218   4                                      tsRxOut++;
 219   4                              }
 220   3                              tsRxOut = 0;
 221   3                              tsRxIn = 0;
 222   3                              tsCommandReceived = 0;
 223   3                      }
 224   2         }
 225   1      
 226   1         if(TI0 == 1)                                                                                                 // Check if one character is successfully sent out
 227   1         {
 228   2              TI0 = 0;                                                                                        // Clear interrupt flag
 229   2      
C51 COMPILER V9.56.0.0   MAIN                                                              10/31/2017 20:24:37 PAGE 5   

 230   2                      if(tsTxEmpty == 0)                                                                                                              // TX buffer has something to send
 231   2                      {
 232   3                              SBUF0 = tsTxBuffer[tsTxOut];                                                                            // Send a character in TX buffer
 233   3                              tsTxOut++;                                                                                                                      // Move to next character
 234   3      
 235   3                              while(TI0 == 0 && txWaitCounter++ < TX_WAIT_LIMIT);                                     // Wait until completion of transmission TI0 = 
             -1
 236   3                              if(txWaitCounter >= TX_WAIT_LIMIT)
 237   3                              {
 238   4                                      TI0 = 1;                                                                                                                // TI0 is not set by hardware, set it by software
 239   4                              }                                                                                                                                       // When TI0 is set to 1, this ISR is executed again
 240   3                              
 241   3                              txWaitCounter = 0;                                                                                                      // Reset counter for next execution     
 242   3      
 243   3                              if(tsTxOut >= TX_BUFFER_SIZE)
 244   3                              {
 245   4                                      tsTxOut = 0;                                                                                                    // Reset index to 0
 246   4                              }                                                               
 247   3      
 248   3                              if(tsTxOut == tsTxIn)                                                                                           // If two indexes are equal
 249   3                              {
 250   4                                      tsTxEmpty = 1;                                                                                                  // No more character in buffer. Empty
 251   4                              }
 252   3                      }
 253   2                      else
 254   2                      {
 255   3                              tsLastCharGone = 1;                                                                                                     // Last character has gone. Buffer is empty
 256   3                      }
 257   2              }
 258   1              
 259   1              SFRPAGE = SFRPAGE_SAVE;                                                                         // Restore SFR page detector
 260   1      }
 261          
 262          //-------------------------------------------------------------------------------------------------------
 263          // Function Name: sendCommand
 264          // Return Value: None 
 265          // Parmeters: s (a string to send)
 266          // Function Description: This function sends a command from the touch screen
 267          //-------------------------------------------------------------------------------------------------------
 268          void sendCommand(const char * s)
 269          {       
 270   1              char SFRPAGE_SAVE = SFRPAGE;
 271   1              
 272   1              while(*s != '\0')                                                                                                                       // Search for end of touch screen command in buffer
 273   1          {
 274   2              if(tsTxEmpty == 1 || (tsTxOut != tsTxIn))                                                               // Tx is empty or two indexes are not equal
 275   2                      {
 276   3                              tsTxBuffer[tsTxIn++] = *s;
 277   3                              if(tsTxIn >= TX_BUFFER_SIZE)                                                                            // Check for limit
 278   3                              {
 279   4                                      tsTxIn = 0;                                                                                                             // Reset if limit reached
 280   4                              }
 281   3      
 282   3                              if(tsTxEmpty == 1)                                                                                                      // If buffer is empty
 283   3                              {
 284   4                                      tsTxEmpty = 0;                                                                                                  // Now buffer has at leat 1 character, set flag
 285   4                              }
 286   3                      }
 287   2              
 288   2                      s++;                                                                                                                                    // Point to next char to send out
 289   2          }
 290   1                                                                                                                                                                      
C51 COMPILER V9.56.0.0   MAIN                                                              10/31/2017 20:24:37 PAGE 6   

 291   1              if(tsLastCharGone == 1)                                                                                                         // All characters in buffer has sent out
 292   1              {
 293   2                      tsLastCharGone = 0;                                                                                                             // Reset flag to indicate no char left in buffer
 294   2                      SFRPAGE = UART0_PAGE;                                                                                                                                                   
 295   2                      TI0 = 1;                                                                        // Set this flage to call ISR to send 
             -out one character
 296   2              }                                                                                                                                                       
 297   1                                                                                                                                                                      
 298   1              SFRPAGE = SFRPAGE_SAVE;                                                                 // Restore SFRPAGE
 299   1      }
 300          
 301          const char code * Font[] = { "m10B",    ///< Font size 0 
 302                                       "m12B",    ///< Font size 1 
 303                                       "m14B",    ///< Font size 2 
 304                                       "m16B",    ///< Font size 3 
 305                                       "m20B",    ///< Font size 4 
 306                                       "m24B",    ///< Font size 5 
 307                                       "m32B",    ///< Font size 6 
 308                                       "m48B",    ///< Font size 7 
 309                                       "m64"};    ///< Font size 8
 310          
 311          
 312          void display_text(const char * fg, const char * bg, const unsigned char size, const char * message, const 
             -int x, const int y)
 313          {
 314   1          char str[256] = { 0 };
 315   1          
 316   1          int i = 0;
 317   1          while(i < 10000) i++;
 318   1              
 319   1          sprintf(str, "S %s %s\r", fg, bg);
 320   1          sendCommand(str);
 321   1          sprintf(str, "f %s\r", Font[size]);
 322   1          sendCommand(str);
 323   1          sprintf(str, "t \"%s\" %u %u\r", message, x, y);
 324   1          sendCommand(str);
 325   1      }
 326          
 327          static void display_image(const unsigned int image_num, const int x, const int y)
 328          {
 329   1          char str[32] = { 0 };
 330   1          
 331   1          int i = 0;
 332   1          while(i < 10000) i++;
 333   1              
 334   1          sprintf(str, "xi %u %u %u\r", image_num, x, y);
 335   1          sendCommand(str);
 336   1      }
 337          
 338          static void send_macro(const unsigned int macro_index)
 339          {
 340   1          char str[8] = { 0 };
 341   1          
 342   1          int i = 0;
 343   1          while(i < 10000) i++;
 344   1              
 345   1          sprintf(str, "m %u\r", macro_index);
 346   1          sendCommand(str);
 347   1      }
 348          
 349          void displayText(const char* fg, const char* bg, const unsigned char size, const char* message, const unsi
             -gned int x, const unsigned int y)
C51 COMPILER V9.56.0.0   MAIN                                                              10/31/2017 20:24:37 PAGE 7   

 350          {
 351   1              char str[TX_BUFFER_SIZE];                                                                                                       // String
 352   1      
 353   1              //delay(5);                                                                                                                                     // Do not remove this delay
 354   1                      
 355   1              sprintf(str, "S %s %s\r", fg, bg);                                                                                      // Set forground and background color
 356   1              sendCommand(str);                                                                                                               
 357   1              sprintf(str, "f %s\r", Font[size]);                                                                                     // Set text font
 358   1              sendCommand(str);                                                                                                               
 359   1              sprintf(str, "t \"%s\" %u %u\r", message, x, y);                                                        // Display text
 360   1              sendCommand(str);                                                                                                               
 361   1      }
 362          /*
 363          void showBitmap(const unsigned int index, const unsigned int x, const unsigned int y)
 364          {
 365                  char str[TX_BUFFER_SIZE];
 366          
 367                  sprintf(str, "xi %u %u %u\r", index, x, y);                                                                     // Bitmap index
 368                  sendCommand(str);
 369          }
 370          
 371          void changeScreen(const unsigned char screenIndex)
 372          {
 373                  callMacro(screenIndex);                                                                                                         // Change screen                
 374          }
 375          
 376          void callMacro(const unsigned int macroNumber)
 377          {
 378                  char str[TX_BUFFER_SIZE];
 379          
 380                  sprintf(str, "m %u\r", macroNumber);                                                                            // Execute macro number
 381                  sendCommand(str);
 382          }
 383          */
 384          int main()
 385          {
 386   1              int i = 0;
 387   1          char str[64];
 388   1          
 389   1          disableWatchdog();
 390   1          systemClockInit();
 391   1              portInit();
 392   1              enableInterrupts();
 393   1              uart0Init();
 394   1          tsLastCharGone = 1;
 395   1          tsTxOut = tsTxIn = 0;
 396   1          tsTxEmpty = 1;
 397   1          
 398   1              sprintf(str, "z\r");
 399   1          sendCommand(str);
 400   1          
 401   1          send_macro(display_temperature);
 402   1          
 403   1          while(1)
 404   1              {
 405   2                      //sprintf(str, "z\r");
 406   2              //sendCommand(str);
 407   2              
 408   2              i = 0;
 409   2              
 410   2              while(i < 10000)
 411   2                  i++;
C51 COMPILER V9.56.0.0   MAIN                                                              10/31/2017 20:24:37 PAGE 8   

 412   2              
 413   2              //sprintf(str, "t \"San Jose State University, 1234\" 100 100\r");
 414   2              //sendCommand(str);
 415   2              
 416   2              //display_text("FFFFFF", "000000", 2, "SJSU", 100, 100);
 417   2              
 418   2              //if (splashEnd) 
 419   2              //{
 420   2              
 421   2              //}
 422   2              
 423   2              if (tsCommandReceived) 
 424   2              {
 425   3                  if ('1' == userCommand[1] && '2' == userCommand[2] && '9' == userCommand[3]) {
 426   4                      display_text("FFFFFF", "000000", 8, "32F", 240, 110);
 427   4                  }
 428   3                  else if ('1' == userCommand[1] && '3' == userCommand[2] && '0' == userCommand[3]) {
 429   4                      display_text("FFFFFF", "000000", 8, "32C", 240, 110);
 430   4                  }
 431   3                  else {
 432   4                      // noop
 433   4                  }
 434   3              }
 435   2              
 436   2              i = 0;
 437   2              
 438   2              while(i < 10000)
 439   2                  i++;
 440   2              }
 441   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1743    ----
   CONSTANT SIZE    =    413    ----
   XDATA SIZE       =    795     662
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      8    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)

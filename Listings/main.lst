C51 COMPILER V9.56.0.0   MAIN                                                              11/21/2017 19:11:10 PAGE 1   


C51 COMPILER V9.56.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE main.c LARGE OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listing
                    -s\main.lst) TABS(2) OBJECT(.\Objects\main.obj)

line level    source

   1          #include <main.h>
   2          #include "macros.h"
   3          
   4          //-------------------------------------------------------------------------------------------------------
   5          // Global Declarations
   6          //-------------------------------------------------------------------------------------------------------
   7          unsigned char tsByte;
   8          //unsigned char passcode[4][3] = {"140", "141", "142","143"}; 
   9          
  10          
  11          
  12          bit splashEnd = 0;
  13          bit screenReset = 0;
  14          bit ackFromScreen = 0;
  15          bit tsCommandReceived = 0;
  16          bit tsCommandTransmitted = 0;
  17          bit SMB_RW;                                                                     // Software flag to indica
             -te Read or Write
  18          
  19          
  20          int k = 0;
  21          unsigned char sharedDataRx[SHARED_DATA_MAX];
  22          unsigned char sharedDataTx[SHARED_DATA_MAX];
  23          unsigned char eepromTx[EEPROM_TX_BUFFER];
  24          unsigned char eepromRx[EEPROM_RX_BUFFER];
  25          unsigned char eepromPageTx[EEPROM_PAGE_SIZE];
  26          
  27          unsigned int pageCount;
  28          unsigned int bytesExtra;
  29          unsigned int eepromPageCounter;
  30          unsigned int startAddr;
  31          unsigned char slaveAddr;                                                        // Target SMBus slave addr
             -ess
  32          unsigned char eepromDataByte;
  33          
  34          unsigned int numBytesRD;
  35          unsigned int numBytesWR;
  36          unsigned char slaveWriteDone;
  37          unsigned char slaveReadDone;
  38          unsigned char eepromWriteDone;
  39          unsigned char eepromReaddone;
  40          
  41          unsigned char tsRxBuffer[RX_BUFFER_SIZE];
  42          unsigned char tsTxBuffer[TX_BUFFER_SIZE];
  43          unsigned char userCommand[RX_BUFFER_SIZE];
  44          
  45          unsigned int tsRxIn;
  46          unsigned int tsRxOut; 
  47          unsigned int tsTxIn;
  48          unsigned int tsTxOut;
  49          
  50          bit tsRxEmpty;
  51          bit tsTxEmpty;
  52          bit tsLastCharGone; 
C51 COMPILER V9.56.0.0   MAIN                                                              11/21/2017 19:11:10 PAGE 2   

  53          
  54          bit screenChanged;
  55          unsigned char screen;
  56          unsigned char lastScreen;
  57          
  58          const char code * Font[] = {/*0*/   "m10B", 
  59                                      /*1*/   "m12B",
  60                                      /*2*/   "m14B",
  61                                      /*3*/   "m16B",
  62                                      /*4*/   "m20B",
  63                                      /*5*/   "m24B",
  64                                      /*6*/   "m32B",
  65                                      /*7*/   "m48",
  66                                      /*8*/   "m64"};
  67          
  68          bit SMB_BUSY = 0;                                                               // Set to claim the bus, c
             -lear to free
  69          bit SMB_RW;                                                                     // Software flag to indica
             -te Read or Write
  70          
  71          unsigned int startAddr;
  72          unsigned char slaveAddr;                                                        // Target SMBus slave addr
             -ess
  73          
  74          unsigned int numBytesRD;
  75          unsigned int numBytesWR;
  76          
  77          unsigned char slaveWriteDone;
  78          unsigned char slaveReadDone;
  79                                      
  80          unsigned char roomTemp;
  81          
  82          //-------------------------------------------------------------------------------------------------------
  83          // System Configurations
  84          //-------------------------------------------------------------------------------------------------------
  85          void systemClockInit(void)
  86          {
  87   1          char SFRPAGE_SAVE = SFRPAGE;                                                // Save Current SFR page
  88   1          int i = 0;
  89   1          
  90   1          SFRPAGE  = CONFIG_PAGE;
  91   1          
  92   1          OSCICN    = 0x83;
  93   1      
  94   1          SFRPAGE = SFRPAGE_SAVE;                                                     // Restore SFRPAGE
  95   1      }
  96          
  97          void portInit(void)
  98          {
  99   1          char SFRPAGE_SAVE = SFRPAGE;                                                // Save Current SFR page
 100   1      
 101   1          SFRPAGE = CONFIG_PAGE;                                                      // Set SFR page
 102   1      
 103   1          XBR0 = 0x2F;                                                                // Enable UART0, UART1, SP
             -I0, SMB, CEX0 - CEX4                                                                          
 104   1          XBR1 = 0x01;                                        
 105   1          XBR2 = 0xC4;                                                                // Enable crossbar and dis
             -able weak pull-up                                             
 106   1          
 107   1          P0MDOUT = 0x01;                                                             // Set TX0 pin to push-pul
             -l
 108   1                                                                                      // TX0 = P0.0; RX0 = P0.1
C51 COMPILER V9.56.0.0   MAIN                                                              11/21/2017 19:11:10 PAGE 3   

 109   1          P1MDOUT = 0x01;                                                             // Set TX1 pin to push-pul
             -l, P1.0
 110   1                                                                                      // TX1 = P1.0; RX1 = P1.1
 111   1          P3MDOUT = 0xCA;                                                             // P3.0, P3.2, P3.4, P3.5:
             - open drain; P3.1, P3.3, P3.6, P3.7: push pull
 112   1          
 113   1          P4MDOUT = 0x0F;                                                             // P4.0, P4.1, P4.2, P4.3:
             - push pull
 114   1                                                                                      
 115   1          P5MDOUT = 0x04;                                                             // P5.0 open drain; P5.1 O
             -pen drain; P5.2 Push pull
 116   1          
 117   1          P6MDOUT = 0x00;
 118   1                                                                                                                
             -                                                  
 119   1          P7MDOUT = 0x80;                                                             // Set P7.7 push-pull (smb
             - error line)
 120   1          
 121   1          P0 = 0xFF;                                                                  // Initialize port P0 latc
             -h
 122   1          P1 = 0xFF;                                                                  // Initialize port P1 latc
             -h
 123   1          P2 = 0xFF;                                                                  // Initialize port P2 latc
             -h
 124   1          P3 = 0xFF;                                                                  // Initialize port P3 latc
             -h
 125   1          P4 = 0xFF;                                                                  // Initialize port P4 latc
             -h
 126   1          P5 = 0xFF;                                                                  // Initialize port P5 latc
             -h
 127   1          P6 = 0xFF;                                                                  // Initialize port P6 latc
             -h
 128   1          P7 = 0xFF;                                                                  // Initialize port P7 latc
             -h
 129   1      
 130   1          RHW = 0;                                                                    // Pull low SMB error line
 131   1      
 132   1          SFRPAGE = SFRPAGE_SAVE;                                                     // Restore SFR page
 133   1      }
 134          
 135          void enableInterrupts(void)
 136          {
 137   1          IE = 0x92;                                                                  // Enable all interrupts +
             - UART0 + Timer 0
 138   1          EIE2 |= 0x01;                                                               // Enable Timer 3 interrup
             -t
 139   1          EIE2 |= 0x40;                                                               // Enable UART1 interrupt
 140   1          EIE1 |= 0x0A;                                                               // Enable SMBus interrupt
 141   1      }
 142          
 143          void uart0Init(void)
 144          {
 145   1         char SFRPAGE_SAVE;
 146   1      
 147   1         SFRPAGE_SAVE = SFRPAGE;                                                      // Preserve SFRPAGE
 148   1      
 149   1         SFRPAGE = TMR2_PAGE;
 150   1         TMR2CN = 0x00;                                                               // Stop timer. Timer 2 in 
             -16-bit auto-reload up timer mode
 151   1         TMR2CF = 0x08;                                                               // SYSCLK is time base; no
             - output; up count only
 152   1         RCAP2L = 0xF3;                                                               // Low byte
C51 COMPILER V9.56.0.0   MAIN                                                              11/21/2017 19:11:10 PAGE 4   

 153   1         RCAP2H = 0xFF;                                                               // High byte
 154   1         TMR2 = RCAP2;                                                                // Load 16 bit reload valu
             -e into timer 2
 155   1         TMR2CN = 0x04;                                                               // Enable timer 2 (Start t
             -imer 2)
 156   1      
 157   1         SFRPAGE = UART0_PAGE;
 158   1         SCON0 = 0x50;                                                                // 8-bit variable baud rat
             -e; 9th bit ignored; RX enabled
 159   1         SSTA0 = 0x05;                                                                // Enable baud rate       
             -                                                                  
 160   1                                                                                      // Use timer 2 as RX and T
             -X baud rate source
 161   1         IE = 0x90;                                                                   // Enable all interrupts a
             -nd UART0 Interrupt
 162   1      
 163   1         SFRPAGE = SFRPAGE_SAVE;                                                      // Restore SFRPAGE
 164   1      }
 165          
 166          void disableWatchdog(void)
 167          {
 168   1          WDTCN = 0xDE;                                                               // Disable watchdog timer
 169   1          WDTCN = 0xAD;
 170   1      }
 171          
 172          void uart0Interrupt(void) interrupt INTERRUPT_UART_0 using 2
 173          {
 174   1          char SFRPAGE_SAVE = SFRPAGE;
 175   1          unsigned int i = 0;
 176   1          unsigned long txWaitCounter = 0;
 177   1      
 178   1          SFRPAGE = UART0_PAGE;
 179   1      
 180   1          if(RI0 == 1)                                                                // There is a char in SBUF
 181   1          {
 182   2              RI0 = 0;                                                                // Clear interrupt flag
 183   2      
 184   2              tsByte = SBUF0;                                                         // Read a character from U
             -ART
 185   2      
 186   2              if(tsRxIn < RX_BUFFER_SIZE)                                             // If buffer size is withi
             -n limit
 187   2              {
 188   3                  if(tsByte != '\r')                                                  // Check end of a command 
             -from touch screen
 189   3                  {
 190   4                      tsRxBuffer[tsRxIn] = tsByte;                                    // Store a character in so
             -ftware buffer
 191   4                      tsRxIn++;                                                       // Increment index
 192   4                  }
 193   3                  else                                                                // If it is CR character, 
             -it marks end of command
 194   3                  {                                                               
 195   4                      if(tsRxBuffer[0] == '{')                                        // Splash screen indicator
 196   4                      {
 197   5                          if(tsRxBuffer[1] == 'c' && tsRxBuffer[2] == 'm' && tsRxBuffer[3] == 'p' && tsRxBuffer[
             -4] == 'e' && tsRxBuffer[5] == '}')
 198   5                          {
 199   6                              splashEnd = 1;                                          // Detect end of splash sc
             -reen
 200   6                              screenReset = 1;                                        // Screen was reset, so to
             -uch screen sends {babe\r}
C51 COMPILER V9.56.0.0   MAIN                                                              11/21/2017 19:11:10 PAGE 5   

 201   6                          }
 202   5                          else
 203   5                          {
 204   6                              splashEnd = 0;                                          // End of splash screen NO
             -T detected
 205   6                              screenReset = 0;                                    
 206   6                          }
 207   5                      }
 208   4                      else if(tsRxBuffer[0] == 'x')                                   // It is a command from to
             -uch screen controller
 209   4                      {                                                               // A command starts with '
             -('
 210   5                          for(i = 0; i < tsRxIn; i++)
 211   5                          {
 212   6                              userCommand[i] = tsRxBuffer[i];                         // Copy to command array f
             -or later evaluation
 213   6                          }
 214   5      
 215   5                          ackFromScreen = 0;                                          // This is a command, NOT 
             -an ACK
 216   5                          tsCommandReceived = 1;                                      // Set flag when a complet
             -e command is received
 217   5                      }
 218   4                      else if(tsRxBuffer[0] == '(')                                   // It is a command from to
             -uch screen controller
 219   4                      {                                                               // A command starts with '
             -('
 220   5                          for(i = 0; i < tsRxIn; i++)
 221   5                          {
 222   6                              userCommand[i] = tsRxBuffer[i];                         // Copy to command array f
             -or later evaluation
 223   6                          }
 224   5      
 225   5                          ackFromScreen = 0;                                          // This is a command, NOT 
             -an ACK
 226   5                          tsCommandReceived = 1;                                      // Set flag when a complet
             -e command is received
 227   5                      }
 228   4                      else                                                            // Not a command from touc
             -h screen controller
 229   4                      {
 230   5                          ackFromScreen = 1;                                          // Set a flag to indicate 
             -it is an ACK from screen
 231   5                          tsCommandReceived = 0;                                      // No need to set flag bec
             -ause it is not a command
 232   5                      }
 233   4      
 234   4                      for(i = 0; i < tsRxIn; i++)
 235   4                      {
 236   5                          tsRxBuffer[i] = '\0';                                       // Delete all contents
 237   5                      }
 238   4                      
 239   4                      tsRxOut = 0;                                                    // Reset index Out
 240   4                      tsRxIn = 0;                                                     // Reset index In
 241   4                  }   
 242   3              }
 243   2              else                                                                    // Reset all indexes
 244   2              {   
 245   3                  while(tsRxOut < tsRxIn)
 246   3                  {
 247   4                      tsRxBuffer[tsRxOut] = '\0';
 248   4                      tsRxOut++;
C51 COMPILER V9.56.0.0   MAIN                                                              11/21/2017 19:11:10 PAGE 6   

 249   4                  }
 250   3                  tsRxOut = 0;
 251   3                  tsRxIn = 0;
 252   3                  tsCommandReceived = 0;
 253   3              }
 254   2         }
 255   1      
 256   1         if(TI0 == 1)                                                                 // Check if one character 
             -is successfully sent out
 257   1         {
 258   2              TI0 = 0;                                                                // Clear interrupt flag
 259   2      
 260   2              if(tsTxEmpty == 0)                                                      // TX buffer has something
             - to send
 261   2              {
 262   3                  SBUF0 = tsTxBuffer[tsTxOut];                                        // Send a character in TX 
             -buffer
 263   3                  tsTxOut++;                                                          // Move to next character
 264   3      
 265   3                  while(TI0 == 0 && txWaitCounter++ < TX_WAIT_LIMIT);                 // Wait until completion o
             -f transmission TI0 = 1
 266   3                  if(txWaitCounter >= TX_WAIT_LIMIT)
 267   3                  {
 268   4                      TI0 = 1;                                                        // TI0 is not set by hardw
             -are, set it by software
 269   4                  }                                                                   // When TI0 is set to 1, t
             -his ISR is executed again
 270   3                  
 271   3                  txWaitCounter = 0;                                                  // Reset counter for next 
             -execution 
 272   3      
 273   3                  if(tsTxOut >= TX_BUFFER_SIZE)
 274   3                  {
 275   4                      tsTxOut = 0;                                                    // Reset index to 0
 276   4                  }                               
 277   3      
 278   3                  if(tsTxOut == tsTxIn)                                               // If two indexes are equa
             -l
 279   3                  {
 280   4                      tsTxEmpty = 1;                                                  // No more character in bu
             -ffer. Empty
 281   4                  }
 282   3              }
 283   2              else
 284   2              {
 285   3                  tsLastCharGone = 1;                                                 // Last character has gone
             -. Buffer is empty
 286   3              }
 287   2          }
 288   1          
 289   1          SFRPAGE = SFRPAGE_SAVE;                                                     // Restore SFR page detect
             -or
 290   1      }
 291          
 292          //-------------------------------------------------------------------------------------------------------
 293          // Function Name: sendCommand
 294          // Return Value: None 
 295          // Parmeters: s (a string to send)
 296          // Function Description: This function sends a command from the touch screen
 297          //-------------------------------------------------------------------------------------------------------
 298          void sendCommand(const char * s)
 299          {   
C51 COMPILER V9.56.0.0   MAIN                                                              11/21/2017 19:11:10 PAGE 7   

 300   1          char SFRPAGE_SAVE = SFRPAGE;
 301   1          
 302   1          while(*s != '\0')                                                           // Search for end of touch
             - screen command in buffer
 303   1          {
 304   2              if(tsTxEmpty == 1 || (tsTxOut != tsTxIn))                               // Tx is empty or two inde
             -xes are not equal
 305   2              {
 306   3                  tsTxBuffer[tsTxIn++] = *s;
 307   3                  if(tsTxIn >= TX_BUFFER_SIZE)                                        // Check for limit
 308   3                  {
 309   4                      tsTxIn = 0;                                                     // Reset if limit reached
 310   4                  }
 311   3      
 312   3                  if(tsTxEmpty == 1)                                                  // If buffer is empty
 313   3                  {
 314   4                      tsTxEmpty = 0;                                                  // Now buffer has at leat 
             -1 character, set flag
 315   4                  }
 316   3              }
 317   2              
 318   2              s++;                                                                    // Point to next char to s
             -end out
 319   2          }
 320   1                                                                                      
 321   1          if(tsLastCharGone == 1)                                                     // All characters in buffe
             -r has sent out
 322   1          {
 323   2              tsLastCharGone = 0;                                                     // Reset flag to indicate 
             -no char left in buffer
 324   2              SFRPAGE = UART0_PAGE;                                                                           
 325   2              TI0 = 1;                                                                // Set this flage to call 
             -ISR to send out one character
 326   2          }                                                                           
 327   1                                                                                      
 328   1          SFRPAGE = SFRPAGE_SAVE;                                                     // Restore SFRPAGE
 329   1      }
 330          
 331          //-------------------------------------------------------------------------------------------------------
 332          // Function Name: displayText
 333          // Return Value: None 
 334          // Parmeters: fg, bg, size, message, x, y
 335          // Function Description: This function displays a text on the touch screen
 336          //-------------------------------------------------------------------------------------------------------
 337          void displayText(const char* fg, const char* bg, const unsigned char size, const char* message, const unsi
             -gned int x, const unsigned int y)
 338          {
 339   1          char str[TS_BUFFER_SIZE];                                                   // String
 340   1              
 341   1          sprintf(str, "S %s %s\r", fg, bg);                                          // Set forground and backg
             -round color
 342   1          sendCommand(str);                                                       
 343   1          sprintf(str, "f %s\r", Font[size]);                                         // Set text font
 344   1          sendCommand(str);                                                       
 345   1          sprintf(str, "t \"%s\" %u %u\r", message, x, y);                            // Display text
 346   1          sendCommand(str);                                                       
 347   1      }
 348          
 349          
 350          //-------------------------------------------------------------------------------------------------------
 351          // Function Name: showBitmap
 352          // Return Value: None 
C51 COMPILER V9.56.0.0   MAIN                                                              11/21/2017 19:11:10 PAGE 8   

 353          // Parmeters: index, x, y (bitmap index and coordinates)
 354          // Function Description: This function displays a bitmap image
 355          //-------------------------------------------------------------------------------------------------------
 356          void showBitmap(const unsigned int index, const unsigned int x, const unsigned int y)
 357          {
 358   1          char str[TS_BUFFER_SIZE];
 359   1      
 360   1          sprintf(str, "xi %u %u %u\r", index, x, y);                                 // Bitmap index
 361   1          sendCommand(str);
 362   1      }
 363          
 364          //-------------------------------------------------------------------------------------------------------
 365          // Function Name: changeScreen
 366          // Return Value: None 
 367          // Parmeters: screenIndex (macro number)
 368          // Function Description: This function switches to the new screen
 369          //-------------------------------------------------------------------------------------------------------
 370          void changeScreen(const unsigned char screenIndex)
 371          {
 372   1          callMacro(screenIndex);                                                     // Change screen        
 373   1      }
 374          
 375          //-------------------------------------------------------------------------------------------------------
 376          // Function Name: callMacro
 377          // Return Value: None 
 378          // Parmeters: macroNumber (macro number in the macro file)
 379          // Function Description: This function calls a macro
 380          //-------------------------------------------------------------------------------------------------------
 381          void callMacro(const unsigned int macroNumber)
 382          {
 383   1          char str[TS_BUFFER_SIZE];
 384   1      
 385   1          sprintf(str, "m %u\r", macroNumber);                                        // Execute macro number
 386   1          sendCommand(str);
 387   1      }
 388          
 389          //-------------------------------------------------------------------------------------------------------
 390          // Function Name: scanUserInput
 391          // Return Value: None 
 392          // Parmeters: None
 393          // Function Description: This function processes commands from the touch screen
 394          //-------------------------------------------------------------------------------------------------------
 395          void scanUserInput(void)
 396          {   
 397   1          int i = 0;
 398   1      
 399   1          if(screen == MAIN_PAGE)                                                     // Main screen
 400   1          {        
 401   2              if(userCommand[0] == '(')                                               // Check for an actual com
             -mand followed by this '(' character
 402   2              {
 403   3                  switch (userCommand[1])                                             // Scan a command type
 404   3                  {
 405   4                      case '1':                                                       // Main page
 406   4                          changeScreen(MAIN_PAGE);                                    // Stay in main page if ma
             -in button is pressed again
 407   4                          break;
 408   4                      case '2':                                                       // Settings page
 409   4                          changeScreen(SETTINGS_PAGE);
 410   4                          break;
 411   4                      case '3':                                                       // Service page
 412   4                          changeScreen(SERVICE_PAGE);
C51 COMPILER V9.56.0.0   MAIN                                                              11/21/2017 19:11:10 PAGE 9   

 413   4                          break;
 414   4                      case 'A':
 415   4                          // Call a function here or do something here            
 416   4                          break;
 417   4                      case 'B':
 418   4                          // Call a function here or do something here
 419   4                          break;
 420   4                      case 'C':
 421   4                          // Call a function here or do something here
 422   4                          break;  
 423   4                      default:                                                        // Other options
 424   4                          break;
 425   4                      }
 426   3              }
 427   2              else                                                                    // Not a command, empty bu
             -ffer with null char
 428   2              {
 429   3                  i = 0;
 430   3                  while(userCommand[i] != '\0')
 431   3                  {
 432   4                      userCommand[i] = '\0';
 433   4                      i++;
 434   4                  }
 435   3              }   
 436   2          }
 437   1          else if(screen == SETTINGS_PAGE)                                            // Settings page
 438   1          {
 439   2              if(userCommand[0] == '(')
 440   2              {
 441   3                  switch (userCommand[1])
 442   3                  {
 443   4                      case '1':
 444   4                          changeScreen(MAIN_PAGE);
 445   4                          break;
 446   4                      case '2':
 447   4                          changeScreen(SETTINGS_PAGE);
 448   4                          break;
 449   4                      case '3':
 450   4                          changeScreen(SERVICE_PAGE);
 451   4                          break;
 452   4                      case 'A':
 453   4                          // Call a function here or do something here
 454   4                          break;
 455   4                      case 'B':
 456   4                          // Call a function here or do something here
 457   4                          break;
 458   4                      case 'C':
 459   4                          // Call a function here or do something here
 460   4                          break;
 461   4                      default:
 462   4                          break;
 463   4                  }
 464   3              }
 465   2              else                                                                    // Not a command, empty bu
             -ffer with null
 466   2              {
 467   3                  i = 0;
 468   3                  while(userCommand[i] != '\0')
 469   3                  {
 470   4                      userCommand[i] = '\0';
 471   4                      i++;
 472   4                  }
C51 COMPILER V9.56.0.0   MAIN                                                              11/21/2017 19:11:10 PAGE 10  

 473   3              }               
 474   2          }
 475   1          else if(screen == SERVICE_PAGE)
 476   1          {
 477   2              if(userCommand[0] == '(')
 478   2              {
 479   3                  switch (userCommand[1])
 480   3                  {
 481   4                      case '1':
 482   4                          changeScreen(MAIN_PAGE);
 483   4                          break;
 484   4                      case '2':
 485   4                          changeScreen(SETTINGS_PAGE);
 486   4                          break;
 487   4                      case '3':
 488   4                          changeScreen(SERVICE_PAGE);
 489   4                          break;
 490   4                      case 'A':
 491   4                          // Call a function here or do something here
 492   4                      case 'B':
 493   4                          // Call a function here or do something here
 494   4                      case 'C':
 495   4                          // Call a function here or do something here
 496   4                      default:
 497   4                          break;
 498   4                  }
 499   3              }
 500   2              else                                                                    // Not a command, empty bu
             -ffer with null
 501   2              {                                                           
 502   3                  i = 0;
 503   3                  while(userCommand[i] != '\0')
 504   3                  {
 505   4                      userCommand[i] = '\0';
 506   4                      i++;
 507   4                  }
 508   3              }               
 509   2          }   
 510   1          else
 511   1          {
 512   2      
 513   2          }
 514   1      
 515   1          i = 0;
 516   1          while(userCommand[i] != '\0')
 517   1          {
 518   2              userCommand[i] = '\0';                                                  // Delete all contents in 
             -array
 519   2              i++;
 520   2          }
 521   1      }
 522          
 523          //-------------------------------------------------------------------------------------------------------
 524          // Function Name: smbInit
 525          // Return Value: None 
 526          // Parmeters: None
 527          // Function Description: This function initializes the SMB bus 
 528          //-------------------------------------------------------------------------------------------------------
 529          void smbInit(void)
 530          {
 531   1          int i;
 532   1          unsigned long pollingCounter = 0;
C51 COMPILER V9.56.0.0   MAIN                                                              11/21/2017 19:11:10 PAGE 11  

 533   1          char SFRPAGE_SAVE = SFRPAGE;
 534   1      
 535   1          SFRPAGE = SMB0_PAGE;
 536   1          while(SDA == 0 && pollingCounter++ < SMB_POLLING_LIMIT)                         // If slave is holding
             - SDA low because of error or reset
 537   1          {
 538   2              SCL = 0;                                                                    // Drive the clock low
 539   2              for(i = 0; i < 255; i++);                                                   // Hold the clock low
 540   2              SCL = 1;                                                                    // Release the clock
 541   2              while(SCL == 0 && pollingCounter++ < SMB_POLLING_LIMIT);                    // Wait for open-drain
 542   2              for(i = 0; i < 10; i++);                                                    // Hold the clock high
 543   2          }
 544   1                  
 545   1          SMB0CN = 0x07;                                                                  // Assert Acknowledge 
             -low (AA bit = 1b);
 546   1                                                                                          // Enable SMBus Free t
             -imeout detect;
 547   1          SMB0CR = 267 - (SYSTEM_CLOCK / (8 * SMB_FREQUENCY));                            // Derived approximati
             -on from the Tlow and Thigh equations
 548   1                                                                          
 549   1          SMB0CN |= 0x40;                                                                 // Enable SMBus;
 550   1      
 551   1          SFRPAGE = SFRPAGE_SAVE;                                                         // Restore SFR page de
             -tector
 552   1          
 553   1          SMB_BUSY = 0;                                                                   // Release SMB
 554   1      }
 555          
 556          //-------------------------------------------------------------------------------------------------------
 557          // Function Name: timer3Init
 558          // Return Value: None 
 559          // Parmeters: None
 560          // Function Description: This function nitializes timer 3 which is used to time out the SMB if errors occu
             -r
 561          //-------------------------------------------------------------------------------------------------------
 562          void timer3Init (void)
 563          {
 564   1          char SFRPAGE_SAVE = SFRPAGE;        
 565   1      
 566   1          SFRPAGE = TMR3_PAGE;
 567   1      
 568   1          TMR3CN = 0x00;                                                                  // Timer 3 in timer mo
             -de
 569   1                                                                                          // Timer 3 auto reload
 570   1          TMR3CF = 0x00;                                                                  // Timer 3 prescaler =
             - 12
 571   1      
 572   1          RCAP3 = -(SYSTEM_CLOCK / 12 / 40);                                              // Timer 3 overflows a
             -fter 25 ms
 573   1          TMR3 = RCAP3;                                                               
 574   1      
 575   1          TR3 = 1;                                                                        // Start Timer 3
 576   1      
 577   1          SFRPAGE = SFRPAGE_SAVE;                                                         // Restore SFR page
 578   1      }
 579          
 580          //-------------------------------------------------------------------------------------------------------
 581          // Function Name: timer3ISR
 582          // Return Value: None 
 583          // Parmeters: None
 584          // Function Description: This function is timer 3 ISR which is used to reset the SMB bus if the clock line
             - is held for too long
C51 COMPILER V9.56.0.0   MAIN                                                              11/21/2017 19:11:10 PAGE 12  

 585          //-------------------------------------------------------------------------------------------------------
 586          void timer3ISR(void) interrupt INTERRUPT_Timer_3
 587          {
 588   1          char SFRPAGE_SAVE = SFRPAGE;                                                    // Save Current SFR pa
             -ge
 589   1      
 590   1          SFRPAGE = SMB0_PAGE;
 591   1          SMB0CN &= ~0x40;                                                                // Disable SMBus
 592   1          SMB0CN |= 0x40;                                                                 // Re-enable SMBus
 593   1      
 594   1          SFRPAGE = SFRPAGE_SAVE;                                                         // Switch back to the 
             -Timer3 SFRPAGE
 595   1          TF3 = 0;                                                                        // Clear Timer3 interr
             -upt-pending flag
 596   1          SMB_BUSY = 0;                                                                   // Free bus
 597   1         
 598   1          SFRPAGE = SFRPAGE_SAVE;                                                         // Restore SFR page de
             -tector
 599   1      }
 600          
 601          //-------------------------------------------------------------------------------------------------------
 602          // Function Name: writeOneByteToSlave
 603          // Return Value: None 
 604          // Parmeters: target, startAddr, content
 605          // Function Description: This function writes one to the slave microprocessor
 606          //-------------------------------------------------------------------------------------------------------
 607          void writeOneByteToSlave(unsigned char startAddr, unsigned char content)
 608          {           
 609   1          sharedDataTx[startAddr] = content;
 610   1          smbWrite(MCU_SLAVE_ADDR, startAddr, 1);
 611   1      }
 612          
 613          //-------------------------------------------------------------------------------------------------------
 614          // Function Name: readOneByteFromSlave
 615          // Return Value: long 
 616          // Parmeters: startAddr, bytes
 617          // Function Description: This function reads one from the slave microprocessor
 618          //-------------------------------------------------------------------------------------------------------
 619          unsigned char readOneByteFromSlave(unsigned char startAddr)
 620          {
 621   1          smbRead(MCU_SLAVE_ADDR, startAddr, 1);
 622   1          return sharedDataRx[startAddr];                                                                       
             -                      
 623   1      }
 624          
 625          //-------------------------------------------------------------------------------------------------------
 626          // Function Name: smbRead
 627          // Return Value: unsigned char * 
 628          // Parmeters: target, startAddr, bytes
 629          // Function Description: This function reads from SM bus
 630          //-------------------------------------------------------------------------------------------------------
 631          void smbRead(unsigned char deviceId, unsigned int location, unsigned int bytes)
 632          {
 633   1          char SFRPAGE_SAVE = SFRPAGE;
 634   1      
 635   1          SFRPAGE = SMB0_PAGE;
 636   1          
 637   1          while(BUSY || SMB_BUSY);                                                        // Wait for free SMB
 638   1      
 639   1          SFRPAGE = SFRPAGE_SAVE;
 640   1              
 641   1          switch(deviceId)
C51 COMPILER V9.56.0.0   MAIN                                                              11/21/2017 19:11:10 PAGE 13  

 642   1          {
 643   2              case MCU_SLAVE_ADDR:
 644   2              case EEPROM_ADDR:
 645   2                  smbWrite(deviceId, location, 0);                                        // Write address befor
             -e reading
 646   2                  break;
 647   2              default:
 648   2                  break;  
 649   2          }
 650   1      
 651   1          SFRPAGE = SMB0_PAGE;
 652   1              
 653   1          while(BUSY || SMB_BUSY);
 654   1          slaveAddr = deviceId;                                                           // Address of MCU slav
             -e
 655   1          startAddr = location;                                                           // Starting address to
             - read from slave
 656   1          numBytesRD = bytes;                                                             // Number of bytes to 
             -read
 657   1          
 658   1          SMB_BUSY = 1;                                                                   // Claim SMBus (set to
             - busy)
 659   1          SMB_RW = 1;                                                                     // Mark this transfer 
             -as a READ
 660   1          STA = 1;
 661   1      
 662   1          while(BUSY || SMB_BUSY);                                                        // Wait for SMB
 663   1              
 664   1          SFRPAGE = SFRPAGE_SAVE;
 665   1                  
 666   1          switch(deviceId)
 667   1          {
 668   2              case MCU_SLAVE_ADDR:
 669   2                  while(slaveReadDone == 0);                                              // Wait until slave wr
             -ite completed
 670   2                  break;
 671   2              case EEPROM_ADDR:
 672   2                  while(eepromReadDone == 0);                                             // Wait until EEPROM w
             -rite completed
 673   2                  break;
 674   2              default:
 675   2                  break;  
 676   2          }    
 677   1      }
 678          
 679          //-------------------------------------------------------------------------------------------------------
 680          // Function Name: smbWrite
 681          // Return Value: unsigned char * 
 682          // Parmeters: target, startAddr, bytes
 683          // Function Description: This function reads to SM bus
 684          //-------------------------------------------------------------------------------------------------------
 685          void smbWrite(unsigned char deviceId, unsigned int location, unsigned int bytes)
 686          {
 687   1          unsigned char i = 0;
 688   1          unsigned int pageWrittenDelay = 0;
 689   1          char SFRPAGE_SAVE = SFRPAGE;
 690   1              
 691   1          SFRPAGE = SMB0_PAGE;
 692   1          
 693   1          while(BUSY || SMB_BUSY);                                                        // Wait for SMB to be 
             -free
 694   1          slaveAddr = deviceId;                                                           // Address of MCU slav
C51 COMPILER V9.56.0.0   MAIN                                                              11/21/2017 19:11:10 PAGE 14  

             -e board
 695   1          startAddr = location;                                                           // Starting address to
             - write to slave
 696   1      
 697   1          switch(deviceId)
 698   1          {
 699   2              case MCU_SLAVE_ADDR:                                                        // Pass through
 700   2              case DEVICE_DUMP_ADDR:                                                      // Pass through
 701   2                  numBytesWR = bytes;                                                     // Number of bytes to 
             -read
 702   2                  SMB_BUSY = 1;                                                           // Claim SMBus (set to
             - busy)
 703   2                  SMB_RW = 0;                                                             // Mark this transfer 
             -as a WRITE
 704   2                  STA = 1;                                                                // Start transfer
 705   2                  while(slaveWriteDone == 0);                                             // Wait until SRAM wri
             -te completed or timeout occurs
 706   2                  break;
 707   2              default:
 708   2                  break;      
 709   2          }
 710   1      
 711   1          SFRPAGE = SFRPAGE_SAVE;                                                         // Restore SFR page
 712   1      }
 713          
 714          //-------------------------------------------------------------------------------------------------------
 715          // Function Name: smbISR
 716          // Return Value: None 
 717          // Parmeters: None
 718          // Function Description: 
 719          // SMBus Interrupt Service Routine (ISR)
 720          // Anytime the SDA is pulled low by the master, this ISR will be called. For example, if STA = 1,
 721          // this ISR is called and SMB0STA = SMB_START = SMB_REPEAT_START. These cases are executed within the swit
             -ch statement.
 722          //-------------------------------------------------------------------------------------------------------
 723          void smbISR (void) interrupt INTERRUPT_SMB using 2
 724          {
 725   1          bit FAIL = 0;                                                                   // Used by the ISR to 
             -flag failed transfers
 726   1          static unsigned int TxCounter;                                                  // Initialize counter
 727   1          static unsigned int RxCounter;                                                  // Initialize counter
 728   1          static unsigned int slaveCount = 0;
 729   1          static unsigned int eepromCount = 0;
 730   1          static unsigned char eepromAddrDone;
 731   1          
 732   1          switch (SMB0STA >> 3)                                                           // Check SMB bus statu
             -s
 733   1          {
 734   2      //-------------------------------------------------------------------------------------------------------
 735   2      // Master Transmitter/Receiver: START condition transmitted. Load SMB0DAT with slave device address
 736   2      //-------------------------------------------------------------------------------------------------------
 737   2              case SMB_START:                                                             // Master initiates a 
             -transfer
 738   2      
 739   2      //-------------------------------------------------------------------------------------------------------
 740   2      // Master Transmitter/Receiver: repeated START condition transmitted. Load SMB0DAT with slave device addre
             -ss
 741   2      //-------------------------------------------------------------------------------------------------------
 742   2              case SMB_REPEAT_START:
 743   2                  SMB0DAT = slaveAddr;                                                    // Load address of the
             - slave.
 744   2                  SMB0DAT &= 0xFE;                                                        // Clear the LSB of th
C51 COMPILER V9.56.0.0   MAIN                                                              11/21/2017 19:11:10 PAGE 15  

             -e address for the R/W bit
 745   2                  SMB0DAT |= SMB_RW;                                                      // Load R/W bit (Read 
             -= 1; Write = 0)
 746   2                  STA = 0;                                                                // Manually clear STA 
             -bit
 747   2      
 748   2                  RxCounter = 0;                                                          // Reset the counter
 749   2                  TxCounter = 0;                                                          // Reset the counter
 750   2                  eepromAddrDone = CLEAR;                                                 // For 2 byte EEPROM a
             -ddress    
 751   2                  
 752   2                  break;
 753   2      
 754   2      //-------------------------------------------------------------------------------------------------------
 755   2      // Master Transmitter: Slave address + WRITE transmitted.  ACK received. For a READ: N/A
 756   2      // For a WRITE: Send the first data byte to the slave
 757   2      //-------------------------------------------------------------------------------------------------------
 758   2              case SMB_ADDR_W_TX_ACK_RX:
 759   2                  if(slaveAddr == MCU_SLAVE_ADDR)
 760   2                  {
 761   3                      if(startAddr == DEVICE_DUMP_ADDR)                                   // Dump device address
             - to check slave presence only
 762   3                      {
 763   4                          STO = 1;                                                        // Stop this transfer
 764   4                          SMB_BUSY = 0;                                                   // Releas SMB
 765   4                      }
 766   3                      else
 767   3                      {
 768   4                          SMB0DAT = startAddr;                                            // Send 1 byte address
             - to slave
 769   4                          slaveWriteDone = 0;                                             // Mark start of slave
             - write
 770   4                      }
 771   3                  }
 772   2                  break;
 773   2      
 774   2      //-------------------------------------------------------------------------------------------------------
 775   2      // Master Transmitter: Slave address + WRITE transmitted.  NACK received. Restart the transfer
 776   2      //-------------------------------------------------------------------------------------------------------
 777   2              case SMB_ADDR_W_TX_NACK_RX:
 778   2                  if(slaveAddr == MCU_SLAVE_ADDR || slaveAddr == WAVEFORM_GEN_ADDR)
 779   2                  {
 780   3                      if(slaveCount < MAX_NACK_RETRY)
 781   3                      {
 782   4                          slaveCount++;                                                   // Increment number of
             - attempts when NACK is received
 783   4                          STA = 1;                                                        // Restart a new trans
             -fer
 784   4                      }
 785   3                      else
 786   3                      {
 787   4                          slaveCount = 0;                                                 // Reset this counter 
             -to keep retry seeking slave response
 788   4                          slaveWriteDone = 1;
 789   4                          STO = 1;
 790   4                          SMB_BUSY = 0;
 791   4                          FAIL = 1;
 792   4                      }   
 793   3                  }
 794   2                  else if(slaveAddr == EEPROM_ADDR)
 795   2                  {
 796   3                      if(eepromCount < MAX_NACK_RETRY)
C51 COMPILER V9.56.0.0   MAIN                                                              11/21/2017 19:11:10 PAGE 16  

 797   3                      {
 798   4                          eepromCount++;                                                  // Increment number of
             - attempts when NACK is received
 799   4                          STA = 1;                                                        // Restart a new trans
             -fer
 800   4                      }
 801   3                      else
 802   3                      {
 803   4                          eepromCount = 0;
 804   4                          eepromWriteDone = 1;
 805   4                          STO = 1;
 806   4                          SMB_BUSY = 0;
 807   4                          FAIL = 1;
 808   4                      }   
 809   3                  }
 810   2                  else
 811   2                  {}
 812   2      
 813   2                  break;
 814   2      
 815   2      //-------------------------------------------------------------------------------------------------------
 816   2      //Master Transmitter: Data byte transmitted.  ACK received. For a READ: N/A
 817   2      //For a WRITE: Send all data.  After the last data byte, send the stop bit
 818   2      //-------------------------------------------------------------------------------------------------------
 819   2              case SMB_DATA_TX_ACK_RX:
 820   2                  if(slaveAddr == MCU_SLAVE_ADDR)
 821   2                  {
 822   3                      if(TxCounter < numBytesWR)
 823   3                      {
 824   4                          SMB0DAT = sharedDataTx[startAddr + TxCounter];                  // Send data byte
 825   4                          TxCounter++;
 826   4                      }
 827   3                      else
 828   3                      {
 829   4                          STO = 1;                                                        // Set STO to terminat
             -e transfer                                                
 830   4                          SMB_BUSY = 0;                                                   // And free SMBus inte
             -rface
 831   4                          slaveWriteDone = 1;                                             // Mark end of slave w
             -rite
 832   4                      }
 833   3                  }
 834   2                  break;
 835   2      
 836   2      //-------------------------------------------------------------------------------------------------------
 837   2      // Master Transmitter: Data byte transmitted.  NACK received. Restart the transfer
 838   2      //-------------------------------------------------------------------------------------------------------
 839   2              case SMB_DATA_TX_NACK_RX:
 840   2                  if(slaveAddr == MCU_SLAVE_ADDR)
 841   2                  {
 842   3                      if(slaveCount < MAX_NACK_RETRY)
 843   3                      {
 844   4                          slaveCount++;                                                   // Increment number of
             - attempts when NACK is received
 845   4                          STA = 1;                                                        // Restart a new trans
             -fer
 846   4                      }
 847   3                      else
 848   3                      {
 849   4                          slaveCount = 0;
 850   4                          STO = 1;
 851   4                          SMB_BUSY = 0;
C51 COMPILER V9.56.0.0   MAIN                                                              11/21/2017 19:11:10 PAGE 17  

 852   4                          FAIL = 1;
 853   4                      }   
 854   3                  }
 855   2                  else if(slaveAddr == EEPROM_ADDR)
 856   2                  {
 857   3                      if(eepromCount < MAX_NACK_RETRY)
 858   3                      {
 859   4                          eepromCount++;                                                  // Increment number of
             - attempts when NACK is received
 860   4                          STA = 1;                                                        // Restart a new trans
             -fer
 861   4                      }
 862   3                      else
 863   3                      {
 864   4                          eepromCount = 0;
 865   4                          STO = 1;
 866   4                          SMB_BUSY = 0;
 867   4                          FAIL = 1;
 868   4                      }   
 869   3                  }
 870   2                  else
 871   2                  {}
 872   2                  break;
 873   2      
 874   2      //-------------------------------------------------------------------------------------------------------
 875   2      // Master Receiver: Slave address + READ transmitted.  ACK received. 
 876   2      // For a READ: check if this is a one-byte transfer. if so, set the NACK after the data byte
 877   2      // is received to end the transfer. if not, set the ACK and receive the other data bytes
 878   2      //-------------------------------------------------------------------------------------------------------
 879   2              case SMB_ADDR_R_TX_ACK_RX:
 880   2                  if(numBytesRD == 1)                                                     // If there is one byt
             -e to transfer, send a NACK and go to
 881   2                  {                                                                       // SMB_DATA_RX_NACK_TX
             - case to accept data from slave
 882   3                      AA = 0;                                                             // Clear AA flag befor
             -e data byte is received
 883   3                                                                                          // send NACK signal to
             - slave after byte is received
 884   3                  }
 885   2                  else
 886   2                  {
 887   3                      AA = 1;                                                             // More than one byte 
             -in this transfer,
 888   3                                                                                          // send ACK after byte
             - is received
 889   3                  }
 890   2                  break;
 891   2      
 892   2      //-------------------------------------------------------------------------------------------------------
 893   2      // Master Receiver: Slave address + READ transmitted.  NACK received. Restart the transfer
 894   2      //-------------------------------------------------------------------------------------------------------
 895   2              case SMB_ADDR_R_TX_NACK_RX:
 896   2                  if(slaveAddr == MCU_SLAVE_ADDR)
 897   2                  {
 898   3                      if(slaveCount < MAX_NACK_RETRY)
 899   3                      {
 900   4                          slaveCount++;                                                   // Increment number of
             - attempts when NACK is received
 901   4                          STA = 1;                                                        // Restart transfer af
             -ter receiving a NACK
 902   4                      }
 903   3                      else
C51 COMPILER V9.56.0.0   MAIN                                                              11/21/2017 19:11:10 PAGE 18  

 904   3                      {
 905   4                          slaveCount = 0;                                                 // Reset counter
 906   4                          STO = 1;
 907   4                          SMB_BUSY = 0;
 908   4                          FAIL = 1;
 909   4                      }   
 910   3                  }
 911   2                  else if(slaveAddr == EEPROM_ADDR)
 912   2                  {
 913   3                      if(eepromCount < MAX_NACK_RETRY)
 914   3                      {
 915   4                          eepromCount++;                                                  // Increment number of
             - attempts when NACK is received
 916   4                          STA = 1;                                                        // Restart a new trans
             -fer
 917   4                      }
 918   3                      else
 919   3                      {
 920   4                          eepromCount = 0;
 921   4                          STO = 1;
 922   4                          SMB_BUSY = 0;
 923   4                          FAIL = 1;
 924   4                      }   
 925   3                  }
 926   2                  else
 927   2                  {}
 928   2                  break;
 929   2      
 930   2      //-------------------------------------------------------------------------------------------------------
 931   2      // Master Receiver: Data byte received. If AA flag was set beforehand, then ACK transmitted.
 932   2      // For a READ: receive each byte from the slave.  if this is the last byte, send a NACK and set the STOP b
             -it
 933   2      //-------------------------------------------------------------------------------------------------------
 934   2              case SMB_DATA_RX_ACK_TX:
 935   2                  
 936   2                  if(slaveAddr == MCU_SLAVE_ADDR)
 937   2                  {
 938   3                      if (RxCounter < numBytesRD)
 939   3                      {
 940   4                          sharedDataRx[startAddr + RxCounter] = SMB0DAT;
 941   4                          AA = 1;                                                         // Send ACK to indicat
             -e byte received
 942   4                          RxCounter++;                                                    // Increment the byte 
             -counter
 943   4                          slaveReadDone = 0;                                              // Mark start of slave
             - read
 944   4                      }
 945   3                      else
 946   3                      {
 947   4                          AA = 0;                                                         // Send NACK to indica
             -te last byte is received
 948   4                          slaveReadDone = 1;                                              // Mark end of slave r
             -ead
 949   4                      }
 950   3                  }
 951   2                  else if(slaveAddr == EEPROM_ADDR)
 952   2                  {
 953   3                      if(RxCounter < numBytesRD)
 954   3                      {
 955   4                          eepromDataByte = eepromRx[RxCounter] = SMB0DAT;
 956   4                          AA = 1;                                                         // Send ACK to indicat
             -e byte received
C51 COMPILER V9.56.0.0   MAIN                                                              11/21/2017 19:11:10 PAGE 19  

 957   4                          RxCounter++;                                                    // Increment the byte 
             -counter
 958   4                          eepromReadDone = 0;                                             // Mark start of fram 
             -read
 959   4                      }
 960   3                      else
 961   3                      {
 962   4                          AA = 0;                                                         // Send NACK to indica
             -te last byte is received
 963   4                          eepromReadDone = 1;                                             // Mark end of fram re
             -ad
 964   4                      }
 965   3                  }
 966   2                  break;
 967   2      
 968   2      //-------------------------------------------------------------------------------------------------------
 969   2      // Master Receiver: Data byte received. If AA flag was cleared, then NACK transmitted.
 970   2      // For a READ: Read operation has completed.  Read data register and send STOP
 971   2      //-------------------------------------------------------------------------------------------------------
 972   2              case SMB_DATA_RX_NACK_TX:
 973   2                  if(slaveAddr == MCU_SLAVE_ADDR)
 974   2                  {
 975   3                      sharedDataRx[startAddr + RxCounter] = SMB0DAT;
 976   3                      STO = 1;                                                            // Stop transfer
 977   3                      SMB_BUSY = 0;                                                       // Release SMB
 978   3                      AA = 1;
 979   3                      slaveReadDone = 1;                                                  // Mark end of slave r
             -ead                                                               // Set AA for next transfer                           
             -                              
 980   3                  }
 981   2                  else if(slaveAddr == EEPROM_ADDR)
 982   2                  {
 983   3                      eepromRx[RxCounter] = SMB0DAT;
 984   3                      STO = 1;                                                            // Stop transfer
 985   3                      SMB_BUSY = 0;                                                       // Release SMB
 986   3                      AA = 1;
 987   3                      eepromReadDone = 1;                                                 // Mark end of eeprom 
             -read      
 988   3                  }
 989   2                  break;
 990   2      
 991   2      //-------------------------------------------------------------------------------------------------------
 992   2      // Master Transmitter: Arbitration lost
 993   2      //-------------------------------------------------------------------------------------------------------
 994   2              case SMB_ARBITRATION_LOST:
 995   2                  FAIL = 1;                                                               // Indicate failed tra
             -nsfer
 996   2                                                                                          // and handle at end o
             -f ISR
 997   2                  break;
 998   2      
 999   2      //-------------------------------------------------------------------------------------------------------
1000   2      // All other status codes invalid.  Reset communication
1001   2      //-------------------------------------------------------------------------------------------------------
1002   2              default:
1003   2                  FAIL = 1;
1004   2                  break;
1005   2         }
1006   1      //-------------------------------------------------------------------------------------------------------
1007   1      // If all failed, reset everything
1008   1      //-------------------------------------------------------------------------------------------------------
1009   1          if(FAIL)                                                                        // If the transfer fai
C51 COMPILER V9.56.0.0   MAIN                                                              11/21/2017 19:11:10 PAGE 20  

             -led,
1010   1          {
1011   2              SMB0CN &= ~0x40;                                                            // Reset communication
1012   2              SMB0CN |= 0x40;
1013   2              STA = 0;
1014   2              STO = 0;
1015   2              AA = 0;
1016   2      
1017   2              SMB_BUSY = 0;                                                               // Free SMBus
1018   2      
1019   2              FAIL = 0;
1020   2                                                                                          // Set to finish all p
             -ending processes
1021   2              slaveWriteDone = 1;                                                         // Mark end of slave w
             -rite
1022   2              slaveReadDone = 1;                                                          // Mark end of slave r
             -ead
1023   2          }
1024   1      
1025   1          SI = 0;                                                                         // Clear interrupt fla
             -g
1026   1      }
1027          
1028          void display_text(const char * fg, const char * bg, const unsigned char size, const char * message, const 
             -int x, const int y)
1029          {
1030   1          char str[128] = { 0 };
1031   1          
1032   1          int i = 0;
1033   1          while(i < 10000) i++;
1034   1              
1035   1          sprintf(str, "S %s %s\r", fg, bg);
1036   1          sendCommand(str);
1037   1          sprintf(str, "f %s\r", Font[size]);
1038   1          sendCommand(str);
1039   1          sprintf(str, "t \"%s\" %u %u\r", message, x, y);
1040   1          sendCommand(str);
1041   1      }
1042          
1043          
1044          static void send_macro(const unsigned int macro_index)
1045          {
1046   1          char str[8] = { 0 };
1047   1          
1048   1          int i = 0;
1049   1          while(i < 10000) i++;
1050   1              
1051   1          sprintf(str, "m %u\r", macro_index);
1052   1          sendCommand(str);
1053   1      }
1054          
1055          //-------------------------------------------------------------------------------------------------------
1056          // Main
1057          //-------------------------------------------------------------------------------------------------------
1058          
1059          #define PAGE_MAIN            1
1060          #define PAGE_SETTINGS        2
1061          #define PAGE_SERVICE         3
1062          #define PAGE_CONFIG          4
1063          int current_page;
1064          
1065          void main()
C51 COMPILER V9.56.0.0   MAIN                                                              11/21/2017 19:11:10 PAGE 21  

1066          {
1067   1          int i = 0;
1068   1          int count = 0;
1069   1          int prev_temp = 0;
1070   1          int display_celsius = 0;
1071   1          int state_changed = 1;
1072   1          char str[SPRINTF_SIZE];
1073   1          
1074   1          disableWatchdog();
1075   1          systemClockInit();
1076   1          portInit();
1077   1          enableInterrupts();
1078   1          uart0Init();
1079   1          smbInit();
1080   1          timer3Init();
1081   1          
1082   1          tsLastCharGone = 1;
1083   1          tsTxOut = tsTxIn = 0;
1084   1          tsTxEmpty = 1;
1085   1          
1086   1          sprintf(str, "z\r");
1087   1          sendCommand(str);
1088   1          
1089   1          send_macro(Splash);
1090   1          
1091   1          while(1)
1092   1          {
1093   2              //scanUserInput();                                                        // Detect a string input
             - from the touch screen
1094   2              
1095   2              #define change_state(state) \
1096   2                  current_page = state;   \
1097   2                  state_changed = 1
1098   2      
1099   2      
1100   2              switch(current_page) 
1101   2              {
1102   3                  case (PAGE_SETTINGS):
1103   3                  {
1104   4                      if (state_changed) {
1105   5                          state_changed = 0;
1106   5                          display_text("000000", "FFFFFF", 8, "set!", 240, 110);
1107   5                      }
1108   4      
1109   4                      if ('1' == userCommand[1] && '3' == userCommand[2] && '1' == userCommand[3]) {
1110   5                          change_state(PAGE_SETTINGS);
1111   5                      }
1112   4                      else if ('1' == userCommand[1] && '2' == userCommand[2] && '8' == userCommand[3]) {
1113   5                          change_state(PAGE_MAIN);
1114   5                      }
1115   4                      else if ('1' == userCommand[1] && '3' == userCommand[2] && '2' == userCommand[3]) {
1116   5                          change_state(PAGE_SERVICE);
1117   5                      }
1118   4                      else {
1119   5                          // NOOP
1120   5                      }
1121   4                      break;
1122   4                  }
1123   3                  case (PAGE_CONFIG):
1124   3                  {
1125   4                      if (state_changed) {
1126   5                          state_changed = 0;
C51 COMPILER V9.56.0.0   MAIN                                                              11/21/2017 19:11:10 PAGE 22  

1127   5                          display_text("000000", "FFFFFF", 8, "cfg!", 240, 110);
1128   5                      }
1129   4              
1130   4                      if ('1' == userCommand[1] && '3' == userCommand[2] && '1' == userCommand[3]) {
1131   5                          change_state(PAGE_SETTINGS);
1132   5                      }
1133   4                      else if ('1' == userCommand[1] && '2' == userCommand[2] && '8' == userCommand[3]) {
1134   5                          change_state(PAGE_MAIN);
1135   5                      }
1136   4                      else if ('1' == userCommand[1] && '3' == userCommand[2] && '2' == userCommand[3]) {
1137   5                          change_state(PAGE_SERVICE);
1138   5                      }
1139   4                      else {
1140   5                          // NOOP
1141   5                      }
1142   4                      break;
1143   4                  }
1144   3                  case (PAGE_SERVICE):
1145   3                  {
1146   4                      if (state_changed) {
1147   5                          state_changed = 0;
1148   5                          display_text("000000", "FFFFFF", 8, "svc!", 240, 110);
1149   5                      }
1150   4                      
1151   4                      
1152   4                      /*for (k = 0; k < 4 ; k++){
1153   4                        if (passcode[k][0] == userCommand[1] && passcode[k][1] == userCommand[2] && passcode[k][2] == use
             -rCommand[3]) {
1154   4                        tsCommandReceived  = 0;
1155   4                          if (k == 3)
1156   4                            display_text("000000","FFFFFF",8,"OK!", 240,200);
1157   4                        while(tsCommandReceived == 0);
1158   4                       }
1159   4                        else{
1160   4                          continue;
1161   4                        }
1162   4                     }  */              
1163   4                      if ('1' == userCommand[1] && '3' == userCommand[2] && '1' == userCommand[3]) {
1164   5                          change_state(PAGE_SETTINGS);
1165   5                      }
1166   4                      else if ('1' == userCommand[1] && '2' == userCommand[2] && '8' == userCommand[3]) {
1167   5                          change_state(PAGE_MAIN);
1168   5                      }
1169   4                      else if ('1' == userCommand[1] && '3' == userCommand[2] && '2' == userCommand[3]) {
1170   5                          change_state(PAGE_SERVICE);
1171   5                      }
1172   4                      else {
1173   5                          // NOOP
1174   5                      }
1175   4                      break;
1176   4                  }
1177   3                  default:            // no break
1178   3                  case (PAGE_MAIN) :
1179   3                  {
1180   4                      roomTemp = readOneByteFromSlave(ROOM_TEMP);
1181   4      
1182   4                      if (state_changed) {
1183   5                          state_changed = 0;
1184   5                          sprintf(str, "%-3buC", roomTemp);
1185   5                          display_text("000000", "FFFFFF", 8, str, 240, 110);
1186   5                      }
1187   4                      
C51 COMPILER V9.56.0.0   MAIN                                                              11/21/2017 19:11:10 PAGE 23  

1188   4                      if (tsCommandReceived || roomTemp != prev_temp) 
1189   4                      {
1190   5                          prev_temp = roomTemp;
1191   5                          
1192   5                          if ('1' == userCommand[1] && '2' == userCommand[2] && '9' == userCommand[3]) {
1193   6                              display_celsius = 1;
1194   6                              sprintf(str, "%-3buC", roomTemp);
1195   6                              display_text("000000", "FFFFFF", 8, str, 240, 110);
1196   6                          }
1197   5                          else if ('1' == userCommand[1] && '3' == userCommand[2] && '0' == userCommand[3]) {
1198   6                              display_celsius = 0;
1199   6                              roomTemp = (roomTemp * 9) / 5 + 32;
1200   6                              sprintf(str, "%-3buF", roomTemp);
1201   6                              display_text("000000", "FFFFFF", 8, str, 240, 110);
1202   6                          }
1203   5                          else if ('1' == userCommand[1] && '3' == userCommand[2] && '1' == userCommand[3]) {
1204   6                              change_state(PAGE_SETTINGS);
1205   6                          }
1206   5                          else if ('1' == userCommand[1] && '2' == userCommand[2] && '8' == userCommand[3]) {
1207   6                              change_state(PAGE_MAIN);
1208   6                          }
1209   5                          else if ('1' == userCommand[1] && '3' == userCommand[2] && '2' == userCommand[3]) {
1210   6                              change_state(PAGE_SERVICE);
1211   6                          }
1212   5                          else {
1213   6                              // Noop
1214   6                          }
1215   5                      }
1216   4                      break;
1217   4                  }
1218   3              }
1219   2          }
1220   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   4101    ----
   CONSTANT SIZE    =    273    ----
   XDATA SIZE       =   3419     654
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =     11       1
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
